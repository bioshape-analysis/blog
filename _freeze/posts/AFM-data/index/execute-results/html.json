{
  "hash": "63b013051bafa4b515cdd0e82af3e4a1",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Extracting cell geometry from Atomic Force Microscopy\"\nsubtitle: \"Part 1: Static analysis\"\njupyter: python3\n\nauthor:\n  - name: \"Cl√©ment Soubrier\" \n    email: \"c.soubrier@math.ubc.ca\"\n    affiliations:\n      - name: KDD Group\n        url: \"https://rtviii.xyz/\"\n\n  - name: \"Khanh Dao Duc\" \n    email: \"kdd@math.ubc.ca\"\n    affiliations:\n      - name: Department of Mathematics, UBC\n        url: \"https://www.math.ubc.ca/\"\n      - name: Department of Computer Science, UBC\n        url: \"https://www.cs.ubc.ca/\"\n\ndate: \"July 31 2024\"\ncategories: [biology, bioinformatics]    \n\ncallout-icon: false\nformat:\n  html:\n    code-fold: true\nbibliography: bibliography.bib\n\nexecute:\n  echo: true\n  freeze: auto\n\n---\n\n\n\n\n\nWe present here the protocole to process biological images such as bacteria atomic force miroscopy data. We want to study the bacteria cell shape and extract the main geometrical feature.\n\n## Biological context\n*Mycobacterium smegmatis* is Grahm-positive rod shape bacterium. It is 3 to 5 $\\mu m$ long and around 500 $nm$ wide. This non-pathogenic species is otften used a biological model to study the pathogenic Mycobacteria such as *M.tuberculosis* (responsible for the tubercuosis) or *M.abscessus*, with which it shares the same cell wall structure [@tyagi2002mycobacterium]. In particular *M.smegmatis* has a fast growth (3-4 hours doubling time compared to 24h for *M. tuberculosis*), allowing for faster experimental protocols. \n\n\nHere are some know properties of *M.smegmatis* bacteria :\n\n* They present variation of cell diameter along their longitudinal axis [@eskandarian2017division]. The cell diameter is represented as a height profile along the cell centerline. We respectively name peaks and troughs the local maxima and minima of this proile.\n\n![3D image of *M.smegmatis*. The orange line represents the height profile.](3D_cell.png)\n\n* They grow following a biphasic and asymetrical polar dynamics [@hannebelle2020biphasic]. The cells elongate from the poles, where material is added. After division, the pre-existing pole (OP) elongate at a high rate, whereas the newly created pole (NP) has first a slow growth, and then switches to a fast growth, after the New End Take Off (NETO).\n\n![Growth dynamics.](Neto.svg)\n\n\n\n\n\n\n## Raw image pre-processing\n#### Data\n\nSeveral data acquisitions were conducted with wild types and different mutant strains. The raw data is composed of AFM log files times series for each experiments. Each log file contain several images, each one representing a physical channel such as height, stiffness, adhesion etc. After extraction of the data, forward and backward cells are aligned, artefacts such as image scars are detected and corrected.\n\n![At each time step, images representing different physical variables are produced by the AFM](Figure_1_quarto.png)\n\n## Segmentation\nAt each time steps, images are segmented to detect each cells using the cellpose package [@stringer2021cellpose]. If available, different physical channels are combined to improve the segmentation. Forward and backward images are also combined.\n\n![Images are combined to improve the segmentation](Figure_2_quarto.png)\n\nHere is an example on how to use cellpose on an image. Different models are available (with the `seg_mod` variable), depending on the training datasets. With cellpose 3, different denoising models are also available (with the `denoise_mod` variable). \n\n::: {#c67099f9 .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom cellpose import utils, io, models, denoise, plot\nfrom PIL import Image\n\n\n'''\nParameters\n'''\n\nimage_path = 'raw_img.png'\npath_to_save = 'segmented_img'\n# Segmentation model type\nseg_mod = 'cyto'   \n# Denoizing model\ndenoise_mod = \"denoise_cyto3\"  \n# Expected cell diameter (pixels)\ndia = 40\n# Type of segmentation (with / without nuclei, different color channels or not)\nchan = [0,0] \n# Segmentation sensibility parameters\nthres = 0.8\ncelp = 0.4\n\n'''\nComputing segmentation\n'''\n\n\n# Opening image to segment\nimg=np.array(Image.open(image_path))[:,:,1]\n\n# Chosing a model type :\nmodel = denoise.CellposeDenoiseModel(gpu=False, model_type=seg_mod, restore_type=denoise_mod)\n\n# Computing segmentaion\nmasks, flows, st, diams = model.eval(img, diameter = dia, channels=chan, flow_threshold = thres, cellprob_threshold=celp)\n\n\n# Saving the results into a numpy file\nio.masks_flows_to_seg(img, masks, flows, path_to_save, channels=chan, diams=diams)\n\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n/home/c.soubrier/Documents/UBC_Vancouver/Projets_recherche/bioshape_analysis_blog/blog/posts/AFM-data/.venv/lib/python3.12/site-packages/cellpose/resnet_torch.py:280: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.\n  state_dict = torch.load(filename, map_location=torch.device(\"cpu\"))\n```\n:::\n:::\n\n\nWe plot the final results :\n\n::: {#fee58a32 .cell execution_count=2}\n``` {.python .cell-code}\nplt.imshow(img,cmap='gray')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Raw image](index_files/figure-html/cell-3-output-1.png){width=575 height=307}\n:::\n:::\n\n\n::: {#47080349 .cell execution_count=3}\n``` {.python .cell-code}\nmask_RGB = plot.mask_overlay(img,masks)\nplt.imshow(mask_RGB)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Image with segmented masks overlaid](index_files/figure-html/cell-4-output-1.png){width=575 height=307}\n:::\n:::\n\n\n## Centerline\nSince we are interested in studying the variations of the cell diameter, we define height profile as the value of the cell height along the cell centerline. The cell centerline are computed using a skeletonization algorithm [@lee1994building]. \n\n# References\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}