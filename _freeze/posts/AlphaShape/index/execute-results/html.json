{
  "hash": "eaff9817af0041061ca19e4fa374e94b",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Alpha Shapes in 2D and 3D\"\ndate: \"August 14 2024\"\njupyter: python3\nauthor:\n  - name: \"Wenjun Zhao\" \ncategories: [theory]\n---\n\n\n## Introduction\n\nAlpha shapes are a generalization of the convex hull used in computational geometry. They are particularly useful for understanding the shape of a point cloud in both 2D and 3D spaces. In this document, we will explore alpha shapes in both dimensions using Python.\n\n**What is $\\alpha$ shape?** My favorite analogy (reference https://doc.cgal.org/latest/Alpha_shapes_2/index.html): \n\nImagine you have a huge mass of ice cream in either 2D or 3D, and the points are \"hard\" chocolate pieces which we would like to avoid. Using one of these round-shaped ice-cream spoons with radius $1/\\alpha$, we carve out all the ice cream without bumping into any of the chocolate pieces. Finally we straighten the round boundaries to obtain the so-called $\\alpha$ shape. \n\n**What is the $\\alpha$ parameter**? $1/\\alpha$ is the radius of your \"carving spoon\" and controls the roughness of your boundary. If the radius of spoon is too small ($\\alpha\\to \\infty$), all the ice cream can be carved out except the chocolate chips themselves, so eventually all data points become singletons and no information regarding the shape can be revealed. However, choosing big radius ($\\alpha \\approx 0$) may not be ideal either because it does not allow carving out anything, so we end up with a convex hull of all data points. In practice, be careful choosing your $\\alpha$!\n\n## 2D Alpha Shape\n\nTo illustrate alpha shapes in 2D, we'll use the `alphashape` library. Let's start by generating a set of random points and compute their alpha shape.\n\nFirst we create a point cloud:\n\n::: {#2750d981 .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport alphashape\nfrom matplotlib.path import Path\nfrom scipy.spatial import ConvexHull\n\ndef generate_flower_shape(num_petals, num_points_per_petal):\n    angles = np.linspace(0, 2 * np.pi, num_points_per_petal, endpoint=False)\n    r = 1 + 0.5 * np.sin(num_petals * angles)\n    \n    x = r* np.cos(angles)\n    \n    y = r * np.sin(angles)\n    \n    return np.column_stack((x, y))\n\ndef generate_random_points_within_polygon(polygon, num_points):\n    \"\"\"Generate random points inside a given polygon.\"\"\"\n    min_x, max_x = polygon[:, 0].min(), polygon[:, 0].max()\n    min_y, max_y = polygon[:, 1].min(), polygon[:, 1].max()\n    \n    points = []\n    while len(points) < num_points:\n        x = np.random.uniform(min_x, max_x)\n        y = np.random.uniform(min_y, max_y)\n        if Path(polygon).contains_point((x, y)):\n            points.append((x, y))\n    \n    return np.array(points)\n\nplt.figure(figsize=(8, 6))\npoints = generate_flower_shape(num_petals=6, num_points_per_petal=100)\npoints = generate_random_points_within_polygon(points, 1000)\nplt.scatter(points[:, 0], points[:, 1], s=10, color='blue', label='Points')\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-2-output-1.png){width=656 height=485}\n:::\n:::\n\n\nTry run this with alpha shape radius 0.1:\n\n::: {#9bc9b178 .cell execution_count=2}\n``` {.python .cell-code}\n# Create alpha shape\nalpha = 0.1\nalpha_shape = alphashape.alphashape(points, alpha)\n\n# Plot points and alpha shape\nplt.figure(figsize=(8, 6))\nplt.scatter(points[:, 0], points[:, 1], s=10, color='blue', label='Points')\nplt.plot(*alpha_shape.exterior.xy, color='red', lw=2, label='Alpha Shape')\nplt.title('2D Alpha Shape')\nplt.xlabel('X')\nplt.ylabel('Y')\nplt.legend()\nplt.grid(True)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-3-output-1.png){width=675 height=523}\n:::\n:::\n\n\nOops, it seems the radius we picked is too big! Let's try a few other choices.\n\n::: {#9a48e8ab .cell execution_count=3}\n``` {.python .cell-code}\nalpha_values = [0.1, 5.0, 10.0, 15.0]\n# Plot the flower shape and alpha shapes with varying alpha values\nfig, axes = plt.subplots(2, 2, figsize=(6,6))\naxes = axes.flatten()\n\nfor i, alpha in enumerate(alpha_values):\n    # Compute alpha shape\n    alpha_shape = alphashape.alphashape(points, alpha)\n    \n    # Plot the points and the alpha shape\n    ax = axes[i]\n    #print(alpha_shape.type)\n    if alpha_shape.type == 'Polygon':\n        ax.plot(*alpha_shape.exterior.xy, color='red', lw=2, label='Alpha Shape')\n    ax.scatter(points[:, 0], points[:, 1], color='orange', s=10, label='Point Cloud')\n    \n    \n    \n    ax.set_title(f'Alpha Shape with alpha={alpha}')\n    ax.legend()\n    ax.grid(True)\n\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n/var/folders/k7/s0t_zwg11h56xb5xp339s5pm0000gp/T/ipykernel_93289/885549844.py:13: ShapelyDeprecationWarning:\n\nThe 'type' attribute is deprecated, and will be removed in the future. You can use the 'geom_type' attribute instead.\n\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-4-output-2.png){width=573 height=565}\n:::\n:::\n\n\n## Application of 2D alpha shapes on reaction-diffusion equation\n\nReference: Zhao, Maffa, Sandstede. http://bjornsandstede.com/papers/Data_Driven_Continuation.pdf\n\n::: {#85e6426f .cell execution_count=4}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef brusselator_2d_simulation(A, B, Lx=100, Ly=100, Nx=100, Ny=100, dt=0.005, D_u=4, D_v=32, T=20):\n    \"\"\"\n    Simulate the 2D Brusselator model and return the concentration field u at time T.\n    \n    Parameters:\n    - A: Reaction parameter A\n    - B: Reaction parameter B\n    - Lx: Domain size in x direction\n    - Ly: Domain size in y direction\n    - Nx: Number of grid points in x direction\n    - Ny: Number of grid points in y direction\n    - dt: Time step\n    - D_u: Diffusion coefficient for u\n    - D_v: Diffusion coefficient for v\n    - T: Total simulation time\n    \n    Returns:\n    - u: Concentration field u at time T\n    \"\"\"\n    \n    # Initialize variables\n    dx, dy = Lx / Nx, Ly / Ny\n    u = np.random.uniform(size=(Nx, Ny))\n    v = np.zeros((Nx, Ny))\n    \n    \n    # Prepare the grid\n    x = np.linspace(0, Lx, Nx)\n    y = np.linspace(0, Ly, Ny)\n    \n    # Compute Laplacian\n    def laplacian(field):\n        return (np.roll(field, 1, axis=0) + np.roll(field, -1, axis=0) +\n                np.roll(field, 1, axis=1) + np.roll(field, -1, axis=1) -\n                4 * field) / (dx * dy)\n    \n    # Time-stepping loop\n    num_steps = int(T / dt)\n    for _ in range(num_steps):\n        # Compute Laplacian\n        lap_u = laplacian(u)\n        lap_v = laplacian(v)\n        \n        # Brusselator model equations\n        du = D_u * lap_u + A - (B + 1) * u + u**2 * v\n        dv = D_v * lap_v + B * u - u**2 * v\n        \n        # Update fields\n        u += du * dt\n        v += dv * dt\n    \n    return u, x, y\n\n# Example usage\nA = 4.75\nB = 11.0\nu_at_T, x, y = brusselator_2d_simulation(A, B)\n\n# Plot the result\nplt.figure(figsize=(8, 8))\nplt.imshow(u_at_T, cmap='viridis', interpolation='bilinear', origin='lower')\nplt.colorbar(label='Concentration of u')\nplt.title(f'Concentration of u at T=100 with A={A}, B={B}')\nplt.xlabel('x')\nplt.ylabel('y')\nplt.grid(True)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-5-output-1.png){width=644 height=611}\n:::\n:::\n\n\nCreate point cloud via thresholding the PDE solution:\n\n::: {#a9833af0 .cell execution_count=5}\n``` {.python .cell-code}\ndef get_threshold_points(u, threshold=0.7):\n    \"\"\"\n    Get grid points where the concentration field u exceeds the specified threshold.\n    \n    Parameters:\n    - u: Concentration field\n    - threshold: The threshold value as a percentage of the maximum value in u\n    \n    Returns:\n    - coords: Array of grid points where u exceeds the threshold\n    \"\"\"\n    max_u = np.max(u)\n    threshold_value = threshold * max_u\n    coords = np.argwhere(u > threshold_value)\n    return coords\n\n# Get grid points above 70% of the maximum value\ncoords = get_threshold_points(u_at_T, threshold=0.7)\n# Highlight points above threshold\nx_coords, y_coords = coords[:, 1], coords[:, 0]\nplt.scatter(x_coords, y_coords, color='red', s=20, marker='o', edgecolor='w')\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-6-output-1.png){width=575 height=411}\n:::\n:::\n\n\nTry a few alpha values\n\n::: {#2d90cb11 .cell execution_count=6}\n``` {.python .cell-code}\nalpha_values = [.3, 0.35, 0.5, 1.]\n# Plot the flower shape and alpha shapes with varying alpha values\nfig, axes = plt.subplots(2, 2, figsize=(6,6))\naxes = axes.flatten()\n\nfor i, alpha in enumerate(alpha_values):\n    # Scatter the plot\n    \n    # Compute alpha shape\n    alpha_shape = alphashape.alphashape(coords, alpha)\n    #print(alpha_shape.type)\n    # Plot the points and the alpha shape\n    plt.subplot(2,2,i+1)\n    #ax = axes[i]\n    \n    if alpha_shape.geom_type == 'GeometryCollection':\n        print(alpha_shape)\n        for geom in list( alpha_shape.geoms ):\n            \n            if geom.type == 'Polygon':\n                x, y = geom.exterior.xy\n                plt.plot(x, y, 'r-')\n    elif alpha_shape.geom_type == 'Polygon':\n                x, y = alpha_shape.exterior.xy\n                plt.plot(x, y, 'r-')\n    elif alpha_shape.geom_type == 'MultiPolygon':\n        \n        alpha_shape = list( alpha_shape.geoms )\n        for polygon in alpha_shape:\n            x, y = polygon.exterior.xy\n            plt.plot(x, y, 'r-')#, label='Alpha Shape')\n    plt.scatter(coords[:, 0], coords[:, 1], color='orange', s=10, label='Point Cloud')\n    \n    \n    \n    plt.title(f'alpha={alpha}')\n    #plt.legend()\n    #plt.grid(True)\n\nplt.tight_layout()\nplt.show()\n\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-7-output-1.png){width=566 height=565}\n:::\n:::\n\n\nNow we can study different pattern statistics for these clusters! For example, the area:\n\n::: {#69668b98 .cell execution_count=7}\n``` {.python .cell-code}\nalpha_values = [.3, 0.4, 0.6, 1.]\n# Plot the flower shape and alpha shapes with varying alpha values\nfig, axes = plt.subplots(2, 2, figsize=(6,6))\naxes = axes.flatten()\n\nfor i, alpha in enumerate(alpha_values):\n    plt.subplot(2,2,i+1)\n    # Compute alpha shape\n    alpha_shape = alphashape.alphashape(coords, alpha)\n    if alpha_shape.geom_type == 'MultiPolygon':\n        # Extract and print the area of each polygon\n        areas = [polygon.area for polygon in list(alpha_shape.geoms)]\n        perimeters = [polygon.length for polygon in list(alpha_shape.geoms)]\n        roundness = [4*np.pi*areas[i]/perimeters[i]**2 for i in range(len(list(alpha_shape.geoms))) ]\n    else:\n        areas = [ alpha_shape.area ]\n        perimeters = [alpha_shape.length]\n        roundness = [areas[0]*4*np.pi/perimeters[0]**2]\n    plt.hist(roundness,density=True, range=[0,1])\n    plt.xlim([0,1])\n    plt.title(f'Distribution of roundness with alpha={alpha}')\n    \n\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-8-output-1.png){width=629 height=565}\n:::\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}