{
  "hash": "06a60bfecddb063afc37f7518e9a8a91",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Shape Analysis of Contractile Cells\nexecute:\n  freeze: true\n  date: December 16 2024\nauthor:\n  - name: Yuqi Xiao\ncategories:\n  - biology\n  - cell morphology\nbibliography: references.bib\njupyter: .venv\n---\n\n\n# Introduction\n\nCapsular contracture (CC) is an ailing complication that arises commonly amonst breast cancer patients after reconstructive breast implant surgery. CC patients suffer from aesthetic deformation, pain, and in rare cases, they may develop anaplastic large cell lymphoma (ALCL), a type of cancer of the immune system. The mechanism of CC is unknown, and there are few objective assessments of CC based on histology.\n\n<center><img src=\"Baker_grade.png\" width=\"600\"/></center>\n<center>Figure 1: Baker grade</center>\n\nBaker grade is a subjective, clinical evaluation for the extent of CC (See Fig 1). Many researchers have measured histological properties in CC tissue samples, and correlated theses findings to their assigned Baker grade. It has been found that a high density of immune cells is associated with higher Baker grade. \n\nThese immune cells include fibroblasts and myofibroblasts, which can distort surrounding tissues by contracting and pulling on them. The transition from the fibroblast to myofibroblast phenotype is an important driving step in many fibrotic processes including capsular contracture. In wound healing processes, the contactility of myofibroblasts is essential in facilitating tissue remodelling, however, an exess amount of contratile forces creates a positive feedback loop of enhanced immune cell recruitment, leading to the formation of pathological capsules with high density and extent of deformation. \n\nMyofibroblasts, considered as an \"activated\" form of fibroblasts, is identified by the expression of alpha-smooth muscle actin ($\\alpha$-SMA). However, this binary classification system does not capture the full range of complexities involved in the transition between these two phenotypes. Therefore, it is beneficial to develop a finer classification system of myofibroblasts to explain various levels of forces they can generate. One recent work uses pre-defined morphological features of cells, including perimeter and circularity, to create a continuous spectrum of myofibroblast activation [@hillsley2022strategy].\n\n[//]: # (Past work 1 including single cell force profiling: https://pmc.ncbi.nlm.nih.gov/articles/PMC7104857/#s2)\n[//]: # (Past work 2 including morphological features: https://pmc.ncbi.nlm.nih.gov/articles/PMC9293987/#Sec2)\n\nResearch suggests that mechanical strain induces change in cell morphology, inducing round cells that are lacking in stress fibers into more broad, elongated shapes. We hypothesize that cell shapes influence their ability to generate forces via mechanisms of cell-matrix adheshion and cell traction. Further, we hypothesis that cell shape is directly correlated with the severity of CC by increasing contractile forces.\n\nIn order to test these hypothesis, we will take a 2-step approach. The first step involves statistical analysis on correlation between cell shapes and their associated Baker grade. To do this, we collect cell images from CC samples with various Baker grades, using Geomstat we can compute a characteristic mean cell shape for each sample. Then, we cluster these characteristic cell shapes into 4 groups, and observe the extent of overlap between this classification and the Baker grade. We choose the elastic metric, associated with its geodesic distances, since it allows us to not only looking at classification, but also how cell shape deforms. If we can find a correlation, the second step is then to go back to in-vitro studies of fibroblasts, and answer the question: can the shapes of cells predict their disposition to developing into a highly contractile phenotype (linked to more severe CC)? I don't have a concrete plan for this second step yet, however, it motivates this project as it may suggest a way to predict clinical outcomes based on pre-operative patient assessment. \n\n# Cell Segmentation\n\nI was provided with histological images of CC tissues, by a group in Coppenhagen \\{add credit and citations\\}. The images are $\\alpha$-SMA stained to visualize myofibroblasts, each image is associated with a Baker Grade and the age of the implant. The first step is to preprocess the images and segment the cells. After some attempts with different segmentation algorithms, I opted to use a custom segmentation model with squidpy.\n\n::: {#ba12dd55 .cell execution_count=1}\n``` {.python .cell-code}\nimport sys\nfrom pathlib import Path\nfrom decimal import Decimal\nimport matplotlib.pyplot as plt\n\nsys.path=['', '/opt/petsc/linux-c-opt/lib', '/home/uki', '/usr/lib/python312.zip', '/usr/lib/python3.12', '/usr/lib/python3.12/lib-dynload', '/home/uki/Desktop/blog/posts/CC-cells/.venv/lib/python3.12/site-packages']\n\nimport numpy as np\nimport seaborn as sns\nimport squidpy as sq\n```\n:::\n\n\n## Example workflow\n\nFor each image, we go through the following process for cell segmentation.\n\n::: {#e306b087 .cell execution_count=2}\n``` {.python .cell-code}\nfilename = '/home/uki/Desktop/blog/posts/CC-cells/images/low/7-1.tif'\nimg = sq.im.ImageContainer(filename)\n\n# smooth image\nsq.im.process(img, layer=\"image\", method=\"smooth\", sigma=0) #sigma value depends on the quality of each image, needs to be manually adjusted\n\n# plot the result\nfig, axes = plt.subplots(1, 2)\nfor layer, ax in zip([\"image\", \"image_smooth\"], axes):\n    img.show(layer, ax=ax)\n    ax.set_title(layer)\n```\n\n::: {.cell-output .cell-output-display}\n![](Shape_Analysis_of_Contractile_Cells_files/figure-html/cell-3-output-1.png){width=540 height=104}\n:::\n:::\n\n\n::: {#d800099c .cell execution_count=3}\n``` {.python .cell-code}\nfig, axes = plt.subplots(1, 3, figsize=(15, 4))\nimg.show(\"image_smooth\", cmap=\"gray\", ax=axes[0])\naxes[1].imshow(img[\"image_smooth\"][:, :, 0, 0] < 110)  # in this case, setting the threshold at 110 gives us reasonable results\n_ = sns.histplot(np.array(img[\"image_smooth\"]).flatten(), bins=50, ax=axes[2])\nplt.tight_layout()\n\nplt.show() #Second images are smoothed, then flattened, then histogram\n```\n\n::: {.cell-output .cell-output-display}\n![](Shape_Analysis_of_Contractile_Cells_files/figure-html/cell-4-output-1.png){width=1430 height=373}\n:::\n:::\n\n\n::: {#68416ee9 .cell execution_count=4}\n``` {.python .cell-code}\nsq.im.segment(img=img, layer=\"image_smooth\", method=\"watershed\", thresh=110, geq=False)\n# NOTE: This thresh must be adjusted per image analyzed based on histogram\n```\n:::\n\n\n::: {#7e4f679a .cell execution_count=5}\n``` {.python .cell-code}\nprint(img)\nprint(f\"Number of segments in crop: {len(np.unique(img['segmented_watershed']))}\")\n\nfig, axes = plt.subplots(1, 2)\nimg.show(\"image\", channel=0, ax=axes[0])\n_ = axes[0].set_title(\"H&E\")\nimg.show(\"segmented_watershed\", cmap=\"jet\", interpolation=\"none\", ax=axes[1])\n_ = axes[1].set_title(\"segmentation\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nImageContainer[shape=(182, 670), layers=['image', 'image_smooth', 'segmented_watershed']]\nNumber of segments in crop: 281\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](Shape_Analysis_of_Contractile_Cells_files/figure-html/cell-6-output-2.png){width=540 height=104}\n:::\n:::\n\n\n## Some data wrangling\n\nWe get a lot of cells from the segmented image. Unfortunately, the segmentation results are not immediately usable for our purposes, so I write an inelegenat script to find the identified cell borders. In this process we get rid of a large portion of segmentations that are unusable. \n\n::: {#1de7474e .cell execution_count=6}\n``` {.python .cell-code}\nmy_array = img[\"segmented_watershed\"].data #plain numpy array of cellseg data\nmy_array = my_array.squeeze()\nmy_rows, my_cols = my_array.shape\nmark_for_deletion = np.zeros((my_rows,my_cols),dtype=np.int8)\n\n#intentionally omit boundaries\nfor x in range(1,my_cols-1):\n  for y in range(1,my_rows-1):\n    val = my_array[y,x]\n    if val == 0: #Not a cell so no processing required\n      continue\n    #Not zero so this pixel is a cell\n    #Mark for deletion if all cardinal neighbors are part of the same cell\n    if my_array[y-1,x] != val:\n      continue\n    if my_array[y+1,x] != val:\n      continue\n    if my_array[y,x-1] != val:\n      continue\n    if my_array[y,x+1] != val:\n      continue\n    mark_for_deletion[y,x] = 1\n\nfor x in range(1,my_cols-1):\n  for y in range(1,my_rows-1):\n    if mark_for_deletion[y,x] == 1:\n      my_array[y,x] = 0\n\nplt.imshow(my_array,interpolation='none')\nplt.show() #Third image shown is the borders I derived\n```\n\n::: {.cell-output .cell-output-display}\n![](Shape_Analysis_of_Contractile_Cells_files/figure-html/cell-7-output-1.png){width=575 height=188}\n:::\n:::\n\n\nSome more work is required to find 2D coordinates resulting from this, we take away borders with too few data points to work with. This step runs quite slow at the moment and could be optimized.\n\n::: {#1e6d2203 .cell execution_count=7}\n``` {.python .cell-code}\nmy_cell_borders = []\n\nfor val in np.unique(my_array):\n    temp_array = []\n    if val == 0:\n        continue\n    for x in range(0,my_cols):\n        for y in range(0,my_rows):\n            if my_array[y,x] == val:\n                temp_array.append(np.array([y,x]))\n    if len(temp_array)>9:\n        my_cell_borders.append(np.array(temp_array))\n```\n:::\n\n\nWe repeat this process for several images, due to the inconsistencies in the qualities of our obtained images, special image processing steps had to be designed for each image and implemented manually. These steps are omitted here, eventually we obtain 2 separate lists of 2D cell coordinates, for low grade (Baker I&II) and high grade (Baker III&IV) samples respectively.\n\n::: {#159ae9cd .cell execution_count=8}\n``` {.python .cell-code}\nimport pickle\n\nwith open('low-grade.pkl', 'rb') as fp:\n    low_grade_cells = pickle.load(fp)\n\nwith open ('high-grade.pkl', 'rb') as fp:\n    high_grade_cells = pickle.load(fp)\n\ncells = low_grade_cells + high_grade_cells\n\nprint(f\"Total number of cells : {len(low_grade_cells)+len(high_grade_cells)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTotal number of cells : 295\n```\n:::\n:::\n\n\n# Pre-Processing\n\n## Sort labelling data\n\nSince the data is unordered, we need to sort the coordinates in order to visualize cell shapes.\n\n::: {#db5cc440 .cell execution_count=9}\n``` {.python .cell-code}\ndef sort_coordinates(list_of_xy_coords):\n    cx, cy = list_of_xy_coords.mean(0)\n    x, y = list_of_xy_coords.T\n    angles = np.arctan2(x-cx, y-cy)\n    indices = np.argsort(angles)\n    return list_of_xy_coords[indices]\n```\n:::\n\n\n::: {#a6f3b30d .cell execution_count=10}\n``` {.python .cell-code}\nsorted_cells = []\n\nfor cell in cells:\n    sorted_cells.append(sort_coordinates(cell))\n```\n:::\n\n\n::: {#83ce0a87 .cell execution_count=11}\n``` {.python .cell-code}\nindex = 2\ncell_rand = cells[index]\ncell_sorted = sorted_cells[index]\n\nfig = plt.figure(figsize=(15, 5))\n\nfig.add_subplot(121)\nplt.scatter(cell_rand[:, 0], cell_rand[:, 1], color='black', s=4)\n\nplt.plot(cell_rand[:, 0], cell_rand[:, 1])\nplt.axis(\"equal\")\nplt.title(f\"Original coordinates\")\nplt.axis(\"off\")\n\nfig.add_subplot(122)\nplt.scatter(cell_sorted[:, 0], cell_sorted[:, 1], color='black', s=4)\n\nplt.plot(cell_sorted[:, 0], cell_sorted[:, 1])\nplt.axis(\"equal\")\nplt.title(f\"sorted coordinates\")\nplt.axis(\"off\")\n```\n\n::: {.cell-output .cell-output-display}\n![](Shape_Analysis_of_Contractile_Cells_files/figure-html/cell-12-output-1.png){width=1135 height=409}\n:::\n:::\n\n\n## Interpolation and removing duplicate sample points\n\n::: {#82ac5231 .cell execution_count=12}\n``` {.python .cell-code}\nimport geomstats.backend as gs\nfrom common import *\nimport random\nimport os\nimport scipy.stats as stats\nfrom sklearn import manifold\n\ngs.random.seed(2024)\n```\n:::\n\n\n::: {#f80599dd .cell execution_count=13}\n``` {.python .cell-code}\ndef interpolate(curve, nb_points):\n    \"\"\"Interpolate a discrete curve with nb_points from a discrete curve.\n\n    Returns\n    -------\n    interpolation : discrete curve with nb_points points\n    \"\"\"\n    old_length = curve.shape[0]\n    interpolation = gs.zeros((nb_points, 2))\n    incr = old_length / nb_points\n    pos = 0\n    for i in range(nb_points):\n        index = int(gs.floor(pos))\n        interpolation[i] = curve[index] + (pos - index) * (\n            curve[(index + 1) % old_length] - curve[index]\n        )\n        pos += incr\n    return interpolation\n    \nk_sampling_points = 500\n```\n:::\n\n\n::: {#516e3b78 .cell execution_count=14}\n``` {.python .cell-code}\nindex = 2\ncell_rand = sorted_cells[index]\ncell_interpolation = interpolate(cell_rand, k_sampling_points)\n\nfig = plt.figure(figsize=(15, 5))\n\nfig.add_subplot(121)\nplt.scatter(cell_rand[:, 0], cell_rand[:, 1], color='black', s=4)\n\nplt.plot(cell_rand[:, 0], cell_rand[:, 1])\nplt.axis(\"equal\")\nplt.title(f\"Original curve ({len(cell_rand)} points)\")\nplt.axis(\"off\")\n\nfig.add_subplot(122)\nplt.scatter(cell_interpolation[:, 0], cell_interpolation[:, 1], color='black', s=4)\n\nplt.plot(cell_interpolation[:, 0], cell_interpolation[:, 1])\nplt.axis(\"equal\")\nplt.title(f\"Interpolated curve ({k_sampling_points} points)\")\nplt.axis(\"off\")\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n(np.float64(29.650000000000006),\n np.float64(37.349999999999895),\n np.float64(551.6),\n np.float64(560.4))\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](Shape_Analysis_of_Contractile_Cells_files/figure-html/cell-15-output-2.png){width=1135 height=409}\n:::\n:::\n\n\n::: {#48a39d17 .cell execution_count=15}\n``` {.python .cell-code}\ndef preprocess(curve, tol=1e-10):\n    \"\"\"Preprocess curve to ensure that there are no consecutive duplicate points.\n    Returns\n    -------\n    curve : discrete curve\n    \"\"\"\n\n    dist = curve[1:] - curve[:-1]\n    dist_norm = np.sqrt(np.sum(np.square(dist), axis=1))\n\n    if np.any( dist_norm < tol ):\n        for i in range(len(curve)-1):\n            if np.sqrt(np.sum(np.square(curve[i+1] - curve[i]), axis=0)) < tol:\n                curve[i+1] = (curve[i] + curve[i+2]) / 2\n\n    return curve\n```\n:::\n\n\n::: {#692170d5 .cell execution_count=16}\n``` {.python .cell-code}\ninterpolated_cells = []\n\nfor cell in sorted_cells:\n    interpolated_cells.append(preprocess(interpolate(cell, k_sampling_points)))\n```\n:::\n\n\n## Alignment\n\n::: {#7557cddd .cell execution_count=17}\n``` {.python .cell-code}\nfrom geomstats.geometry.pre_shape import PreShapeSpace\n\nAMBIENT_DIM = 2\n\nPRESHAPE_SPACE = PreShapeSpace(ambient_dim=AMBIENT_DIM, k_landmarks=k_sampling_points)\n\nPRESHAPE_SPACE.equip_with_group_action(\"rotations\")\nPRESHAPE_SPACE.equip_with_quotient()\n\n\ndef exhaustive_align(curve, base_curve):\n    \"\"\"Align curve to base_curve to minimize the L² distance.\n\n    Returns\n    -------\n    aligned_curve : discrete curve\n    \"\"\"\n    nb_sampling = len(curve)\n    distances = gs.zeros(nb_sampling)\n    base_curve = gs.array(base_curve)\n    for shift in range(nb_sampling):\n        reparametrized = [curve[(i + shift) % nb_sampling] for i in range(nb_sampling)]\n        aligned = PRESHAPE_SPACE.fiber_bundle.align(\n            point=gs.array(reparametrized), base_point=base_curve\n        )\n        distances[shift] = PRESHAPE_SPACE.embedding_space.metric.norm(\n            gs.array(aligned) - gs.array(base_curve)\n        )\n    shift_min = gs.argmin(distances)\n    reparametrized_min = [\n        curve[(i + shift_min) % nb_sampling] for i in range(nb_sampling)\n    ]\n    aligned_curve = PRESHAPE_SPACE.fiber_bundle.align(\n        point=gs.array(reparametrized_min), base_point=base_curve\n    )\n    return aligned_curve\n```\n:::\n\n\n::: {#5d8311a3 .cell execution_count=18}\n``` {.python .cell-code}\naligned_cells = []\nBASE_CURVE = interpolated_cells[0]\n\nfor cell in interpolated_cells:\n    aligned_cells.append(exhaustive_align(cell, BASE_CURVE))\n```\n:::\n\n\n::: {#a7af4259 .cell execution_count=19}\n``` {.python .cell-code}\nindex = 1\nunaligned_cell = interpolated_cells[index]\naligned_cell = exhaustive_align(unaligned_cell, BASE_CURVE)\n\nfig = plt.figure(figsize=(15, 5))\n\nfig.add_subplot(131)\nplt.plot(BASE_CURVE[:, 0], BASE_CURVE[:, 1])\nplt.plot(BASE_CURVE[0, 0], BASE_CURVE[0, 1], \"ro\")\nplt.axis(\"equal\")\nplt.title(\"Reference curve\")\n\nfig.add_subplot(132)\nplt.plot(unaligned_cell[:, 0], unaligned_cell[:, 1])\nplt.plot(unaligned_cell[0, 0], unaligned_cell[0, 1], \"ro\")\nplt.axis(\"equal\")\nplt.title(\"Unaligned curve\")\n\nfig.add_subplot(133)\nplt.plot(aligned_cell[:, 0], aligned_cell[:, 1])\nplt.plot(aligned_cell[0, 0], aligned_cell[0, 1], \"ro\")\nplt.axis(\"equal\")\nplt.title(\"Aligned curve\")\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\nText(0.5, 1.0, 'Aligned curve')\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](Shape_Analysis_of_Contractile_Cells_files/figure-html/cell-20-output-2.png){width=1171 height=431}\n:::\n:::\n\n\n# Data Analysis\n\n## Computing mean cell shapes\n\nIt is not particularly meaningful to compute a global mean cell shape, but here we may generate some reference data and some simple, reproducible steps for more in-depth analysis.\n\n::: {#208fde23 .cell execution_count=20}\n``` {.python .cell-code}\nfrom geomstats.geometry.discrete_curves import DiscreteCurvesStartingAtOrigin\nfrom geomstats.learning.frechet_mean import FrechetMean\n\nCURVES_SPACE_SRV = DiscreteCurvesStartingAtOrigin(ambient_dim=2, k_sampling_points=k_sampling_points)\n\nmean = FrechetMean(CURVES_SPACE_SRV)\n\ncell_shapes_at_origin = CURVES_SPACE_SRV.projection(gs.array(aligned_cells))\nmean.fit(cell_shapes_at_origin[:500])\n\nmean_estimate = mean.estimate_\n\nplt.plot(mean_estimate[:, 0], mean_estimate[:, 1], \"black\");\n```\n\n::: {.cell-output .cell-output-display}\n![](Shape_Analysis_of_Contractile_Cells_files/figure-html/cell-21-output-1.png){width=571 height=411}\n:::\n:::\n\n\n::: {#a294b979 .cell execution_count=21}\n``` {.python .cell-code}\nprint(gs.sum(gs.isnan(mean_estimate)))\nmean_estimate_clean = mean_estimate[~gs.isnan(gs.sum(mean_estimate, axis=1)), :]\nprint(mean_estimate_clean.shape)\nmean_estimate_clean = interpolate(mean_estimate_clean, k_sampling_points - 1)\nprint(gs.sum(gs.isnan(mean_estimate_clean)))\nprint(mean_estimate_clean.shape)\n\nprint(cell_shapes_at_origin.shape)\nfor cell_at_origin in cell_shapes_at_origin:\n    plt.plot(cell_at_origin[:, 0], cell_at_origin[:, 1], \"lightgrey\", alpha=0.2)\n\nplt.plot(\n    mean_estimate_clean[:, 0], mean_estimate_clean[:, 1], \"black\", label=\"Mean cell\"\n)\nplt.legend(fontsize=12);\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0\n(499, 2)\n0\n(499, 2)\n(295, 499, 2)\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](Shape_Analysis_of_Contractile_Cells_files/figure-html/cell-22-output-2.png){width=566 height=411}\n:::\n:::\n\n\nWe adjust the scaling manually.\n\n::: {#80f3dc35 .cell execution_count=22}\n``` {.python .cell-code}\nmean_estimate_aligned = 1.8 * mean_estimate_clean\n\nfor cell_at_origin in cell_shapes_at_origin:\n    plt.plot(cell_at_origin[:, 0], cell_at_origin[:, 1], \"lightgrey\", alpha=0.2)\n\nplt.plot(\n    mean_estimate_aligned[:, 0], mean_estimate_aligned[:, 1], \"black\", label=\"Mean cell\"\n)\nplt.legend(fontsize=12);\n```\n\n::: {.cell-output .cell-output-display}\n![](Shape_Analysis_of_Contractile_Cells_files/figure-html/cell-23-output-1.png){width=566 height=411}\n:::\n:::\n\n\nWe compute the distance from each cell to the global mean cell shape, and plot the results on a histogram. It's seen here that the majority of cells are close to the global mean. \n\n::: {#ceb51305 .cell execution_count=23}\n``` {.python .cell-code}\ndists_to_global_mean_list = []\nfor cell in aligned_cells:\n    dists_to_global_mean_list.append(CURVES_SPACE_SRV.metric.dist(CURVES_SPACE_SRV.projection(cell), mean_estimate_aligned))\n```\n:::\n\n\n::: {#e6570a34 .cell execution_count=24}\n``` {.python .cell-code}\nmin_dists = min(dists_to_global_mean_list)\nmax_dists = max(dists_to_global_mean_list)\nprint(min_dists, max_dists)\nxx = gs.linspace(gs.floor(min_dists), gs.ceil(max_dists), 100)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1.4633405312629748 8.794301541946876\n```\n:::\n:::\n\n\n::: {#01b964c7 .cell execution_count=25}\n``` {.python .cell-code}\nfrom scipy import stats\nfig, axs = plt.subplots(1, sharex=True, sharey=True, tight_layout=True, figsize=(8, 4))\n\nfor i in enumerate(aligned_cells):\n    distances = dists_to_global_mean_list\n    axs.hist(distances, bins=10, alpha=0.4, density=True)\n    kde = stats.gaussian_kde(distances)\n    axs.plot(xx, kde(xx))\n    axs.set_xlim((min_dists, max_dists))\n\n    axs.set_ylabel(\"Fraction of cells\", fontsize=14)\n\nfig.suptitle(\n    \"Histograms of srv distances (a=1, b=0.5) to global mean cell\", fontsize=20\n)\n```\n\n::: {.cell-output .cell-output-display execution_count=25}\n```\nText(0.5, 0.98, 'Histograms of srv distances (a=1, b=0.5) to global mean cell')\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](Shape_Analysis_of_Contractile_Cells_files/figure-html/cell-26-output-2.png){width=837 height=381}\n:::\n:::\n\n\n## Differences between low and high grade cells\n\nNow, we attempt to characterize geometric differences between cells from low vs. high grade CC samples. Perhaps as expected, we see a more rounded shape for low grade cells, and a more long, spindle shape for high grade cells.\n\n::: {#afbab1e7 .cell execution_count=26}\n``` {.python .cell-code}\nlow = aligned_cells[0:167]\nhigh = aligned_cells[168:len(aligned_cells)]\n\nlow_shapes = CURVES_SPACE_SRV.projection(gs.array(low))\nmean.fit(low_shapes[:500])\nmean_estimate_low = mean.estimate_\n\nhigh_shapes = CURVES_SPACE_SRV.projection(gs.array(high))\nmean.fit(high_shapes[:500])\nmean_estimate_high = mean.estimate_\n\nfig = plt.figure(figsize=(15, 5))\n\nfig.add_subplot(121)\nplt.plot(mean_estimate_low[:, 0], mean_estimate_low[:, 1], \"black\");\nplt.axis(\"equal\")\nplt.title(f\"Low Grade Cells\")\nplt.axis(\"off\")\n\nfig.add_subplot(122)\nplt.plot(mean_estimate[:, 0], mean_estimate_high[:, 1], \"black\");\nplt.axis(\"equal\")\nplt.title(f\"High Grade Cells\")\nplt.axis(\"off\")\n```\n\n::: {.cell-output .cell-output-display execution_count=26}\n```\n(np.float64(-1.9972225059184727),\n np.float64(1.6950423762408362),\n np.float64(-0.177643622871598),\n np.float64(3.8498647025428094))\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](Shape_Analysis_of_Contractile_Cells_files/figure-html/cell-27-output-2.png){width=1135 height=409}\n:::\n:::\n\n\n::: {#f4b54ffd .cell execution_count=27}\n``` {.python .cell-code}\nmean_estimate_clean_low = mean_estimate_low[~gs.isnan(gs.sum(mean_estimate_low, axis=1)), :]\nmean_estimate_clean_low = interpolate(mean_estimate_clean_low, k_sampling_points - 1)\n\nmean_estimate_clean_high = mean_estimate_high[~gs.isnan(gs.sum(mean_estimate_high, axis=1)), :]\nmean_estimate_clean_high = interpolate(mean_estimate_clean_high, k_sampling_points - 1)\n\nfig = plt.figure(figsize=(15, 5))\n\nfig.add_subplot(121)\nfor cell_at_origin in low_shapes:\n    plt.plot(cell_at_origin[:, 0], cell_at_origin[:, 1], \"lightgrey\", alpha=0.2)\nplt.plot(\n    mean_estimate_clean_low[:, 0], mean_estimate_clean_low[:, 1], \"black\", label=\"Mean cell shape for low grades\"\n)\nplt.title(f\"Low Grade Cells\")\n\nfig.add_subplot(122)\nfor cell_at_origin in high_shapes:\n    plt.plot(cell_at_origin[:, 0], cell_at_origin[:, 1], \"lightgrey\", alpha=0.2)\nplt.plot(\n    mean_estimate_clean_high[:, 0], mean_estimate_clean_high[:, 1], \"black\", label=\"Mean cell shape for high grades\"\n)\nplt.title(f\"High Grade Cells\")\n```\n\n::: {.cell-output .cell-output-display execution_count=27}\n```\nText(0.5, 1.0, 'High Grade Cells')\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](Shape_Analysis_of_Contractile_Cells_files/figure-html/cell-28-output-2.png){width=1177 height=431}\n:::\n:::\n\n\n::: {#7a820f21 .cell execution_count=28}\n``` {.python .cell-code}\nmean_estimate_aligned_low = 1.8 * mean_estimate_clean_low\nmean_estimate_aligned_high = 1.6 * mean_estimate_clean_high\n\nfig = plt.figure(figsize=(15, 5))\n\nfig.add_subplot(121)\nfor cell_at_origin in low_shapes:\n    plt.plot(cell_at_origin[:, 0], cell_at_origin[:, 1], \"lightgrey\", alpha=0.2)\nplt.plot(\n    mean_estimate_aligned_low[:, 0], mean_estimate_aligned_low[:, 1], \"black\", label=\"Mean cell shape for low grades\"\n)\nplt.title(f\"Low Grade Cells\")\n\nfig.add_subplot(122)\nfor cell_at_origin in high_shapes:\n    plt.plot(cell_at_origin[:, 0], cell_at_origin[:, 1], \"lightgrey\", alpha=0.2)\nplt.plot(\n    mean_estimate_aligned_high[:, 0], mean_estimate_aligned_high[:, 1], \"black\", label=\"Mean cell shape for high grades\"\n)\nplt.title(f\"High Grade Cells\")\n```\n\n::: {.cell-output .cell-output-display execution_count=28}\n```\nText(0.5, 1.0, 'High Grade Cells')\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](Shape_Analysis_of_Contractile_Cells_files/figure-html/cell-29-output-2.png){width=1177 height=431}\n:::\n:::\n\n\nBelow are the setup to visualizing distances with respect to each mean shape, due to time constraints this was not implemented.\n\n::: {#5ffc71a6 .cell execution_count=29}\n``` {.python .cell-code}\ndists_to_mean_low = []\n\nfor cell in low_shapes:\n    dist_to_low = CURVES_SPACE_SRV.metric.dist(cell, mean_estimate_aligned_low)\n    dist_to_high = CURVES_SPACE_SRV.metric.dist(cell, mean_estimate_aligned_high)\n    dists_to_mean_low.append(np.array([dist_to_low, dist_to_high]))\n\ndists_to_mean_high = []\n\nfor cell in high_shapes:\n    dist_to_low = CURVES_SPACE_SRV.metric.dist(cell, mean_estimate_aligned_low)\n    dist_to_high = CURVES_SPACE_SRV.metric.dist(cell, mean_estimate_aligned_high)\n    dists_to_mean_high.append(np.array([dist_to_low, dist_to_high]))\n```\n:::\n\n\n::: {#dc9d7b31 .cell execution_count=30}\n``` {.python .cell-code}\ndists = dists_to_mean_low + dists_to_mean_high\nmin_dists = np.min(dists)\nmax_dists = np.max(dists)\nprint(min_dists, max_dists)\nxx = gs.linspace(gs.floor(min_dists), gs.ceil(max_dists), 100)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1.3595235583661602 8.828945361746527\n```\n:::\n:::\n\n\n## Testing\n\nUsing a new set of images, we test the accuracy of this classification, we test on 11 cells from low Baker grade samples and 6 cells from high Baker grade samples.\n\n::: {#174381d0 .cell execution_count=31}\n``` {.python .cell-code}\nwith open('test-low-grade.pkl', 'rb') as fp:\n    test_low_grade_cells = pickle.load(fp)\n\nwith open ('test-high-grade.pkl', 'rb') as fp:\n    test_high_grade_cells = pickle.load(fp)\n```\n:::\n\n\n::: {#eef96b33 .cell execution_count=32}\n``` {.python .cell-code}\ntest_cells_aligned_low = []\ntest_cells_aligned_high = []\n\nfor cell in test_low_grade_cells:\n    cell_sorted = sort_coordinates(cell)\n    cell_interpolated = preprocess(interpolate(cell_sorted, k_sampling_points))\n    cell_aligned = exhaustive_align(cell_interpolated, BASE_CURVE)\n    test_cells_aligned_low.append(cell_aligned)\n\nfor cell in test_high_grade_cells:\n    cell_sorted = sort_coordinates(cell)\n    cell_interpolated = preprocess(interpolate(cell_sorted, k_sampling_points))\n    cell_aligned = exhaustive_align(cell_interpolated, BASE_CURVE)\n    test_cells_aligned_high.append(cell_aligned)\n```\n:::\n\n\n::: {#270c0a30 .cell execution_count=33}\n``` {.python .cell-code}\ndists_to_mean_test_low = []\ncount_low = 0\n\nfor cell in test_cells_aligned_low:\n    count = 0;\n    dist_to_low = CURVES_SPACE_SRV.metric.dist(CURVES_SPACE_SRV.projection(cell), mean_estimate_aligned_low)\n    dist_to_high = CURVES_SPACE_SRV.metric.dist(CURVES_SPACE_SRV.projection(cell), mean_estimate_aligned_high)\n    dists_to_mean_test_low.append(np.array([dist_to_low, dist_to_high]))\n    if dist_to_low <= dist_to_high:\n        count_low += 1\n\ndists_to_mean_test_high = []\ncount_high = 0\n\nfor cell in test_cells_aligned_high:\n    dist_to_low = CURVES_SPACE_SRV.metric.dist(CURVES_SPACE_SRV.projection(cell), mean_estimate_aligned_low)\n    dist_to_high = CURVES_SPACE_SRV.metric.dist(CURVES_SPACE_SRV.projection(cell), mean_estimate_aligned_high)\n    dists_to_mean_test_high.append(np.array([dist_to_low, dist_to_high]))\n    if dist_to_low >= dist_to_high:\n        count_high += 1\n\nprint(f\"Fraction of low grade cells correctly identified : {count_low/len(test_cells_aligned_low)}\")\nprint(f\"Fraction of high grade cells correctly identified : {count_high/len(test_cells_aligned_high)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFraction of low grade cells correctly identified : 0.6363636363636364\nFraction of high grade cells correctly identified : 0.8333333333333334\n```\n:::\n:::\n\n\n# Conclusion and Future Work\n\nUsing applied methods in Riemannian geometry, we were able to identify cells from low vs. high grade contracture with different mean shapes. The findings corresponded to biological knowledge without the need to rely on pre-defined features, that is, more round-shaped cells are found in low-grade contractures, and more spindle-shaped cells are found in high grade contractures. The classification performed reasonably well on test data.\n\nThere are many limitations to this small, pilot project. If this work is to be carried on in the future, there are two major goals that I will seek to address: \n1. In addition to the elastic metric, other metrics may be tested to see if there is an improvement in the accuracy of classification. Furthermore, methods outside of Riemannian geometry can be implemented and compared with our results. This was attempted but I did not have enough time to run the analysis successfully.\n2. Images in 2D results in loss of data. There are 3D cell shape reconstruction techniques, such as SHAPR, that would be interesting to apply on our dataset.\n\n# Appendix\n\n## Visualizing deformations between cells\n\n::: {#fa50ebe5 .cell execution_count=34}\n``` {.python .cell-code}\nfrom geomstats.geometry.discrete_curves import DiscreteCurvesStartingAtOrigin\n\ncell_start = aligned_cells[0]\ncell_end = aligned_cells[1]\n\nCURVES_SPACE_SRV = DiscreteCurvesStartingAtOrigin(ambient_dim=2, k_sampling_points=k_sampling_points)\n\ncell_start_at_origin = CURVES_SPACE_SRV.projection(cell_start)\ncell_end_at_origin = CURVES_SPACE_SRV.projection(cell_end)\n\ngeodesic_func = CURVES_SPACE_SRV.metric.geodesic(\n    initial_point=cell_start_at_origin, end_point=cell_end_at_origin\n)\n\nn_times = 30\ntimes = gs.linspace(0.0, 1.0, n_times)\ngeod_points = geodesic_func(times)\n```\n:::\n\n\n::: {#db87880a .cell execution_count=35}\n``` {.python .cell-code}\nfig = plt.figure(figsize=(10, 2))\nplt.title(\"Geodesic between two cells\")\nplt.axis(\"off\")\n\nfor i, curve in enumerate(geod_points):\n    fig.add_subplot(2, n_times // 2, i + 1)\n    plt.plot(curve[:, 0], curve[:, 1])\n    plt.axis(\"equal\")\n    plt.axis(\"off\")\n```\n\n::: {.cell-output .cell-output-display}\n![](Shape_Analysis_of_Contractile_Cells_files/figure-html/cell-36-output-1.png){width=763 height=187}\n:::\n:::\n\n\n::: {#543fe58d .cell execution_count=36}\n``` {.python .cell-code}\nplt.figure(figsize=(12, 12))\nfor i in range(1, n_times - 1):\n    plt.plot(geod_points[i, :, 0], geod_points[i, :, 1], \"o-\", color=\"lightgrey\")\nplt.plot(geod_points[0, :, 0], geod_points[0, :, 1], \"o-b\", label=\"Start Cell\")\nplt.plot(geod_points[-1, :, 0], geod_points[-1, :, 1], \"o-r\", label=\"End Cell\")\n\nplt.title(\"Geodesic for the Square Root Velocity metric\")\nplt.legend()\n```\n\n::: {.cell-output .cell-output-display}\n![](Shape_Analysis_of_Contractile_Cells_files/figure-html/cell-37-output-1.png){width=941 height=949}\n:::\n:::\n\n\n",
    "supporting": [
      "Shape_Analysis_of_Contractile_Cells_files"
    ],
    "filters": [],
    "includes": {}
  }
}