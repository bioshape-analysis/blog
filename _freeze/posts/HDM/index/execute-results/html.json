{
  "hash": "33bebacdb8c7b01b3e098d406c6b4454",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Horizontal Diffusion Map\"\ndate: \"Aug 30 2024\"\njupyter: python3\nauthor:\n  - name: \"Wenjun Zhao\" \ncategories: [theory]\n---\n\n\n## References:\n\nThis post is based on the following references:\n\n- Shan Shan, Probabilistic Models on Fibre Bundles (https://dukespace.lib.duke.edu/server/api/core/bitstreams/21bc2e06-ee66-4331-83af-115fe9518e80/content)\n\n- Tingran Gao, The Diffusion Geometry of Fibre Bundles: Horizontal Diffusion Maps (https://arxiv.org/pdf/1602.02330)\n\n## Introduction\n\nHorizontal Diffusion Maps are a variant of diffusion maps used in dimensionality reduction and data analysis. They focus on preserving the local structure of data points in a lower-dimensional space by leveraging diffusion processes. Here's a simple overview:\n\n1. Diffusion Maps Overview\n\n**Diffusion Maps:** These are a powerful technique in machine learning and data analysis for reducing dimensionality and capturing intrinsic data structures. They are based on the concept of diffusion processes over a graph or data manifold.\n\n**Concept:** Imagine a diffusion process where particles spread out over a data set according to some probability distribution. The diffusion map captures the way these particles spread and organizes the data into a lower-dimensional space that retains the local and global structure.\n\n2. Horizontal Diffusion Maps\n\n**Purpose:** Horizontal Diffusion Maps specifically aim to capture and visualize the horizontal or local structure of the data manifold. This can be particularly useful when you want to emphasize local relationships while reducing dimensionality.\n\n**Difference from Standard Diffusion Maps:** While standard diffusion maps focus on capturing both local and global structures, horizontal diffusion maps emphasize local, horizontal connections among data points. This means they preserve local neighborhoods and horizontal relationships more explicitly.\n\n## Example: Möbius Strip\n\nIn this section, we show how horizontal diffusion map works on Möbius Strip parameterized by:\n\n$$\nx = (1 + v\\cos(\\frac{u}{2}))\\cos(u),\\quad y= (1 + v\\cos(\\frac{u}{2}))\\sin(u),\n$$\nfor $u\\in [0,2\\pi)$ and $v \\in [-1,1]$.\n\nIt is known as one of the most simple yet nontrivial fibre bundle. See below for a visualization:\n\n::: {#5bb1df53 .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n\ndef mobius_strip(u, v):\n    \"\"\"\n    Generate coordinates for a Möbius strip.\n    \n    Parameters:\n    - u: Parameter that varies from 0 to 2*pi\n    - v: Parameter that varies from -0.5 to 0.5\n    \n    Returns:\n    - x, y, z: Coordinates of the Möbius strip\n    \"\"\"\n    # Parameters for the Möbius strip\n    radius = 1.0\n    width = 1.0\n    \n    # Compute coordinates\n    x = (radius + width * v * np.cos(u / 2)) * np.cos(u)\n    y = (radius + width * v * np.cos(u / 2)) * np.sin(u)\n    z = width * v * np.sin(u / 2)\n    \n    return x, y, z\n\ndef plot_mobius_strip():\n    u = np.linspace(0, 2 * np.pi, 100)\n    v = np.linspace(-1, 1, 10)\n    \n    u, v = np.meshgrid(u, v)\n    x, y, z = mobius_strip(u, v)\n    \n    fig = plt.figure(figsize=(10, 7))\n    ax = fig.add_subplot(111, projection='3d')\n    \n    # Plot the Möbius strip\n    ax.plot_surface(x, y, z, cmap='inferno', edgecolor='none')\n    \n    # Set labels and title\n    ax.set_xlabel('X')\n    ax.set_ylabel('Y')\n    ax.set_zlabel('Z')\n    ax.set_title('Möbius Strip')\n    \n    plt.show()\n\n# Run the function to plot the Möbius strip\nplot_mobius_strip()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-2-output-1.png){width=552 height=557}\n:::\n:::\n\n\nNow we generate samples from the surface uniformly by first sample $N_{base}$ points on the `base manifold', parameterized by the $v$ component. Then we sample $N_{fibre}$ points along each fibre:\n\n::: {#a76b56be .cell execution_count=2}\n``` {.python .cell-code}\nN_fibre = 20\nv = np.linspace(-1,1,N_fibre,endpoint=False) #samples on each fibre\nN_base = 50\nu = np.linspace(0,2*np.pi,N_base,endpoint=False) #different objects\n# Here we concatenate all fibres to create the overall object\nV = np.tile(v,len(u))\nU= np.array([num for num in u for _ in range(len(v)) ])\nN = U.shape[0]\n```\n:::\n\n\nHere we visualize the points to see how they are distributed on the manifold:\n\n::: {#8408f828 .cell execution_count=3}\n``` {.python .cell-code}\nu, v = np.meshgrid(U,V)\nx, y, z = mobius_strip(u, v)\n    \nfig = plt.figure(figsize=(10, 7))\nax = fig.add_subplot(111, projection='3d')\n    \n# Plot the Möbius strip\nax.scatter(x, y, z, c=v, s=1)\n    \n# Set labels and title\nax.set_xlabel('X')\nax.set_ylabel('Y')\nax.set_zlabel('Z')\nax.set_title('Möbius Strip')\n    \nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-4-output-1.png){width=552 height=557}\n:::\n:::\n\n\nLater on, we will go over the horizontal diffusion map and apply it to the data we just created!\n\n## Horizontal diffusion map (HDM)\n\nThe first step is to create a kernel matrix. As outlined by the references, two common approaches are:\n\n**Horizontal diffusion kernel: ** For two data points $e=(u,v)$ and $e' = (u',v')$:\n$$\nK_{\\epsilon}(e, e') = \\exp( -(u - u')^2/\\epsilon) \\text{ if }v' = P_{uu'}v,\n$$\nand zero otherwise. Here $P_{uu'}$ is the map which connects every point from $v$ to its image $v'$, which, for our case, maps $v$ to itself.\n\n::: {#b6e82eee .cell execution_count=4}\n``` {.python .cell-code}\ndef horizontal_diffusion_kernel(U,V,eps):\n    \n    N = U.shape[0]\n    K = np.zeros((N,N))\n    for i in range(N):\n        for j in range(N):\n            if V[i] == V[j]:# and U[i] != U[j]:\n                #print('match')\n                K[i,j] = np.exp(-(U[i]-U[j])**2/eps)\n    return K\n\neps = 0.2\nK = horizontal_diffusion_kernel(U,V,0.2)\nplt.imshow(K)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-5-output-1.png){width=424 height=416}\n:::\n:::\n\n\nAn alternative, soft version of the kernel above is the **coupled diffusion kernel: **\n\n$$\nK_{\\epsilon, \\delta}(e,e') = \\exp( -(u - u')^2/\\epsilon) \\exp( -(v-v')^2/\\delta ).\n$$\n\n::: {#fa2e6ff1 .cell execution_count=5}\n``` {.python .cell-code}\ndef coupled_diffusion_kernel(U,V,eps,delta):\n    N = U.shape[0]\n    K_c = np.zeros((N,N))\n    for i in range(N):\n        for j in range(N):\n            if True:#U[i] != U[j]:\n                #print('match')\n                K_c[i,j] = np.exp(-(U[i]-U[j])**2/eps) * np.exp( -(V[i]-V[j])**2/delta )\n    return K_c\n\neps = .2\ndelta = .01  \nK_c = coupled_diffusion_kernel(U,V,eps,delta)   \nplt.imshow(K_c)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-6-output-1.png){width=424 height=416}\n:::\n:::\n\n\nAfter we created the kernel matrix, we can then proceed with the regular diffusion map by (1) Create the diffusion operator by normalizing the kernel matrix and computing its eigendecomposition, and (2) extract the diffusion coordinates by using the eigenvectors corresponding to the largest eigenvalues (excluding the trivial eigenvalue) to form the diffusion coordinates. \n\n::: {#bbac4783 .cell execution_count=6}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.linalg import eigh\nfrom sklearn.preprocessing import normalize\n\ndef compute_diffusion_map(kernel_matrix, num_components=2):\n    \"\"\"\n    Compute the diffusion map from a kernel matrix.\n\n    Parameters:\n    - kernel_matrix: The kernel matrix (e.g., RBF kernel matrix).\n    - num_components: Number of diffusion map dimensions to compute.\n\n    Returns:\n    - diffusion_coordinates: The 2D diffusion map coordinates.\n    \"\"\"\n    # Compute the degree matrix\n    degree_matrix = np.diag(np.sum(kernel_matrix, axis=1))\n    \n    # Compute the normalized Laplacian matrix\n    laplacian = np.linalg.inv(degree_matrix) @ kernel_matrix\n    \n    # Compute eigenvalues and eigenvectors\n    eigvals, eigvecs = eigh(laplacian)\n    \n    # Sort eigenvalues and eigenvectors\n    sorted_indices = np.argsort(eigvals)[::-1]\n    eigvals = eigvals[sorted_indices]\n    #print(eigvals)\n    eigvecs = eigvecs[:, sorted_indices]\n    \n    # Take the first `num_components` eigenvectors (excluding the first one which is trivial)\n    diffusion_coordinates = eigvecs[:, 1:num_components+1] @ np.diag(np.sqrt(eigvals[1:num_components+1]))\n    \n    return diffusion_coordinates\n\n\ndef plot_diffusion_map(diffusion_coordinates,color):\n    \"\"\"\n    Plot the 2D diffusion map.\n\n    Parameters:\n    - diffusion_coordinates: The 2D diffusion map coordinates.\n    \"\"\"\n    plt.figure(figsize=(8, 6))\n    plt.scatter(diffusion_coordinates[:, 0], diffusion_coordinates[:, 1], c=color, s=10, alpha=0.7)\n    plt.title('2D Diffusion Map')\n    plt.xlabel('Dimension 1')\n    plt.ylabel('Dimension 2')\n    plt.grid(True)\n    plt.show()\n```\n:::\n\n\nNow project the data points into a lower-dimensional space defined by the significant diffusion coordinates. This projection helps in visualizing and analyzing the local structure of the data.\n\n::: {#4f1f5a86 .cell execution_count=7}\n``` {.python .cell-code}\n# Compute the diffusion map\neps = 0.2\nK = horizontal_diffusion_kernel(U,V,eps)\ndiffusion_coordinates = compute_diffusion_map( K, num_components=2)\n#print(diffusion_coordinates)\n# Plot the 2D diffusion map, where color represents where they were on the fibre. Points that are mapped \nplot_diffusion_map(diffusion_coordinates,V)\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-8-output-1.png){width=683 height=523}\n:::\n:::\n\n\nSimilarly we perform the same procedure for the coupled diffusion matrix:\n\n::: {#b09e9601 .cell execution_count=8}\n``` {.python .cell-code}\n# Compute the diffusion map\neps = 0.2\ndelta = 0.01\nK_c = coupled_diffusion_kernel(U,V,eps,delta)\n\ndiffusion_coordinates = compute_diffusion_map( K_c, num_components=2)\n#print(diffusion_coordinates)\n# Plot the 2D diffusion map\nplot_diffusion_map(diffusion_coordinates,V)\n#plot_diffusion_map(diffusion_coordinates,U)\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-9-output-1.png){width=698 height=523}\n:::\n:::\n\n\nThe points are colored according to their correspondence on all the fibres through component $v$. If two points correspond to each other across different but nearby fibres, they are likely to be neighbors in the visualization above. \n\n## Horizontal base diffusion map (HBDM)\n\nIn addition to embed all the data points, the framework also allows for embedding different objects (fibres). The new kernel is defined as the Frobenius norm of all entries in the previous kernel matrix that correspond to the two fibres:\n\n::: {#26021931 .cell execution_count=9}\n``` {.python .cell-code}\neps = .2\nK = horizontal_diffusion_kernel(U,V,eps)\nK_base = np.zeros( (N_base,N_base) )\nfor i in range(N_base):\n    for j in range(N_base):\n        #print( np.ix_( range(N_fibre*(i),N_fibre*(i+1)), range(N_fibre*(j),N_fibre*(j+1)) ) )\n        K_base[i,j] = np.linalg.norm( K[ np.ix_( range(N_fibre*(i),N_fibre*(i+1)), range(N_fibre*(j),N_fibre*(j+1)) ) ] ,'fro')\n#plt.imshow(K_base)\n#plt.show()\n\n\n# Compute the diffusion map\ndiffusion_coordinates = compute_diffusion_map( K_base, num_components=2)\n\n# Plot the 2D diffusion map\n\nplot_diffusion_map(diffusion_coordinates, np.sort(list(set(list(U)) ) ) )\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-10-output-1.png){width=686 height=523}\n:::\n:::\n\n\nThe embedded points are colored according to the `ground truth' $u$. The smooth color transition shows that the embedding uncovers the information of all fibres on the base manifold. \n\n## Applications in shape data\n\nThe horizontal diffusion map framework is particularly useful in the two following espects, both demonstrated in Gao et al.:\n\n- Horizontal diffusion map (embedding all data points): The embedding automatically suggests a global registration for all fibres that respects a mutual similarity measure.\n\n- Horizontal base diffusion map (embedding all data objects/fibres): Compared to the classical diffusion map without correspondences, the horizontal base diffusion map is more robust to noises and often demonstrate a clearer pattern of clusters.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}