{
  "hash": "8bfcc2eb3f083e510e7ed66fdef7ad8f",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"An analysis and segmentation of contours in AFM imaging data\"\nauthor:\n    - name: \"Berkant Cunnuk\"\n      email: \"cunnukb@myumanitoba.ca\"\n      url: \"https://cnnk.xyz\"\ndate: \"December 17 2024\"\ncategories: [\"biology\", \"AFM\"]\nbibliography: references.bib\nexecute:\n  freeze: auto\n---\n\n\n\n\n\n## Context and motivation\n\nThe segmentation of pieces in AFM images gives us a chance to gather information about their shape. This can very well be a determining characteristic for certain biological objects. Analyzing an image piece by piece is usually easier. It also allows us to iterate through pieces of an image if we wish to analyze something different that is not necessarily related to its shape.\n\nAlthough the work done in this project is applicable to any AFM image, one of my main goals in to detect R-loops in those images. Further information about this topic can be found in this previous [blog post](https://bioshape-analysis.github.io/blog/posts/rloop-analysis/rloop-analysis.html). Unedited AFM images in this blog post was captured by the [Pyne Lab](https://pyne-lab.uk/).\n\n## Preparations before analysis\n\nFor image denoising and binarization we will use the [OpenCV](https://github.com/opencv/opencv) library. Images will be loaded into Numpy arrays.\n\n::: {#fdc0a772 .cell execution_count=1}\n``` {.python .cell-code}\nimport cv2\nimport numpy as np\n```\n:::\n\n\nBackground noises in images are problematic for edge detection algorithms. Many of them rely on counting pixels around a neighbourhood with a similar color value. When noise is present, we are more likely to get disconnected edges. The most common way to get around this is to use a Gaussian blurring, which basically calculates the average of pixels in a square of pre-determined length. This process makes the image more smooth at the cost of some details and precision.\n\nWe will use a better version of this algorithm called _non-local means denoising_ [@ipol_nlm]. Instead of just looking at the immediate surroundings of a pixel, non-local denoising takes into account similar portions in the entire image and calculates the average of all those pixels.\n\n<div style=\"text-align: center;\">\n![Figure 1, An AFM image of DNA fragments (picture by the [Pyne lab](https://pyne-lab.uk/))](data/data.png)\n</div>\n\n::: {#2ee210a7 .cell execution_count=2}\n``` {.python .cell-code}\nsrc = cv2.imread(\"data/data.png\", cv2.IMREAD_COLOR)\n\n# filter strength for luminance component = 10\n# filter strength for color components = 10\n# templateWindowSize = 7 (for computing weights)\n# searchWindowSize = 21 (for computing averages)\nsrc = cv2.fastNlMeansDenoisingColored(src,None,10,10,7,21)\n\ncv2.imwrite(\"data/data-denoised.png\", src)\n```\n:::\n\n\n<div style=\"text-align: center;\">\n![Figure 2, The image after denoising](data/data-denoised.png)\n</div>\n\nAs we are only interested in finding contours in the image, RGB colors will not be important. In fact, it makes it harder to analyze. We start by changing the color coding of the image to grayscale.\n\n::: {#b40a0e5b .cell execution_count=3}\n``` {.python .cell-code}\nsrc = cv2.imread(\"data/data-denoised.png\", cv2.IMREAD_COLOR)\n\nsrc_gray = cv2.cvtColor(src, cv2.COLOR_BGR2GRAY)\n\ncv2.imwrite(\"data/data-grayscale.png\", src_gray)\n```\n:::\n\n\n<div style=\"text-align: center;\">\n![Figure 3, Grayscale version of the image](data/data-grayscale.png)\n</div>\n\nThe final step is to completely binarize the image. We are only interested in parts of the image that are considered to be DNA matter, which has a smaller color value compared to the background. We will apply a threshold to the image. Any pixel with a color value above 80 is considered to be DNA matter and it is mapped to a white pixel. Everything else is mapped to a black pixel.\n\n::: {#a08e3fe1 .cell execution_count=4}\n``` {.python .cell-code}\nsrc = cv2.imread(\"data/data-grayscale.png\", cv2.IMREAD_COLOR)\n\n# threshold: 80\n# max_value: 255\n# method: THRESH_BINARY\nret,src_binary = cv2.threshold(src_gray,80,255,cv2.THRESH_BINARY)\n\ncv2.imwrite(\"data/data-binary.png\", src_binary)\n```\n:::\n\n\n<div style=\"text-align: center;\">\n![Figure 4, The binarized image after the thresholding](data/data-binary.png)\n</div>\n\n## Finding contours\n\nWe will make use of the ``findContours`` function in ``OpenCV`` with the additional parameter ``RETR_TREE``, which stands for contour retrieval tree. For our purposes, a contour is just a continuous set of points, but its position is also important. A shape can be located inside another shape or it might be connected to some other shape, which is useful information.\n\nWe consider the outer contour a _parent_, and the inner one a _child_. ``findContours`` returns a multi-dimensional array that contains the parent and child relation for any contour in an image.\n\nAfter finding contours from the binarized image, we draw them on top of the original AFM image we initially started with.\n\n::: {#b6d35bfe .cell execution_count=5}\n``` {.python .cell-code}\nsrc = cv2.imread(\"data/data.png\", cv2.IMREAD_COLOR)\nsrc_binary = cv2.imread(\"data/data-binary.png\", cv2.IMREAD_UNCHANGED)\n\ncontours, hierarchy = cv2.findContours(src_binary, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)\nhierarchy = hierarchy[0]\n\nfor i,c in enumerate(contours):\n    # omit very small contours on the background\n    if (cv2.arcLength(c, True) < 75):\n        continue\n    color = (randint(0,255), randint(0,255), randint(0,255))\n    cv2.drawContours(src, contours, i, color, 2)\n\ncv2.imwrite(\"data/data-contours.png\", src)\n```\n:::\n\n\n<div style=\"text-align: center;\">\n![Figure 5, Each contour is highlighted with a different color](data/data-contours.png)\n</div>\n\n## Segmentation\n\nThe hierarchy tree returned by ``findContours`` lets us iterate through any piece or specific level. The following code draws the outermost contours.\n\n::: {#a4959d38 .cell execution_count=6}\n``` {.python .cell-code}\ncontours, hierarchy = cv2.findContours(src_binary, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)\nhierarchy = hierarchy[0]\n\n# create a full black image\nbackground = np.zeros((1504,1504,3), dtype=np.uint8)\n\nfor i,c in enumerate(hierarchy):\n    # find the first outermost contour\n    if(hierarchy[i][1] == -1 and hierarchy[i][3] == -1):\n        current = hierarchy[i]\n    else:\n        continue\n\n    # after we find it, draw all the other outermost contours in the same level\n    while(current[0] != -1):\n        # omit very small contours on the background\n        if (cv2.arcLength(contours[i], True) < 75):\n            # point to the next element\n            current = hierarchy[current[0]]\n            i = current[0]\n            continue\n        cv2.drawContours(background, contours, i, (255,255,255), 2)\n        # point to the next element\n        current = hierarchy[current[0]]\n        i = current[0]\n\n    # after outermost contours are drawn, exit\n    break\n```\n:::\n\n\n<div style=\"text-align: center;\">\n![Figure 6, Pieces in the binarized AFM image](data/segmentation.gif)\n</div>\n\n## Detecting closed contours\n\nIf a contour passes through one pixel more than once, we expect it to have a child contour inside. A closed shape will have an outer contour and at least one inner contour. By looking at the values in the returned tree ``hierarchy``, we can determine whether a contour is open or closed.\n\n::: {#1ebc64c1 .cell execution_count=7}\n``` {.python .cell-code}\nsrc = cv2.imread(\"data/data.png\", cv2.IMREAD_COLOR)\nsrc_binary = cv2.imread(\"data/data-binary.png\", cv2.IMREAD_UNCHANGED)\n\ncontours, hierarchy = cv2.findContours(src_binary, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)\nhierarchy = hierarchy[0]\n\nfor i,c in enumerate(hierarchy):\n    # find the first outermost contour\n    if(hierarchy[i][1] == -1 and hierarchy[i][3] == -1):\n        current = hierarchy[i]\n    else:\n        continue\n\n    # after we find it, draw all the other outermost contours in the same level\n    while(current[0] != -1):\n        # omit very small contours on the background\n        if (cv2.arcLength(contours[i], True) < 75):\n            # point to the next element\n            current = hierarchy[current[0]]\n            i = current[0]\n            continue\n\n        # check whether the contour has a child\n        if hierarchy[i][2] >= 0:\n            cv2.drawContours(src, contours, i, (0, 255, 0), 2)\n        else:\n            cv2.drawContours(src, contours, i, (255, 0, 150), 2)\n\n        # point to the next element\n        current = hierarchy[current[0]]\n        i = current[0]\n\n    # after outermost contours are drawn, exit\n    break\n\ncv2.imwrite(\"data/data-closed-contours.png\", src)\n```\n:::\n\n\n<div style=\"text-align: center;\">\n![Figure 7, Green contours are closed while the magenta ones are not](data/data-closed-contours.png)\n</div>\n\n## Future goals\n\nThis program sometimes gives false positives if there are artificial holes inside the DNA strand. If this is detected as an inner loop, the program considers that the contour is closed even though it is not.\n\nDepending on how bright the picture is, the threshold color value needs to be adjusted manually. Otherwise, some parts of the DNA will not appear in the binarized image. An automatic detection is more preferable.\n\nCurrently, I am using the Python fork of ``OpenCV``, which was originally written in ``C++``. Heavy operations take a considerable amount of time in Python. One of my plans is to rewrite this in ``C++``.\n\n",
    "supporting": [
      "final-post_files"
    ],
    "filters": [],
    "includes": {}
  }
}