{
  "hash": "b26fb9073359be3743ba45d464766379",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Exploring the relation between cell shape and motility\"\nbibliography: references.bib\ndate: \"December 20 2024\" # Format example: August 9 2024\nauthor:\n  - name: \"Pavel Buklemishev\" \n\n  \ncategories: [Cell Morphology, Cell Migration, Differential Geometry] # \n\n\ncallout-icon: false\nformat:\n  html:\n    code-fold: true\n\nexecute:\n  echo: true\n  freeze: auto\n  warning: false\n\n---\n\n\n\n\n\nIn our previous proposal, we introduce our project to study how changes in cell shapes can be associated with motility and introduced our dataset. Here we report the methods\nand results we obtained in two main parts:\n\n1. **Cell Spatial Migration**:\n\n    We visualize and classify the trajectories of motion for cell dataset.\n\n2. **Shape Dynamics**:\n\n    We compute the Riemann distances over time and investigate characteristic events to understand cell shape behavior during migration. We also use conformal mapping to analyze protrusions and other shape features.\n\n# 1. Cell Spatial Migration \n\n### Modes of migration \n\n Cells exhibit different migration patterns, such as free diffusion, directed migration, and confined motion. Mean Squared Displacement (MSD) analysis was used to distinguish these modes. [@Modes] [@MSD] [@wikipedia_anomalous_diffusion].\n\n\nMean squared displacement (MSD): \n\n$$msd(t) = <[x(t+t_0) - x(t)]^2 + [y(t+t_0) - y(t)]^2> $$\n\nExperimentally, the MSD depends on time in a polynomial way:\n$$ msd(t)  = C t^{\\alpha}$$\n\nThe motion types are described by the value of the parameter $\\alpha$(@fig-types): \n\n- **$\\alpha = 1$**: Free Difusion.  \n- **$\\alpha = 2$**: Directed Diffusion.  \n- **$1 < \\alpha < 2$**: Superdiffusion.\n- **$\\alpha <1$**: Subdiffusion (anomalous diffusion, confined diffusion).\n- **$\\alpha \\approx 0$**: Immobility\n\n![Diffusion types [@picture]](img/diff_types.png){#fig-types width=65% style=\"display: block; margin-left: auto; margin-right: auto;\" }\n\nUsing the trajectories, we aim to determine the motions type that appears in the trajectory of a cell and identify potential transitions between them.\nWe discuss the trajectories analysis in the following sections.\n\n\n### Trajectories visualization\n\nThe cell can exhibit different diffusion behavior while migrating in space, thus, initially to investigate these modes of migration we need to visualize the cell trajectories. We visualize the cell trajectory using the following Python code(the dataset was initially adjusted @sec-organization): \n\n#### Code\n\n::: {#49101e14 .cell execution_count=1}\n``` {.python .cell-code}\ndef plot_cell_trajectory(n):\n    centroids = centr[n - 1]  \n    centroids = np.array(centroids)\n    x_coords = centroids[:, 0]  \n    y_coords = centroids[:, 1] \n\n    # riemann_data = riemann[n-1] \n    # riemann_data = np.array(riemann_data)  \n\n    time_steps = np.arange(len(x_coords))  \n\n    plt.figure(figsize=(10, 8))\n    plt.scatter(\n        x_coords[0], y_coords[0],  \n        c='black',\n        marker='o',\n        edgecolor='k',\n        s=100,\n        alpha=0.7,\n        label='Start Point'\n    )\n    scatter = plt.scatter(\n        x_coords[1:], y_coords[1:],  \n        c=time_steps[1:],  #riemann_data[1:],        \n        cmap='plasma',             \n        marker='o',\n        edgecolor='k',\n        s=100,\n        alpha=0.7\n    )\n    plt.plot(x_coords, y_coords, linestyle='-', color='gray', alpha=0.5)  \n\n    plt.title(f\"Cell Num {n}\")\n    plt.xlabel('X Coordinate')\n    plt.ylabel('Y Coordinate')\n    plt.grid(True)\n\n    cbar = plt.colorbar(scatter)\n    cbar.set_label('Time Step (t)', rotation=270, labelpad=15)\n\n    plt.show()\n```\n:::\n\n\n![The cell №87 trajectory](img/cell_traj_87.png){#fig-traj87 width=65% style=\"display: block; margin-left: auto; margin-right: auto;\" }\n\nWe build the trajectories of the cells of the whole dataset. In the example figure(@fig-traj87) one can see the trajectory of the cell №87. However, building trajectories itself doesn't give an answer which modes a cell exhibits. Thus, we need to formulate and demonstrate a technique that help as to segmentize and classify the modes.  \n\n[All the trajectories pdf](files/trajectories.pdf)\n\n### Trajectory classification.\n\n**DC-MSS** - divide-and-conquer moment scaling spectrum transient mobility analysis framework [@VEGA20181018] which classifies trajectory segments into predefined motion types and detects mobility switches. In our project, we use this tool to describe the trajectories of cells. Although this method is powerful and efficient for classifying trajectories, it has its cons as well. As it was designated for the molecular motion analysis it doesn't take into account superdiffusion mode which is more typical for living species.\nThus, method distinguishes between free diffusion, confined motion, immobility, and directed migration, and we will assume that if a cell exhibits superdiffusion mode, it will be covered by the lattest one.\n\n\nAfter converting data to the framework format we can get desired mode classification. \n\n#### Running the DC-MSS Framework in MATLAB\nAfter preparing data for the framework(@sec-dcmssprep) we process the classification.\n\n::: {#7d7b587c .cell execution_count=2}\n``` {.python .cell-code}\nloaded = load(\"../trajectory_data.mat\");\nallTracks = loaded.tracks;\n\nprobDim = 2;       \nplotRes = 0;       \npeakAlpha = 95;  \n\nresults = struct();\n\ntrackNames = fieldnames(allTracks);\nfor i = 1:length(trackNames)\n    trackName = trackNames{i};\n    tracks = allTracks.(trackName);\n\n    [transDiffResults, errFlag] = basicTransientDiffusionAnalysisv1(tracks, probDim, plotRes, peakAlpha);\n    \n    if isfield(transDiffResults.segmentClass, 'momentScalingSpectrum')\n        results.(trackName).momentScalingSpectrum = transDiffResults.segmentClass.momentScalingSpectrum;\n    end\nend\n\nh5FileName = 'time_events.h5';\n\ntrackNames = fieldnames(results);\nfor i = 1:length(trackNames)\n    trackName = trackNames{i};\n    data = results.(trackName).momentScalingSpectrum;\nend\n```\n:::\n\n\nBy varying **peakAlpha** parameter one can get different confidence level for choosing peaks when initially segmenting track.\n\n\n::: {.row}\n::: {.column width=\"40%\"}\n![Classified track with 95% confidence level. Cyan corresponds to the free diffusion, Magenta - directed motion](img/segmented_track.png){#fig-95-class}\n:::\n::: {.column width=\"47%\"}\n![Classified track with 90% confidence level. Blue corresponds to the confined diffusion](img/conf_level_90.png){#fig-90-class}\n:::\n:::\n\nIn the example (@fig-95-class and @fig-90-class) we can see that the classified trajectory segments provide insights into motion types. However, (@fig-90-class) looks much more natively as the motion changes in the cyan part of trajectory(@fig-95-class) are visible to the naked eye. \n\n## Dataset Motion Modes Analysis {#sec-mean_velo}\n\nIn this section, we organize the dataset based on the migration modes classification discussed in the previous sections.\n\nFirst, we will estimate the proportion of each observed migration mode relative to the total.\n\n### Motion Modes Distribution\n\nUsing the illustrations (@fig-prop95, @fig-prop90), it is evident that, despite the presence of unclassified trajectory segments, the two predominant regimes describing the trajectories are the free and confined migration modes.\n\n::: {#ee7c0fea .cell execution_count=3}\n``` {.python .cell-code}\ndef get_motion_type_distribution():\n    type_counts = defaultdict(int)\n    total_count = 0\n\n    with h5py.File('time_events_95.h5', 'r') as f:\n        for plot_index in range(total_plots):\n            track_i_data = f[f'/track_{plot_index+1}'][:]\n            first_three_rows = track_i_data[:3]\n            interval_types = first_three_rows[2, :]\n            \n            for interval_type in interval_types:\n                if not np.isnan(interval_type):\n                    type_counts[int(interval_type)] += 1\n                    total_count += 1\n                else:\n                    type_counts[\"unclassified\"] += 1\n                    total_count += 1\n\n    proportions = {key: count / total_count for key, count in type_counts.items()}\n    return proportions\n\ndef plot_motion_type_distribution():\n\n    proportions = get_motion_type_distribution()\n\n\n    types = [\"Immobile\", \"Confined Diffusion\", \"Free Diffusion\", \"Directed Diffusion\", \"Unclassified\"]\n    colors = [\"brown\", \"blue\", \"cyan\", \"magenta\", \"black\"]\n    keys = [0, 1, 2, 3, \"unclassified\"]\n\n    values = [proportions.get(key, 0) for key in keys]\n    plt.figure(figsize=(8, 6))\n    plt.pie(\n        values,\n        labels=types,\n        colors=colors,\n        autopct=\"%1.1f%%\",\n        startangle=140,\n        textprops={'color': 'white', 'fontsize': 12}  \n    )\n    plt.title(\"Proportion of Motion Types\")\n    plt.tight_layout()\n    plt.savefig(\"motion_type_distribution_90.png\")\n    plt.show()\n```\n:::\n\n\n::: {.columns}\n::: {.column width=\"50%\"}\n![Confidence level 0.95. Cyan corresponds to the free diffusion, Magenta - directed motion, Blue - confined diffusion, Brown - to immobile cells, Black - unclassified.](img/prop95.png){#fig-prop95 fig-align=\"center\" width=\"100%\"}\n:::\n\n::: {.column width=\"50%\"}\n![Confidence level 0.90.](img/prop90.png){#fig-prop90 fig-align=\"center\" width=\"100%\"}\n:::\n:::\n\n### Transition between Modes Matrix\n\n\nThe transition fractions of mode switches can also be represented using a Transition Matrix. These matrices (@fig-transmat95, @fig-transmat90) illustrate the most frequent transitions between migration modes, offering valuable insight into the dynamics of mode switching. From these illustrations, we can draw the following conclusions:\n\n1. Probabilities of the transition from one mode to another usually depends on the direction of a transition.\n\n2. The most dominant mode transition is from free diffusion to the confined mode. \n\n3. Cells tend to switch between modes in a sequential manner, following the pattern: Immobile → Confined → Free → Directed and in the opposite direction.\n\n::: {#b3d4f364 .cell execution_count=4}\n``` {.python .cell-code}\ndef compute_transition_matrix_with_unclassified():\n    transition_counts = np.zeros((5, 5))  \n    total_transitions = 0\n\n    with h5py.File('time_events_95.h5', 'r') as f:\n        for plot_index in range(total_plots):\n            track_i_data = f[f'/track_{plot_index+1}'][:]\n            first_three_rows = track_i_data[:3]\n            interval_types = first_three_rows[2, :]\n\n            for start_idx in range(len(interval_types) - 1):\n                type_from = interval_types[start_idx]\n                type_to = interval_types[start_idx + 1]\n\n\n                type_from = int(type_from) if not np.isnan(type_from) else 4  \n                type_to = int(type_to) if not np.isnan(type_to) else 4  \n\n                if type_from != type_to:  \n                    transition_counts[type_from, type_to] += 1\n                    total_transitions += 1\n\n\n    transition_matrix = (transition_counts / total_transitions) * 100  \n    return transition_matrix\n\ndef plot_transition_matrix_with_unclassified(transition_matrix):\n    types = [\"Immobile\", \"Confined Diffusion\", \"Free Diffusion\", \"Directed Diffusion\", \"Unclassified\"]\n    \n    plt.figure(figsize=(8, 6))\n    masked_matrix = np.ma.masked_where(np.eye(len(types)), transition_matrix)  \n    plt.imshow(masked_matrix, cmap=\"Blues\", aspect=\"auto\")\n    for i in range(5):\n        plt.fill([i - 0.5, i + 0.5, i + 0.5, i - 0.5],\n                 [i - 0.5, i - 0.5, i + 0.5, i + 0.5],\n                 color='black')\n\n    plt.colorbar(label=\"%\")\n\n    plt.xticks(ticks=np.arange(len(types)), labels=types, rotation=45)\n    plt.yticks(ticks=np.arange(len(types)), labels=types)\n    plt.title(\"Transition Matrix\")\n\n\n\n    for i in range(len(types)):\n        for j in range(len(types)):\n            if i != j:  \n                plt.text(j, i, f\"{transition_matrix[i, j]:.1f}%\", ha='center', va='center', color='black')\n\n    plt.tight_layout()\n    plt.savefig(\"transition_matrix_with_unclassified_95.png\")\n    plt.show()\n```\n:::\n\n\n::: {.columns}\n::: {.column width=\"50%\"}\n![Confidence level 0.95. The Y-axis represents the migration mode from which cells transition to a new observed mode, while the X-axis corresponds to the mode they transition into.](img/transition_matrix_with_unclassified_95.png){#fig-transmat95 fig-align=\"center\" width=\"100%\"}\n:::\n\n::: {.column width=\"50%\"}\n![Confidence level 0.90.](img/transition_matrix_with_unclassified_90.png){#fig-transmat90 fig-align=\"center\" width=\"100%\"}\n:::\n:::\n\n\n### Free and Directed Diffusion: average velocities {#sec-avvel}\n\nSince the most interpretable regimes for observers are free diffusion and directed motion, in the following subsections, we investigate cell motility characteristics concerning these two modes.\nWe compute the mean velocities associated with these migration modes, presenting both the mean values and their 95% confidence intervals. Unfortunately, the p-value for the t-test at the 95% confidence level segmentation(@fig-meanvelocity95) exceeds the required 0.05, which limits the statistical significance of the observed differences. However, the segmentation at the 90% confidence level demonstrates statistical significance for the observed velocities. As we can see in (@fig-meanvelocity90), the velocity in directed migration is higher than in free diffusion. This can be explained by the active mechanisms involved in directed migration, such as the reorganization of the cytoskeleton, enhanced energy expenditure, which result in more efficient and faster movement compared to the random free diffusion. \n\n::: {#80ab01e8 .cell execution_count=5}\n``` {.python .cell-code}\ndef average_velocity_with_ttest():\n    type_data = defaultdict(list)\n\n    with h5py.File('time_events_95.h5', 'r') as f:\n        for plot_index in range(total_plots):\n            track_i_data = f[f'/track_{plot_index+1}'][:]\n            first_three_rows = track_i_data[:3]\n            event_indices = first_three_rows[0, :].astype(int) - 1\n            interval_types = first_three_rows[2, :]\n\n            for start_idx, interval_type in enumerate(interval_types):\n                if start_idx + 1 < len(event_indices) and interval_type in [2, 3]:                      start = event_indices[start_idx] + 1  \n                    end = event_indices[start_idx + 1]\n                    segment = [get_abs_velocity(plot_index, idx) for idx in range(start, end + 1)]\n                    type_data[int(interval_type)].extend(segment)\n\n \n    free_diffusion = type_data[2]\n    directed_diffusion = type_data[3]\n\n    t_stat, p_value = ttest_ind(free_diffusion, directed_diffusion, equal_var=False)\n\n\n    plt.figure(figsize=(8, 6))\n    types = [\"Free Diffusion\", \"Directed Diffusion\"]\n    colors = [\"cyan\", \"magenta\"]\n    means = []\n    conf_intervals = []\n\n    for key, velocities in zip([2, 3], [free_diffusion, directed_diffusion]):\n        if velocities:  \n            mean = np.mean(velocities)\n            ci = sem(velocities) * 1.96  \n            means.append(mean)\n            conf_intervals.append(ci)\n        else:\n            means.append(0)\n            conf_intervals.append(0)\n\n    x = np.arange(len(types))\n\n    for idx, (mean, ci, color) in enumerate(zip(means, conf_intervals, colors)):\n        plt.errorbar(x[idx], mean, yerr=ci, fmt='o', color=color, ecolor=color, elinewidth=2, capsize=5)\n\n    plt.text(0.5, max(means) + max(conf_intervals) * 1.2,\n             f\"T-test p-value: {p_value:.3e}\",\n             ha='center', fontsize=12, color='black')\n\n    plt.xticks(x, types)\n    plt.ylabel(\"Velocity\")\n    plt.tight_layout()\n    plt.savefig(\"mean_velocity_with_ttest_95.png\")\n    plt.show()\n```\n:::\n\n\n::: {.columns}\n::: {.column width=\"50%\"}\n![Confidence level 0.95.](img/mean_velocity_with_ttest_95.png){#fig-meanvelocity95 fig-align=\"center\" width=\"100%\"}\n:::\n\n::: {.column width=\"50%\"}\n![Confidence level 0.90.](img/mean_velocity_with_ttest_90.png){#fig-meanvelocity90 fig-align=\"center\" width=\"100%\"}\n:::\n:::\n\n### Free and Directed Diffusion: average angles {#sec-avang}\n\nAnalogously to the previous subsection, we measured the average directional angles associated with different migration modes. Both segmentation levels satisfy the p-value criterion, confirming the statistical significance of the results. From both images, it is evident that cells exhibit more stable behavior in the directed diffusion mode, with noticeably less rotational movement.\n\n::: {#2cced3d8 .cell execution_count=6}\n``` {.python .cell-code}\ndef average_angle_with_ttest():\n    type_data = defaultdict(list)\n\n    with h5py.File('time_events_90.h5', 'r') as f:\n        for plot_index in range(total_plots):\n            track_i_data = f[f'/track_{plot_index+1}'][:]\n            first_three_rows = track_i_data[:3]\n            event_indices = first_three_rows[0, :].astype(int) - 1\n            interval_types = first_three_rows[2, :]\n\n            for start_idx, interval_type in enumerate(interval_types):\n                if start_idx + 1 < len(event_indices) and interval_type in [2, 3]:                      start = event_indices[start_idx] + 1 \n                    end = event_indices[start_idx + 1]\n                    segment = [get_velocity_angle_rel(plot_index, idx) for idx in range(start, end + 1)]\n                    type_data[int(interval_type)].extend(segment)\n\n    free_diffusion = type_data[2]\n    directed_diffusion = type_data[3]\n\n    t_stat, p_value = ttest_ind(free_diffusion, directed_diffusion, equal_var=False)\n\n\n    plt.figure(figsize=(8, 6))\n    types = [\"Free Diffusion\", \"Directed Diffusion\"]\n    colors = [\"cyan\", \"magenta\"]\n    means = []\n    conf_intervals = []\n\n    for key, angles in zip([2, 3], [free_diffusion, directed_diffusion]):\n        if angles: \n\n            sigma = 2\n            angles_smoothed = gaussian_filter1d(angles, sigma=sigma)\n\n            mean = np.mean(angles_smoothed)\n            ci = sem(angles_smoothed) * 1.96 \n            means.append(mean)\n            conf_intervals.append(ci)\n        else:\n            means.append(0)\n            conf_intervals.append(0)\n\n    x = np.arange(len(types))\n\n\n    for idx, (mean, ci, color) in enumerate(zip(means, conf_intervals, colors)):\n        plt.errorbar(x[idx], mean, yerr=ci, fmt='o', color=color, ecolor=color, elinewidth=2, capsize=5)\n\n    plt.text(0.5, max(means) + max(conf_intervals) * 1.2,\n             f\"T-test p-value: {p_value:.3e}\",\n             ha='center', fontsize=12, color='black')\n\n    plt.xticks(x, types)\n    plt.ylabel(\"Angle\")\n    plt.tight_layout()\n    plt.savefig(\"mean_angle_with_ttest_90.png\")\n    plt.show()\n```\n:::\n\n\n::: {.columns}\n::: {.column width=\"50%\"}\n![Confidence level 0.95.](img/mean_angle_with_ttest_95.png){#fig-meanangle95 fig-align=\"center\" width=\"100%\"}\n:::\n\n::: {.column width=\"50%\"}\n![Confidence level 0.90.](img/mean_angle_with_ttest_90.png){#fig-meanangle90 fig-align=\"center\" width=\"100%\"}\n:::\n:::\n\n\n\n\n# 2. Shape analysis\n\nAfter describing the spatial migration of a cell, our next goal is to investigate the dynamics of its shape. We employ the SRV Riemann Elastic Metrics to compute the distance between two shapes[@10.1007/978-3-031-38299-4_60]: \n\n$$ \ng_c^{1, 0.5}(h, k) = \\int_{[0,1]} \\langle D_s h, N \\rangle \\langle D_s k, N \\rangle \\, ds \n+ 0.5^2 \\int_{[0,1]} \\langle D_s h, T \\rangle \\langle D_s k, T \\rangle \\, ds  \\text{ - SRV metrics}\n$$\n\nFor a single cell given time moments $t$ and $t+1$, we:\n\n1. Interpolate the segmentized cell shape for both of moments t and t+1\n\n2. Align the cell shapes. We quotient out transition and reparametrization but ignore the rotation. We expect that the rotation is a significant aspect in spatial migration and we need to focus it. \n\n3. Compute the SRV metrics for an each couple of consequent aligned cell shapes(@sec-align), dividing them by time differences, and, therefore we obtain Riemann Velocities (They would be mentioned in the text as distances as well). \n\n\n\n### Distance Computation\n\nRiemann distances are computed between consequent aligned shapes:\n\n::: {#462e3080 .cell execution_count=7}\n``` {.python .cell-code}\nriemann_distances = []\na = 1\nb = 1/2\n\nCURVES_SPACE_ELASTIC = DiscreteCurvesStartingAtOrigin(\n    ambient_dim=2, k_sampling_points=1000, equip=False\n)\nCURVES_SPACE_ELASTIC.equip_with_metric(ElasticMetric, a=a, b=b)\n\ndef calculate_distance(border,reference_shape):\n\n    return CURVES_SPACE_ELASTIC.metric.dist(CURVES_SPACE_ELASTIC.projection(border), CURVES_SPACE_ELASTIC.projection(reference_shape))\n\n\nfor cell_i in range(1, 205):\n    number_of_frames = sum(os.path.isdir(os.path.join(f\"cells/cell_{cell_i}\", entry)) for entry in os.listdir(f\"cells/cell_{cell_i}\"))  \n\n    iter_distance = np.zeros(number_of_frames)\n\n    BASE_LINE = np.load(f'cells/cell_{cell_i}/frame_1/outline.npy')\n    BASE_LINE= interpolate(BASE_LINE,1000)\n    BASE_LINE = preprocess(BASE_LINE)\n    BASE_LINE= project_on_kendall_space(BASE_LINE)\n    for i in range(number_of_frames):\n        border_cell = np.load(f'cells/cell_{cell_i}/frame_{i+1}/outline.npy')\n        cell_interpolation= interpolate(border_cell,1000)\n        cell_preprocess = preprocess(cell_interpolation)\n        border_cell = cell_preprocess\n        border_cell = project_on_kendall_space(cell_interpolation)\n        aligned_border = align(border_cell, BASE_LINE, rescale=True, rotation=False, reparameterization=True, k_sampling_points=1000)\n        iter_distance[i] = calculate_distance(aligned_border, BASE_LINE)\n        BASE_LINE = aligned_border \n\n    riemann_distances.append(iter_distance)\n### Dividing by delta t in the results.\n```\n:::\n\n\nRiemann Velocities visualization - (@sec-riemann_simple).\n\n\nMoreover, we hypothesize that the cells' shape dynamics, as described by Riemann Velocities, are influenced by the migration mode they exhibit. Therefore, we align the Riemann Velocities with the mode segmentation obtained earlier for further analysis.\n\nRiemann Velocities visualization with segmentation - (@sec-riemann_segmentation).\n\n\nFrom the example pictures (@fig-segm095, @fig-segm090), the peak at time point 49 aligns well with the observed transition in migration modes, suggesting that a connection may exist.\n\n::: {.columns}\n::: {.column width=\"50%\"}\n![Confidence level 0.95.](img/riemann_single_cell_87_classification_95.png){#fig-segm095 fig-align=\"center\" width=\"100%\"}\n:::\n\n::: {.column width=\"50%\"}\n![Confidence level 0.90.](img/riemann_single_cell_87_classification_90.png){#fig-segm090 fig-align=\"center\" width=\"100%\"}\n:::\n:::\n\nBased on the general results, we can formulate a hypothesis: Riemann velocity peaks emerge when the motion mode switches between Directed Diffusion and Confined/Free Diffusion modes. However, with the current data, we cannot confidently confirm this correlation. Nevertheless, some examples (e.g., cells №33, 36, 41, 57, etc.) suggest that this dependency could be a promising target for future exploration. \n\n\n[All the Riemann Velocities pdf](files/riemann_times.pdf)\n\n\n[Riemann velocities and events (0.9 confidence level)](files/riemann_with_events_90.pdf)\n\n[Riemann velocities and events (0.95 confidence level)](files/riemann_with_events_95.pdf)\n\n[Riemann velocities and classified segments  (0.9 confidence level)](files/riemann_with_classification_90.pdf)\n\n[Riemann velocities and classified segments (0.95 confidence level)](files/riemann_with_classification_95.pdf)\n\n\n\nWe can visualize the spatial behaviour of a cell via the motion types as well (@fig-3d95, @fig-3d90). This could be helpful in the further research.\n\n::: {#a937dd09 .cell execution_count=8}\n``` {.python .cell-code}\ndef plot_cell_by_motion_type(n):\n\n    cell_dir = 'cells'\n    cell_path = os.path.join(\n        cell_dir, \n        sorted(os.listdir(cell_dir), key=lambda x: int(x.split('_')[1]) if '_' in x and x.split('_')[1].isdigit() else 0)[n-1]\n    )\n\n    cell = sorted(\n        os.listdir(cell_path), \n        key=lambda x: int(''.join(filter(str.isdigit, x))) \n    )\n    \n    fig = plt.figure()\n    ax = fig.add_subplot(111, projection='3d')\n\n    interval_colors = {\n        0: \"brown\", \n        1: \"blue\",       \n        2: \"cyan\",       \n        3: \"magenta\",  \n        \"unclassified\": \"black\"  \n    }\n    import h5py\n\n    with h5py.File('time_events_90.h5', 'r') as f:\n        track_i_data = f[f'/track_{n}'][:]\n        first_three_rows = track_i_data[:3]\n        event_indices = first_three_rows[0, :].astype(int) - 1\n        interval_types = first_three_rows[2, :]  \n\n    for i, frame in enumerate(cell):\n        frame_path = os.path.join(cell_path, frame)\n        time = np.load(os.path.join(frame_path, 'time.npy'))\n        outline = np.load(os.path.join(frame_path, 'outline.npy'))\n\n        current_type = None\n        for start_idx, interval_type in enumerate(interval_types):\n            if i >= event_indices[start_idx] and (start_idx + 1 == len(event_indices) or i < event_indices[start_idx + 1]):\n                current_type = interval_type\n                break\n\n        if current_type is not None:\n            interval_type = int(current_type) if not np.isnan(current_type) else \"unclassified\"\n            color = interval_colors.get(interval_type, \"black\")\n\n        ax.plot3D(\n            outline[:, 0], \n            outline[:, 1], \n            np.full(len(outline[:, 1]), time),\n            color=color, \n            linewidth=1\n        )\n        print(f\"Frame {frame}: Time = {time}, Motion Type = {current_type}\")\n\n    from matplotlib.lines import Line2D\n    legend_elements = [\n        Line2D([0], [0], color=\"brown\", lw=2, label=\"Immobile\"),\n        Line2D([0], [0], color=\"blue\", lw=2, label=\"Confined Diffusion\"),\n        Line2D([0], [0], color=\"cyan\", lw=2, label=\"Free Diffusion\"),\n        Line2D([0], [0], color=\"magenta\", lw=2, label=\"Directed Diffusion\"),\n        Line2D([0], [0], color=\"black\", lw=2, label=\"Unclassified\")\n    ]\n    ax.legend(handles=legend_elements, loc=\"upper right\", fontsize=8)\n\n    ax.set_xlabel('X Coordinate')\n    ax.set_ylabel('Y Coordinate')\n    ax.set_zlabel('Time')\n    ax.set_title(f\"Cell {n}\")\n    plt.show()\n```\n:::\n\n\n::: {.columns}\n::: {.column width=\"50%\"}\n![Confidence level 0.95.](img/cell87_3d_95.png){#fig-3d95 fig-align=\"center\" width=\"100%\"}\n:::\n::: {.column width=\"50%\"}\n![Confidence level 0.90.](img/cell87_3d_90.png){#fig-3d90 fig-align=\"center\" width=\"100%\"}\n:::\n:::\n\n### Free and Directed Diffusion: Riemann Velocities\n\nIn this section, similar to (@sec-avvel, @sec-avang), we compute the mean values of Riemann Velocities associated with Free and Directed Diffusion modes.\n\nThe figures (@fig-ttestrim95, @fig-ttestrim90) illustrate that during directed migration, cells exhibit fewer shape perturbations compared to free diffusion modes. This suggests that the cytoskeleton in cells undergoing directed migration is more stable than in cells in diffusive modes.\n\n::: {#3f230cc3 .cell execution_count=9}\n``` {.python .cell-code}\ndef average_riemann_distances_with_ttest():\n    type_data = defaultdict(list)\n\n    with h5py.File('time_events_90.h5', 'r') as f:\n        for plot_index in range(total_plots):\n            track_i_data = f[f'/track_{plot_index+1}'][:]\n            first_three_rows = track_i_data[:3]\n            event_indices = first_three_rows[0, :].astype(int) - 1\n            interval_types = first_three_rows[2, :]\n\n            for start_idx, interval_type in enumerate(interval_types):\n                if start_idx + 1 < len(event_indices) and interval_type in [2, 3]: \n                    start = event_indices[start_idx] + 1  \n                    end = event_indices[start_idx + 1]\n                    segment = [\n                        get_riemann_dist(plot_index, idx) /\n                        (get_times(plot_index, idx) - get_times(plot_index, idx - 1))\n                        for idx in range(start, end + 1)\n                    ]\n                    type_data[int(interval_type)].extend(segment)\n\n    free_diffusion = type_data[2]\n    directed_diffusion = type_data[3]\n\n\n    t_stat, p_value = ttest_ind(free_diffusion, directed_diffusion, equal_var=False)\n\n    plt.figure(figsize=(8, 6))\n    types = [\"Free Diffusion\", \"Directed Diffusion\"]\n    colors = [\"cyan\", \"magenta\"]\n    means = []\n    conf_intervals = []\n\n    for key, distances in zip([2, 3], [free_diffusion, directed_diffusion]):\n        if distances:  \n            mean = np.mean(distances)\n            ci = sem(distances) * 1.96  \n            means.append(mean)\n            conf_intervals.append(ci)\n        else:\n            means.append(0)\n            conf_intervals.append(0)\n\n    x = np.arange(len(types))\n\n    for idx, (mean, ci, color) in enumerate(zip(means, conf_intervals, colors)):\n        plt.errorbar(x[idx], mean, yerr=ci, fmt='o', color=color, ecolor=color, elinewidth=2, capsize=5)\n\n    plt.text(0.5, max(means) + max(conf_intervals) * 1.2,\n             f\"T-test p-value: {p_value:.3e}\",\n             ha='center', fontsize=12, color='black')\n\n    plt.xticks(x, types)\n    plt.ylabel(\"Riemann Velocity\")\n\n    plt.tight_layout()\n    plt.savefig(\"riemann_distances_with_ttest_90.png\")\n    plt.show()\n```\n:::\n\n\n::: {.row}\n::: {.column width=\"49%\"}\n![Confidence level 0.95.](img/riemann_distances_with_ttest_95.png){#fig-ttestrim95 fig-align=\"center\" width=\"100%\"}\n:::\n::: {.column width=\"49%\"}\n![ Confidence level 0.90.](img/riemann_distances_with_ttest_90.png){#fig-ttestrim90 fig-align=\"center\" width=\"100%\"}\n:::\n:::\n\nContinuing this investigation, we can create scatter plots to visualize the relationships between Riemann velocities and angles, as well as between Riemann velocities and distances. These plots (@fig-scat95, @fig-scat90) illustrate that in the directed migration mode, the scatter of Riemann distances is more concentrated, showing less variability in the Directed Migration mode.\n\n::: {#834685af .cell execution_count=10}\n``` {.python .cell-code}\ndef plot_velocity_riemann_and_angle_riemann_for_two_modes():\n    type_data = defaultdict(lambda: {'velocity': [], 'riemann': [], 'angle': []})\n    colors = {2: \"cyan\", 3: \"magenta\"}\n    labels = {2: \"Free Diffusion\", 3: \"Directed Diffusion\"}\n    with h5py.File('time_events_95.h5', 'r') as f:\n        for plot_index in range(total_plots):\n            track_i_data = f[f'/track_{plot_index+1}'][:]\n            first_three_rows = track_i_data[:3]\n            event_indices = first_three_rows[0, :].astype(int) - 1\n            interval_types = first_three_rows[2, :]\n\n            for start_idx, interval_type in enumerate(interval_types):\n                if start_idx + 1 < len(event_indices) and interval_type in [2, 3]: \n                    start = event_indices[start_idx] + 1\n                    end = event_indices[start_idx + 1]\n                    type_key = int(interval_type)\n\n                    for idx in range(start, end + 1):\n                        velocity = get_abs_velocity(plot_index, idx)\n                        riemann_distance = get_riemann_dist(plot_index, idx) / (get_times(plot_index, idx) - get_times(plot_index, idx - 1))\n                        angle = get_velocity_angle_rel(plot_index, idx)\n\n                        type_data[type_key]['velocity'].append(velocity)\n                        type_data[type_key]['riemann'].append(riemann_distance)\n                        type_data[type_key]['angle'].append(angle)\n\n    plt.figure(figsize=(12, 6))\n\n    plt.subplot(1, 2, 1)\n    for mode in [2, 3]:  \n        plt.scatter(\n            type_data[mode]['velocity'],\n            type_data[mode]['riemann'],\n            color=colors[mode],\n            label=labels[mode],\n            alpha=0.7\n        )\n    plt.xlabel(\"Velocity\")\n    plt.ylabel(\"Riemann Distance\")\n    plt.title(\"Velocity vs Riemann Distance\")\n    plt.legend()\n\n    plt.subplot(1, 2, 2)\n    for mode in [2, 3]: \n        plt.scatter(\n            type_data[mode]['angle'],\n            type_data[mode]['riemann'],\n            color=colors[mode],\n            label=labels[mode],\n            alpha=0.7\n        )\n    plt.xlabel(\"Angle\")\n    plt.ylabel(\"Riemann Distance\")\n    plt.title(\"Angle vs Riemann Distance\")\n    plt.legend()\n\n    plt.tight_layout()\n    plt.savefig(\"scatter_two_95.png\")\n    plt.show()\n```\n:::\n\n\n::: {.row}\n::: {.column width=\"49%\"}\n![Confidence level 0.95.](img/scatter_two_95.png){#fig-scat95 fig-align=\"center\" width=\"100%\"}\n:::\n::: {.column width=\"49%\"}\n![Confidence level 0.95.](img/scatter_two_90.png){#fig-scat90 fig-align=\"center\" width=\"100%\"}\n:::\n:::\n\n\n# Conformal mapping\n\n\n\nThe conformal mapping is a mathematical transformation that preserves local angles and shapes while potentially altering the size. In this study, we apply conformal maps based on the minimization of area distortion to transform the cell shape into a disk. This transformation allows us to observe protrusions locally, relative to a reference shape obtained after applying the conformal map. The algorithm, as described and implemented in prior works [@Hu_Zou_Hua_2014].\n\nThe example of topographical representation of a cell can be seen below {@fig-com87}: \n\n::: {.columns}\n::: {.column width=\"100%\"}\n![Cell Shape and Conformal Topographical Representation Over Time.](img/combined_cell_87.png){#fig-com87 fig-align=\"center\" width=\"100%\"}\n:::\n:::\n\nAs discussed in the project proposal, during cell migration, the cytoskeleton undergoes changes that lead to the formation of protrusions on the cell membrane. These protrusions can be detected in two ways:\n\n1. **Curvature Analysis**: By computing the curvature of the cell shape and identifying its local extrema, which indicate significant deformations of cell shape.\n\n2. **Conformal Mapping Analysis**: By calculating the difference between the topological cell representation obtained after applying conformal mapping and identifying local maxima, which reveal the locations of protrusions.\n\nClement Soubrier adjusted the **unwrap2D** framework [@Zhou2023.04.12.536640] for our specific problem and developed the code to accumulate protrusion statistics using both methods. The results are presented below.\n\n::: {.columns}\n::: {.column width=\"50%\"}\n![Curvature defined protrusion map](img/curv_conformal.png){#fig-confcurv  fig-align=\"center\" width=\"100%\"}\n:::\n\n::: {.column width=\"50%\"}\n![Topologically defined protrusion map](img/conf_topology.png){#fig-conftop fig-align=\"center\" width=\"100%\"}\n:::\n:::\n\n@fig-confcurv and @fig-conftop demonstrate pie charts showing the difference between the protrusion direction and the direction of cell migration. These figures reveal that protrusions emerge at the front and rear of the cell, a behavior consistently observed in many experiments [@SenGupta_Parent_Bear_2021]. @fig-confcurv additionally highlights that the protrusion region at the front of the cell is broader than at the rear, which may be associated with the formation of lamellipodia.\n\nThis section demonstrated how conformal mapping can be used to investigate cell shape dynamics. However, the analysis conducted here is not limited to the whole dataset examples. Future research could focus on more detailed single-cell analyses, exploring the interplay between protrusion dynamics and cell migration.\n\nAdditional examples of conformal mapping application to single cell analysis are provided in (@sec-someconf).\n\n# Conclusion\n\nIn this project, we conducted an analysis of cell migration and shape dynamics processes. We examined cell trajectories over time, identifying migration modes and transitions between motility regimes using a segmentation and classification framework.\n\nWhile we observed that Riemann velocities coincided with certain motion switch events, no consistent global correlation was found between Riemann velocity behavior and these transitions. This lack of correlation might be attributed to errors in cell segmentation. Repeating the experiment with a resegmented dataset might enhance accuracy.\n\nDespite this, the accumulated statistical data of Riemann velocities highlights that cell shape variations depend significantly on the migration modes observed. Cell spatial velocities and directional angles also varied during transitions between migration modes.\n\nConformal mapping, a promising tool applied in this study, reaffirmed classical experimental results on direction of protrusion growth. However, at this stage, we have only minimally explored the use of conformal mapping for investigating specific artifacts of cell migration. In future, it would be valuable to focus on single-cell analysis identifying similar patterns of cell behavior, such as the formation of multiple large protrusions or uniform cell growth. Quantifying the protrusion analysis(counting them, locating, measuring size etc) would be promising as well.\n\nBesides, our research opens the door for combining Riemann velocities analysis with conformal mapping tools. One may detect the protrusion events observed due to conformal mapping and align it with Riemann dynamics. \n\nThus, based on these conclusions, the following future plans are proposed: \n\n# Future plans\n\n1. **Dataset expansion**: increase the dataset size to observe more characteristic transitions between migration modes and obtain more data for the statistical analysis.\n\n2. **Resegmentation**: test the existing methods on a resegmented dataset.\n\n3. **Improve single cell conformal analysis**: looking for consistent cooperative protrusion patterns appear at different event, potentially protrusions distribution.\n\n4. **Quantifying the protrusion**: develop mathematical tools to describe properties of protrusive behavior, including size, quantity, and shape of individual protrusions.\n\n5. **Testing another classifier**: since the classifier we employ doesn't take the superdiffusion mode into consideration, it might be useful to take another one. For example, DL-MSS might help [@Arts_Smal_Paul_Wyman_Meijering_2019] .\n\n6. **Combine Riemann Velocity and Conformal Mapping tools**: align Riemann velocity dynamics with protrusion patterns identified using conformal mapping. Moreover, looking at less motile cells may simplify the observation of protrusions.\n\n\n# Appendix\n\n### Dataset organization {#sec-organization}\n\nTo simplify the analysis, centroid and time data were organized into arrays.\n\n::: {#5b234488 .cell execution_count=11}\n``` {.python .cell-code}\nfor cell_i in range(1,204):\n    number_of_frames = sum(os.path.isdir(os.path.join(f\"cells/cell_{cell_i}\", entry)) for entry in os.listdir(f\"cells/cell_{cell_i}\"))  \n\n    iter_distance = np.zeros(number_of_frames)\n    iter_time = np.zeros(number_of_frames)\n    iter_centroid = np.array([np.random.rand(2) for _ in range(number_of_frames)])\n    for i in range(number_of_frames):\n        iter_time[i] = np.load(f'cells/cell_{cell_i}/frame_{i+1}/time.npy')\n        iter_centroid[i] = np.load(f'cells/cell_{cell_i}/frame_{i+1}/centroid.npy')\n    riemann_distances.append(iter_distance)\n    times.append(iter_time)\n    centroids.append(iter_centroid)\ndata_path = ########\nwith open(data_path+\"/times.npy\", 'wb') as f:\n    np.save(f, np.array(times, dtype=object))\nwith open(data_path+\"/centroid.npy\", 'wb') as f:\n    np.save(f, np.array(centroids, dtype=object))\n```\n:::\n\n\n### DC-MSS data preparation {#sec-dcmssprep}\n\n::: {#a75ff2d3 .cell execution_count=12}\n``` {.python .cell-code}\nimport numpy as np\nfrom scipy.io import savemat\n                                                                            \ntracks = {}\nfor i, trajectory in enumerate(data):\n    n_frames = trajectory.shape[0]\n    row = np.zeros(n_frames * 8)  \n    for j, (x, y) in enumerate(trajectory):\n        start_idx = j * 8  \n        row[start_idx] = x \n        row[start_idx + 1] = y  \n\n    tracks[f\"track_{i+1}\"] = row  \n\noutput_path = \"trajectory_data.mat\"\nsavemat(output_path, {'tracks': tracks})\n```\n:::\n\n\nThis piece of code converts trajectory data into a .mat file, compatible with MATLAB.\n\n### Alignment {#sec-align}\n\nThe alignment function (kindly provided by Wanxin Li) ensures proper alignment of cell shapes:\n\n::: {#59d9711a .cell execution_count=13}\n``` {.python .cell-code}\ndef align(point, base_point, rescale, rotation, reparameterization, k_sampling_points): #rotation set as False\n    \"\"\"\n    Align point and base_point via quotienting out translation, rescaling, rotation and reparameterization\n    \"\"\"\n\n    total_space = DiscreteCurvesStartingAtOrigin(k_sampling_points=k_sampling_points)\n   \n    \n    # Quotient out translation \n    point = total_space.projection(point) \n    point = point - gs.mean(point, axis=0)\n\n    base_point = total_space.projection(base_point)\n    base_point = base_point - gs.mean(base_point, axis=0)\n\n    # Quotient out rescaling\n    if rescale:\n        point = total_space.normalize(point) \n        base_point = total_space.normalize(base_point)\n    \n    # Quotient out rotation\n    if rotation:\n        point = rotation_align(point, base_point, k_sampling_points)\n\n    # Quotient out reparameterization\n    if reparameterization:\n        aligner = DynamicProgrammingAligner(total_space)\n        total_space.fiber_bundle = ReparametrizationBundle(total_space, aligner=aligner)\n        point = total_space.fiber_bundle.align(point, base_point)\n    return point\n```\n:::\n\n\n### Plotting Riemann Velocities of time {#sec-riemann_simple}\n\n::: {#98980515 .cell execution_count=14}\n``` {.python .cell-code}\ndef plot_riemann_cell(plot_index):\n    riemann_distances = []\n    time_data = []\n    \n    num_frames = len(centr[plot_index-1])\n    \n    for frame in range(1, num_frames):\n\n        dist_value = get_riemann_dist(plot_index-1, frame) / (get_times(plot_index-1, frame) - get_times(plot_index-1, frame - 1))\n        riemann_distances.append(dist_value)\n        time_data.append(get_times(plot_index-1, frame))\n\n    plt.figure(figsize=(8,6))\n    plt.plot(time_data, riemann_distances, marker='o', linestyle='-')\n    plt.xlabel(\"Time\")\n    plt.ylabel(\"Riemann Velocities\")\n    plt.title(f\"Cell {plot_index}\")\n    plt.grid(True)\n    plt.show()\n```\n:::\n\n\n![Riemann Velocities graph for cell №87](img/r.png){ width=65% style=\"display: block; margin-left: auto; margin-right: auto;\" }\n\n### Plotting Riemann Distances with segmentation {#sec-riemann_segmentation}\n\n::: {#4af85400 .cell execution_count=15}\n``` {.python .cell-code}\ndef riemann_single_cell_classification(cell_number):\n    cell_index = cell_number - 1  \n\n\n    riemann_distances = []\n    time_data = []\n    type_data = defaultdict(list)  \n\n    with h5py.File('time_events_90.h5', 'r') as f:\n        track_i_data = f[f'/track_{cell_index+1}'][:]\n        first_three_rows = track_i_data[:3]\n        event_indices = first_three_rows[0, :].astype(int) - 1  \n        interval_types = first_three_rows[2, :]  # \n\n \n    time_data = [times[cell_index][idx] for idx in range(1, len(times[cell_index]))]  \n    riemann_distances = [\n        get_riemann_dist(cell_index, idx) / (get_times(cell_index, idx) - get_times(cell_index, idx - 1))\n        for idx in range(1, len(times[cell_index]))\n    ]\n\n    interval_colors = {\n        0: \"brown\",      \n        1: \"blue\",       \n        2: \"cyan\",       \n        3: \"magenta\",    \n        \"unclassified\": \"black\"  \n    }\n\n\n    fig, ax = plt.subplots(figsize=(8, 6))\n\n    for start_idx, interval_type in enumerate(interval_types):\n        start = event_indices[start_idx]\n        end = event_indices[start_idx + 1] if start_idx + 1 < len(event_indices) else len(time_data) - 1\n\n        if start < len(time_data) and end < len(time_data):\n            time_segment = time_data[start:end + 1]  \n            segment = riemann_distances[start:end + 1]\n\n            interval_type = int(interval_type) if not np.isnan(interval_type) else \"unclassified\"\n            color = interval_colors.get(interval_type, \"black\")\n\n            type_data[interval_type].extend(segment)\n\n            ax.plot(time_segment, segment, color=color)\n\n    from matplotlib.lines import Line2D\n    legend_elements = [\n        Line2D([0], [0], color=\"brown\", lw=2, label=\"Immobile\"),\n        Line2D([0], [0], color=\"blue\", lw=2, label=\"Confined Diffusion\"),\n        Line2D([0], [0], color=\"cyan\", lw=2, label=\"Free Diffusion\"),\n        Line2D([0], [0], color=\"magenta\", lw=2, label=\"Directed Diffusion\"),\n        Line2D([0], [0], color=\"black\", lw=2, label=\"Unclassified\")\n    ]\n    ax.legend(handles=legend_elements, loc=\"upper right\", fontsize=8)\n\n    ax.set_xlabel(\"Time\")\n    ax.set_ylabel(\"Riemann velocity\")\n    ax.set_title(f\"Cell {cell_number}\", fontsize=10)\n    ax.tick_params(axis='both', which='major', labelsize=8)\n\n    plt.tight_layout()\n    plt.savefig(f\"riemann_single_cell_{cell_number}_classification_90.png\")\n    plt.show()\n```\n:::\n\n\n### Additional examples: cell №87 topographical representations over migration modes transitions {#sec-someconf}\n\n\nThis section doesn't include any sufficient results to report in the blog, but there we tried to collect some evidence of a single cell shape artifacts which emerge during migration modes transitions.\n\n::: {.columns}\n::: {.column width=\"100%\"}\n![t = 51](img/combined_cell_87_1.png){#fig-app1 fig-align=\"center\" width=\"100%\"}\n:::\n:::\n\nFrom the @fig-app1, we observe that when the cell transitions from directed migration to a free or confined diffusion mode, a new noticeable protrusion is formed, and the overall structure of the cell membrane undergoes significant multilateral changes.\n\n\n::: {.columns}\n::: {.column width=\"100%\"}\n![t = 85](img/combined_cell_87_2.png){#fig-app2 fig-align=\"center\" width=\"100%\"}\n:::\n:::\n\n@fig-app2 shows how the cell increases its volume almost uniformly across the entire membrane curve.\n\n::: {.columns}\n::: {.column width=\"100%\"}\n![t = 230](img/combined_cell_87_3.png){#fig-app3 fig-align=\"center\" width=\"100%\"}\n:::\n:::\n\nTopological analysis @fig-app3 reveals how the cell transforms two protrusions into a single one while decreasing its volume.\n\n\nSince these conclusions are superficial and far-fetched, the farther exploration of single-cell topological representations might lead to a significant advance of this research. \n\n\n# References\n\n::: {#refs}\n:::\n\n",
    "supporting": [
      "project_report_files"
    ],
    "filters": [],
    "includes": {}
  }
}