{
  "hash": "ef3632412fb331df6e625b6326295b7f",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Defining landmarks for the ribosome exit tunnel\"\nauthor:\n  - name: \"Ella Teasell\" \n\ndate: \"October 2024\"\ncategories: [ribosome, cryo-em, bioinformatics]\njupyter: env1\nbibliography: references.bib\ncsl: nature.csl\n---\n\n\n\n\n## Introduction\n\nThe ribosome, the cellular machinery responsible for translation, is present in all domains of life, though exhibits varying conservation across phylogeny. It has been found that, as translation proceeds, the nascent polypeptide chain interacts with the tunnel, and as such, tunnel geometry plays a role in translation dynamics and resulting protein structures [@dao2019differences]. With advances in imaging of ribosome structure with Cryo-EM, there is ample data on which geometric analysis of the tunnel may be applied and therefore a need for more computational tools to do so [@dao2020heterogeneities].\n\n## Background\n\nIn order to preform geometric shape analysis on the ribosome, we must first superimpose mathematical definitions onto this biological context. Among others, one way of defining shape mathematically is with a set of landmarks. A landmark is a labelled point on some structure, which, biologically speaking, has some meaning. After removing the effects of translation, scaling, and rotation, sets of landmarks form a shape space, on which statistical analysis may be applied. \n\nAssigning landmarks to biological shapes is not a new idea; many examples involve defining landmarks as joins between bones or muscles, or as points along observed curves [@dryden]. However, there has been little work in assigning landmarks to biological molecules, and none specifically to the ribosome exit tunnel. The challenge is that any one landmark must have comparable instances across shapes in the shape space, meaning that we cannot arbitrarily pick residues which we know to be near to the tunnel. Such residues must be conserved, and therefore present in each specimen, to be considered useful.\n\n\n## Protocol\n\nBelow, I present a preliminary protocol for assigning landmarks to eukaryotic ribosome tunnels. The goal is to extrapolate to bacteria and archaea, as well as produce a combined dataset of landmarks which spans the kingdoms for inter-kingdom comparison. For now, I begin with eukaryota, taking advantage of the high degree of conservation between intra-kingdom ribosomes, as conserved sequences form the basis for this protocol.\n\nAs the goal for this dataset is to obtain landmarks that line the ribosome exit tunnel, I begin by selecting proteins and rRNA which interact with the tunnel: uL4, uL22, eL39, and 25/28S rRNA for Eukaryota [@dao2019differences].\n\n![Figure from Dao Duc et al. (2019) showing proteins affecting tunnel shape in E. coli and H. sapiens.](./data/NAR2019-tunnel-proteins.png)\n\nThe full protocol is available [here](https://github.com/eteasell/ribosome-exit-tunnel).\n\n### 1. Sequence Alignment\n\nIn order to assign landmarks which are comparable across ribosome specimens, I consider only the residues which are mostly conserved across our dataset of approximately 400 eukaryotes. To do so, I run Multiple Sequence Alignment (MSA) using MAFFT [@mafft] on the dataset for each of the chosen four polymer types and select residues from the MSA which are at least 90% conserved across samples.\n\n![A visualization of a subsection of the MSA showing a highly conserved region of uL4.](./data/eukaryota-uL4-seq-align.png)\n\nSelecting the most conserved residue at each position in the alignment:\n\n::: {#551caf23 .cell execution_count=1}\n``` {.python .cell-code}\n# Given an MSA column, return the most common element if it is at least as frequent as threshold\ndef find_conserved(column, threshold):\n    counter = Counter(column)\n    mode = counter.most_common(1)[0]\n    \n    if (mode[0] != '-' and mode[1] / len(column) >= threshold):\n        return mode[0]\n    \n    return None\n```\n:::\n\n\n### 2. Locating Residues {#sec-locating-landmarks}\n\nTo locate the conserved residues, I first map the chosen loci from the MSA back to the corresponding loci in the original sequences:\n\n::: {#e44eed4f .cell execution_count=2}\n``` {.python .cell-code}\nimport Bio\nfrom Bio.Seq import Seq\n\ndef map_to_original(sequence: Seq, position: int) -> int:\n  '''\n  Map conserved residue position to orignal sequence positions.\n  'sequence' is the aligned sequence from MSA.\n  '''\n  # Initialize pointer to position in original sequence\n  ungapped_position = 0\n    \n  # Iterate through each position in the aligned sequence\n  for i, residue in enumerate(sequence):\n      # Ignore any gaps '-'\n      if residue != \"-\":\n          # If we have arrived at the aligned position, return pointer to position in original sequence\n          if i == position:\n              return ungapped_position\n          # Every time we pass a 'non-gap' before arriving at position, we increase pointer by 1\n          ungapped_position += 1\n\n    # Return None if the position is at a gap     \n  return None\n```\n:::\n\n\nThen using PyMol [@PyMOL], retrieve the atomic coordinates of the residue from the CIF file. To obtain a single landmark per residue, I take the mean of the atomic coordinates for each residue as the landmark.\n\nBelow is example code for retrieving the atomic coordinates of W66 on 4UG0 uL4:\n\n::: {#f1a5a06a .cell execution_count=3}\n``` {.python .cell-code}\nfrom pymol import cmd\nimport numpy as np\nfrom Bio.SeqUtils import seq3\n\n# Specify the residue to locate\nparent = '4UG0'\nchain = 'LC'\nresidue = 'W'\nposition = 66\n\nif f'{parent}_{chain}' not in cmd.get_names():\n  cmd.load(f'data/{parent}.cif', object=f'{parent}_{chain}')\n  cmd.remove(f'not chain {chain}')\n    \nselect = f\"resi {position + 1}\"\n    \natom_coords = []\ncmd.iterate_state(1, select, 'atom_coords.append((chain, resn, x, y, z))', space={'atom_coords': atom_coords})\n    \nif (len(atom_coords) != 0 and atom_coords[0][1] == seq3(residue).upper()): \n    \n  vec = np.zeros(3)\n  for coord in atom_coords:\n    tmp_arr = np.array([coord[2], coord[3], coord[4]])\n    vec += tmp_arr\n\n  vec = vec / len(atom_coords)\n  vec = vec.astype(np.int32)\n        \n  print(f\"Coordinates: x: {vec[0]}, y: {vec[1]}, z: {vec[2]}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCoordinates: x: 115, y: 171, z: 156\n```\n:::\n:::\n\n\n### 3. Filtering landmarks by distance\n\nAmong the conserved residues on the selected polymers, many will be relatively far from the exit tunnel and not have any influence on tunnel geometry. Thus, I select only those residues which are close enough to the tunnel. In this protocol, a threshold of $7.5 \\mathring{A}$ is applied.\n\nThis process is done by using MOLE 2.0 [@mole], which is a biomolecular channel construction algorithm. The output is a list of points in $\\mathbb{R}^3$ which form the centerline of the tunnel, and, for each point on the centerline, a tunnel radius.\n\nUsing the MSA, I locate the coordinates of the conserved residues (see @sec-locating-landmarks). For each of the residues, find the closest tunnel centerline point in Euclidean space, and compute the distance from the residue to the sphere given by the radius at that centerline point. If this distance is less than the threshold, this conserved residue is close enough to the tunnel to be considered a landmark.\n\nFor efficiency, I only run the MOLE algorithm on one 'prototype' eukaryote to filter the landmarks, then use this filtered list as the list of landmarks to find on subsequent specimens.\n\nBelow is the code which checks landmark location against the tunnel points:\n\n::: {#34a4db17 .cell execution_count=4}\n``` {.python .cell-code}\nimport numpy as np\n\ndef get_tunnel_coordinates(instance: str) -> dict[int,list[float]]:\n    \n    if instance not in get_tunnel_coordinates.cache:\n        xyz = open(f\"data/tunnel_coordinates_{instance}.txt\", mode='r')\n        xyz_lines = xyz.readlines()\n        xyz.close()\n    \n        r = open(f\"data/tunnel_radius_{instance}.txt\", mode='r')\n        r_lines = r.readlines()\n        r.close()\n    \n        coords = {}\n    \n        for i, line in enumerate(xyz_lines):\n            if (i >= len(r_lines)): break\n        \n            content = line.split(\" \")\n            content.append(r_lines[i])\n        \n            cleaned = []\n            for str in content:\n                str.strip()\n                try:\n                    val = float(str)\n                    cleaned.append(val)\n                except:\n                    None\n        \n            coords[i] = cleaned\n        get_tunnel_coordinates.cache[instance] = coords\n        \n    # Each value in coords is of the form [x, y, z, r]\n    return get_tunnel_coordinates.cache[instance]\n\nget_tunnel_coordinates.cache = {}\n\n# p is a list [x,y,z]\n# instance is RCSB_ID code\ndef find_closest_point(p, instance):\n    coords = get_tunnel_coordinates(instance)\n    dist = np.inf\n    r = 0\n    p = np.array(p)\n    \n    for coord in coords.values():\n        xyz = np.array(coord[0:3])\n        euc_dist = np.sqrt(np.sum(np.square(xyz - p))) - coord[3]\n        if euc_dist < dist:\n            dist = euc_dist\n    \n    return dist\n```\n:::\n\n\nFinally, plotting the results using PyMol:\n\n![Landmarks shown in blue on a mesh representation of the 4UG0 tunnel, with proteins shown for reference (uL4 in pink, uL22 in green, and eL39 in yellow).](./data/4UG0_landmarks.gif)\n\nFor information on the mesh representation of the tunnel used in the figure above, see ['3D tesellation of biomolecular cavities'](https://bioshape-analysis.github.io/blog/posts/ribosome-tunnel-new/).\n\n### Notes\n\ni. The code in the post uses a package (```pymol-open-source```) which cannot be installed into a virtual environment. I have instead included a ```/yml``` file specifing my conda environment that is used to compile this code.\n\nii. The code used to retrieve atomic coordinates from PyMol is not robust to inconsistencies in CIF file sequence numbering present in the PDB. My next steps for improving this protocol will be to improve the handling of these edge cases.\n\n\n#### References\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}