{
  "hash": "16e2658be84f72d78418651aff08f0ea",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"3D tessellation of biomolecular cavities\"\nsubtitle: \"Protocol for analyzing the ribosome exit tunnel\"\nbibliography: references.bib\ncsl: nature.csl\nauthor:\n  - name: \"Artem Kushner\" \n  - name: \"Khanh Dao Duc\" \n\ndate: \"August 4 2024\"\ncategories: [ cryo-EM]    \nexecute:\n  freeze: auto\n---\n\n\n## Summary and Background\n\nWe present a protocol to extract the surface of a biomolecular cavity for shape analysis and molecular simulations.\n\nWe apply and illustrate the protocol on the ribosome structure, which contains a subcompartment known as the ribosome exit tunnel or \"nascent polypeptide exit tunnel\" (**NPET**). More details on the tunnel features and biological importance can be found in our previous works [@dao2018impact; @dao2019differences]. \n\nThe protocol was designed to refine the output obtained from MOLE software [@sehnal2013mole], but can be applied to reconstruct a mesh on any general point cloud. Hence,  we take the point-cloud of atom positions surrounding the tunnel as a point of departure. \n\n![Illustration of the ribosome exit tunnel (from Dao Duc et al., NAR 2019)](./data/gkz106fig1.jpeg){width=80%}\n\n<!-- ::: {layout=\"[[57,70] ]\"}\n![PDB 8OJ0. The structure of human ribosome.](./data/8OJ0.gif){fig-alt=\"\"}\n::: -->\n\n<!-- ![The locations of the ribosome exit tunnel and the PTC.](./data/ptc_and_tunnel_illustration.png){width=80%;fig-alt=\"\"} -->\n\n::: {.callout-note collapse=\"true\"}\n## Schematic representation of the protocol\n\n![](./data/visual_protocol.png){fig-alt=\"\"}\n:::\n\n## 1. Pointcloud Preparation: Bounding Box and Voxelization\n\n\n::: {.callout-note collapse=\"true\" icon=\"false\"}\n\n###  `atompos_to_voxel_sphere`: convert a 3D coordinate into a voxelized sphere\n\n::: {#d6243aef .cell execution_count=1}\n``` {.python .cell-code}\ndef atompos_to_voxelized_sphere(center: np.ndarray, radius: int):\n    \"\"\"Make sure radius reflects the size of the underlying voxel grid\"\"\"\n    x0, y0, z0 = center\n\n    #!------ Generate indices of a voxel cube of side 2r  around the centerpoint\n    x_range = slice(\n        int(np.floor(x0 - radius)), \n        int(np.ceil(x0 + radius)))\n    y_range = slice(\n        int(np.floor(y0 - radius)), \n        int(np.ceil(y0 + radius)))\n    z_range = slice(\n        int(np.floor(z0 - radius)), \n        int(np.ceil(z0 + radius)))\n\n    indices = np.indices(\n        (\n            x_range.stop - x_range.start,\n            y_range.stop - y_range.start,\n            z_range.stop - z_range.start,\n        )\n    )\n\n    indices      += np.array([x_range.start,\n                              y_range.start,\n                              z_range.start])[:, np.newaxis, np.newaxis, np.newaxis ]\n    indices       = indices.transpose(1, 2, 3, 0)\n    indices_list  = list(map(tuple, indices.reshape(-1, 3)))\n\n    #!------ Generate indices of a voxel cube of side 2r+2  around the centerpoint\n    sphere_active_ix = []\n\n    for ind in indices_list:\n        x_ = ind[0]\n        y_ = ind[1]\n        z_ = ind[2]\n        if (x_ - x0) ** 2 + (y_ - y0) ** 2 + (z_ - z0) ** 2 <= radius**2:\n            sphere_active_ix.append([x_, y_, z_])\n\n    return np.array(sphere_active_ix)\n```\n:::\n\n\n:::\n\n::: {.callout-note collapse=\"true\" icon=\"false\"}\n\n### `index_grid`: populate a voxel grid (with sphered atoms)\n\n::: {#a6121cf0 .cell execution_count=2}\n``` {.python .cell-code}\ndef index_grid(expanded_sphere_voxels: np.ndarray) :\n\n    def normalize_atom_coordinates(coordinates: np.ndarray)->tuple[ np.ndarray, np.ndarray ]:\n        \"\"\"@param coordinates: numpy array of shape (N,3)\"\"\"\n\n        C      = coordinates\n        mean_x = np.mean(C[:, 0])\n        mean_y = np.mean(C[:, 1])\n        mean_z = np.mean(C[:, 2])\n\n        Cx = C[:, 0] - mean_x\n        Cy = C[:, 1] - mean_y\n        Cz = C[:, 2] - mean_z\n        \n\n        [dev_x, dev_y, dev_z] = [np.min(Cx), np.min(Cy), np.min(Cz)]\n\n        #! shift to positive quadrant\n        Cx = Cx + abs(dev_x)\n        Cy = Cy + abs(dev_y)\n        Cz = Cz + abs(dev_z)\n\n        rescaled_coords = np.array(list(zip(Cx, Cy, Cz)))\n\n        return rescaled_coords, np.array([[mean_x,mean_y,mean_z], [abs( dev_x ), abs( dev_y ), abs( dev_z )]])\n\n    normalized_sphere_cords, mean_abs_vectors = normalize_atom_coordinates(expanded_sphere_voxels)\n    voxel_size = 1\n\n    sphere_cords_quantized = np.round(np.array(normalized_sphere_cords / voxel_size) ).astype(int)\n    max_values             = np.max(sphere_cords_quantized, axis=0)\n    grid_dimensions        = max_values + 1\n    vox_grid               = np.zeros(grid_dimensions)\n\n    print(\"Dimension of the voxel grid is \", vox_grid.shape)\n\n    vox_grid[\n        sphere_cords_quantized[:, 0],\n        sphere_cords_quantized[:, 1],\n        sphere_cords_quantized[:, 2]  ] = 1\n\n\n    return ( vox_grid, grid_dimensions, mean_abs_vectors )\n```\n:::\n\n\n:::\n\n\n__Bbox__: There are many ways to extract a point cloud from a larger biological structure -- in this case we settle for a bounding box that bounds the space between the PTC and the NPET vestibule.\n\n::: {#a2d6a007 .cell execution_count=3}\n``` {.python .cell-code}\n# \"bounding_box_atoms.npy\" is a N,3 array of atom coordinates\n\natom_centers = np.load(\"bounding_box_atoms.npy\") \n```\n:::\n\n\n**Sphering**: To make the representation of atoms slightly more physically-plausible we replace each atom-center coordinate with positions of voxels that fall within a sphere of radius $R$ around the atom's position. This is meant to represent the atom's van der Waals radius.\n\nOne could model different types of atoms ($N$,$C$,$O$,$H$ etc.) with separate radii, but taking $R=2$ proves a good enough compromise. The units are Angstrom and correspond to the coordinate system in which the structure of the ribosome is recorded. \n\n::: {#40b073b0 .cell execution_count=4}\n``` {.python .cell-code}\nvoxel_spheres = np.array([ atompos_to_voxel_sphere(atom, 2) for atom in atom_centers ])\n```\n:::\n\n\n__Voxelization & Inversion__: Since we are interested in the \"empty space\" between the atoms, we need a way to capture it. To make this possible we discretize the space by projecting the (sphered) point cloud into a voxel grid and invert the grid. \n\n::: {#5eb98f44 .cell execution_count=5}\n``` {.python .cell-code}\n# the grid is a binary 3D-array \n# with 1s where a normalized 3D-coordinate of an atom corresponds to the cell index and 0s elsewhere\n\n# by \"normalized\" i mean that the atom coordinates are\n# temporarily moved to the origin to decrease the size of the grid (see `index_grid` method further).\ninitial_grid, grid_dims, _ = index_grid(voxel_spheres)\n\n# The grid is inverted by changing 0->1 and 1->0\n# Now the atom locations are the null voxels and the empty space is active voxels\ninverted_grid              = np.asarray(np.where(initial_grid != 1)).T\n```\n:::\n\n\nCompare the following representation (*Inverted Point Cloud*) to the first point cloud: notice that where there previously was an active voxel is now an empty voxel and vice versa. The tubular constellation of active voxels in the center of the bounding box on this inverted grid is the tunnel \"space\" we are interested in.\n\n\n\n::: {#fig-cluster layout-ncol=2}\n\n\n![Initial bounding-box point cloud ](./data/4UG0.bbox_atoms.gif){#fig-ptcloud}\n\n![Inverted point cloud](./data/4UG0.inverted_grid.gif){#fig-inverted}\n\nPointcloud inversion via a voxel grid.\n\n\n:::\n\n\n## 2. Subcloud Extraction\n\n::: {#dbscan_note .callout-note collapse=\"true\"  icon=\"false\"}\n\n### `DBSCAN_capture`\n\n::: {#35167111 .cell execution_count=6}\n``` {.python .cell-code}\nfrom sklearn.cluster import DBSCAN\ndef DBSCAN_capture(\n    ptcloud: np.ndarray,\n    eps           ,\n    min_samples   ,\n    metric        : str = \"euclidean\",\n): \n\n    u_EPSILON     = eps\n    u_MIN_SAMPLES = min_samples\n    u_METRIC      = metric\n\n    print(\"Running DBSCAN on {} points. eps={}, min_samples={}, distance_metric={}\"\n    .format( len(ptcloud), u_EPSILON, u_MIN_SAMPLES, u_METRIC ) ) \n\n    db     = DBSCAN(eps=eps, min_samples=min_samples, metric=metric).fit(ptcloud) # <-- this is all you need\n\n    labels = db.labels_\n\n    CLUSTERS_CONTAINER = {}\n    for point, label in zip(ptcloud, labels):\n        if label not in CLUSTERS_CONTAINER:\n            CLUSTERS_CONTAINER[label] = []\n        CLUSTERS_CONTAINER[label].append(point)\n\n    CLUSTERS_CONTAINER = dict(sorted(CLUSTERS_CONTAINER.items()))\n    return db, CLUSTERS_CONTAINER\n```\n:::\n\n\n:::\n\n\n::: {#dbscan_note .callout-note collapse=\"true\"  icon=\"false\"}\n\n### `DBSCAN_pick_largest_cluster`\n\n::: {#32c6522f .cell execution_count=7}\n``` {.python .cell-code}\nfrom sklearn.cluster import DBSCAN\ndef DBSCAN_pick_largest_cluster(clusters_container:dict[int,list])->np.ndarray:\n    DBSCAN_CLUSTER_ID = 0\n    for k, v in clusters_container.items():\n        if int(k) == -1:\n            continue\n        elif len(v) > len(clusters_container[DBSCAN_CLUSTER_ID]):\n            DBSCAN_CLUSTER_ID = int(k)\n    return np.array(clusters_container[DBSCAN_CLUSTER_ID])\n```\n:::\n\n\n:::\n\n\n**Clustering**: Having obtained a voxelized representation of the interatomic spaces inside and around the NPET our task is now to extract _only the space_ that _corresponds to the NPET_. We use [DBSCAN](https://en.wikipedia.org/wiki/DBSCAN). \n\n\n`scikit`'s implementation of [ `DBSCAN` ](#dbscan_note) conveniently lets us retrieve the points from the largest cluster only, which corresponds to the active voxels of NPET space (if we eyeballed our DBSCAN parameters well).\n\n::: {#7e832afe .cell execution_count=8}\n``` {.python .cell-code}\nfrom scikit.cluster import DBSCAN\n\n_u_EPSILON, _u_MIN_SAMPLES, _u_METRIC  = 5.5, 600, 'euclidian'\n\n_, clusters_container   = DBSCAN_capture(inverted_grid, _u_EPSILON, _u_MIN_SAMPLES, _u_METRIC ) \nlargest_cluster         = DBSCAN_pick_largest_cluster(clusters_container)\n```\n:::\n\n\n::: {.callout-tip collapse=\"true\" }\n\n## DBSCAN Parameters and grid size.\n\nOur 1Å-side grid just happens to be granular enough to accomodate a \"correct\" separation of clusters for some empirically established values of `min_nbrs` and `epsilon` (DBSCAN parameters), where the largest cluster captures the tunnel space. \n\nA possible issue here is \"extraneous\" clusters merging into the cluster of interest and thereby corrupting its shape. In general this occurs when there are clusters of density that are _close enough_ (within `epsilon` to the main one to warrant a merge) and simultaneously _large enough_ that they fulfill the `min_nbrs` parameter. Hence it might be challenging to find the combination of `min_nbrs` and `epsilon` that is _sensitive enough_ to capture the main cluster completely and yet discriminating enough to not subsume any adjacent clusters.\n\nIn theory, a finer voxel grid  (_finer_ -- in relationship to the initial coordinates of the general point cloud; sub-angstrom in our case) would make finding the combination of parameters specific to the dataset easier: given that the atom-sphere would be represented by a proprotionally larger number of voxels, the euclidian distance calculation between two voxels would be less sensitive to the change in `epsilon`. \n\nPartioning the voxel grid further would come at a cost:\n\n- you would need to rewrite the sphering method for atoms (to account for the the new voxel-size)\n- the computational cost will increase dramatically, the dataset could conceivably stop fitting into memory alltogether. \n\n:::\n\n![Clusters identified by DBSCAN on the inverted index grid. The largest cluster corresponds to the tunnel space.](./data/4UG0.dbscan.clusters.gif)\n\n\n\n::: {#dbscan_note .callout-warning collapse=\"true\" appearance=\"default\"}\n\n### Subcloud refinement\n\n\nI found that this first pass of DBSCAN (`eps`=$5.5$, `min_nbrs`=$600$) successfully identifies the largest cluster with the tunnel but generally happens to be conservative in the amount of points that are merged into it. That is, there are still redundant points in this cluster that would make the eventual surface reconstruction spatially overlap with the rRNA and protiens. To \"sharpen\" this cluster we apply DBSCAN only to its sub-pointcloud and push the `eps` distance down to $3$ and `min_nbrs` to $123$ (again, \"empirically established\" values), which happens to be about the lowest parameter values at which any clusters form. This sharpened cluster is what the tesselation (surface reconstruction) will be performed on.\n\n\n::: {#fig-cluster layout-ncol=2}\n\n![Largest DBSCAN cluster (trimmed from the vestibule side). ](./data/4UG0.ptcloud_trimmed.gif){#fig-trimmed}\n\n![Cluster refinement: DBSCAN{e=3,mn=123} result (marine blue) on the largest cluster of DBSCAN{e=5.5,mn=600} (gray)](./data/4UG0.ptcloud_trimmed_sharpened.gif){#fig-trimmed-sharpened}\n\nSecond pass of DBSCAN sharpens the cluster to peel off the outer layer of redundant points.\n\n:::\n\n:::\n\n\n## 3. Tessellation\n\n\n::: {#ptcloud_convex_hull_points .callout-note collapse=\"true\" icon=\"false\"}\n### `ptcloud_convex_hull_points`\n\nSurface points can be extracted by creating an alpha shape over the point cloud and taking only the points that belong to the alpha surface. \n\n::: {#01c35d4a .cell execution_count=9}\n``` {.python .cell-code}\nimport pyvista as pv\nimport open3d as o3d\nimport numpy as np\n\ndef ptcloud_convex_hull_points(pointcloud: np.ndarray, ALPHA:float, TOLERANCE:float) -> np.ndarray:\n    assert pointcloud is not None\n    cloud       = pv.PolyData(pointcloud)\n    grid        = cloud.delaunay_3d(alpha=ALPHA, tol=TOLERANCE, offset=2, progress_bar=True)\n    convex_hull = grid.extract_surface().cast_to_pointset()\n    return convex_hull.points\n```\n:::\n\n\nOne could content themselves with the alpha shape representation of the NPET geometry and stop here, but it's easy to notice that the vertice of the polygon (red dots) are distributed unevenly over the surface. This is likely to introduce artifacts and instabilities into further simulations.\n\n::: {#fig-alpha layout-ncol=2}\n\n![Alpha-shape over the pointcloud](./data/4UG0.alphashape.gif){#fig-alpha-shape}\n\n![Surface points of the point cloud](./data/4UG0.surface_pts.gif){#fig-surf-pts}\n\nAlpha shape provides a way to identify surface points.\n\n:::\n\n:::\n\n\n::: {#estimate_normals .callout-note collapse=\"true\" icon=\"false\"}\n### `estimate_normals`\n\nNormal estimation is done via rolling a tangent plane over the surface points.\n\n::: {#be397b40 .cell execution_count=10}\n``` {.python .cell-code}\nimport pyvista as pv\nimport open3d as o3d\nimport numpy as np\n\ndef estimate_normals(convex_hull_surface_pts: np.ndarray, kdtree_radius=None, kdtree_max_nn=None, correction_tangent_planes_n=None): \n    pcd        = o3d.geometry.PointCloud()\n    pcd.points = o3d.utility.Vector3dVector(convex_hull_surface_pts)\n\n    pcd.estimate_normals(search_param=o3d.geometry.KDTreeSearchParamHybrid(radius=kdtree_radius, max_nn=kdtree_max_nn) )\n    pcd.orient_normals_consistent_tangent_plane(k=correction_tangent_planes_n)\n\n    return pcd\n```\n:::\n\n\n![Normals' orientations are depicted as vectors(black) on each datapoint.  ](./data/4UG0_normals.gif)\n\n:::\n\n::: {#apply_poisson_recon .callout-note collapse=\"true\" icon=\"false\"}\n### `apply_poisson_recon`\n\nThe source is available at [ https://github.com/mkazhdan/PoissonRecon ](https://github.com/mkazhdan/PoissonRecon). For programmability we connect the binary to the pipeline by wrapping it in a python `subprocess` but one can of course use the binary directly. \n\nThe output of the binary is a binary `.ply` (Stanford Triangle Format) file. For purposes of distribution we also produce an `asciii`-encoded version of this `.ply` file side-by-side: some geometry packages are only able to parse the `ascii` version.\n\n::: {#d6df00a6 .cell execution_count=11}\n``` {.python .cell-code}\ndef apply_poisson_reconstruction(surf_estimated_ptcloud_path: str, recon_depth:int=6, recon_pt_weight:int=3):\n    import plyfile\n    # The documentation can be found at https://www.cs.jhu.edu/~misha/Code/PoissonRecon/Version16.04/ in \"PoissonRecon\" binary\n    command = [\n        POISSON_RECON_BIN,\n        \"--in\",\n        surf_estimated_ptcloud_path,\n        \"--out\",\n        output_path,\n        \"--depth\",\n        str(recon_depth),\n        \"--pointWeight\",\n        str(recon_pt_weight),\n        \"--threads 8\"\n    ]\n    process = subprocess.run(command, capture_output=True, text=True)\n    if process.returncode == 0:\n        print(\">>PoissonRecon executed successfully.\")\n        print(\">>Wrote {}\".format(output_path))\n        # Convert the plyfile to asciii\n        data = plyfile.PlyData.read(output_path)\n        data.text = True\n        ascii_duplicate =output_path.split(\".\")[0] + \"_ascii.ply\"\n        data.write(ascii_duplicate)\n        print(\">>Wrote {}\".format(ascii_duplicate))\n    else:\n        print(\">>Error:\", process.stderr)\n```\n:::\n\n\n![The final NPET surface reconstruction ](./data/4UG0.reconstruction.gif)\n\n:::\n\n\n\nNow, having refined the largest DBSCAN cluster, we have a pointcloud which faithfully represent the tunnel geometry. To create a watertight mesh from this point cloud we need to prepare the dataset:\n\n- retrieve only the \"surface\" points from the pointcloud\n- estimate _normals_ on the surface points (establish data orientation)\n\n::: {#a87aeb5a .cell execution_count=12}\n``` {.python .cell-code}\nd3d_alpha, d3d_tol     = 2, 1\n\nsurface_pts = ptcloud_convex_hull_points(coordinates_in_the_original_frame, d3d_alpha,d3d_tol)\npointcloud  = estimate_normals(surface_pts, kdtree_radius=10, kdtree_max_nn=15, correction_tangent_planes_n=10)\n```\n:::\n\n\nThe dataset is now ready for surface reconstruction. We reach for Poisson surface reconstruction[@kazhdan2006poisson] by _Kazhdan_ and _Hoppe_, a de facto standard in the field. \n\n::: {#de2d41c5 .cell execution_count=13}\n``` {.python .cell-code}\nPR_depth , PR_ptweight = 6, 3\napply_poisson_recon(pointcloud, recon_depth=PR_depth, recon_pt_weight=PR_ptweight)\n```\n:::\n\n\n## Result\n\nWhat you are left with is a smooth polygonal mesh in the `.ply` format. Below is the illustration of the fidelity of the representation. Folds and depressions can clearly be seen engendered by three proteins surrounding parts of the tunnel (uL22 _yellow_, uL4 _light blue_ and eL39 _magenta_). rRNA is not shown.[@zhou2018open3d,@sullivan2019pyvista]\n\n![The NPET mesh surrounded by by three ribosome proteins](./data/tunnel_proteins.gif)\n\n\n\n\n\n## References\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}