{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Extracting cell geometry from Atomic Force Microscopy\"\n",
        "subtitle: \"Part 1: Static analysis\"\n",
        "jupyter: python3\n",
        "\n",
        "author:\n",
        "  - name: \"Cl√©ment Soubrier\" \n",
        "    email: \"c.soubrier@math.ubc.ca\"\n",
        "    affiliations:\n",
        "      - name: KDD Group\n",
        "\n",
        "  - name: \"Khanh Dao Duc\" \n",
        "    email: \"kdd@math.ubc.ca\"\n",
        "    affiliations:\n",
        "      - name: Department of Mathematics, UBC\n",
        "        url: \"https://www.math.ubc.ca/\"\n",
        "      - name: Department of Computer Science, UBC\n",
        "        url: \"https://www.cs.ubc.ca/\"\n",
        "\n",
        "date: \"July 31 2024\"\n",
        "categories: [biology, bioinformatics]    \n",
        "\n",
        "callout-icon: false\n",
        "format:\n",
        "  html:\n",
        "    code-fold: true\n",
        "bibliography: bibliography.bib\n",
        "\n",
        "execute:\n",
        "  echo: true\n",
        "  freeze: auto\n",
        "  warning: false\n",
        "\n",
        "---\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "We present here the protocole to process biological images such as bacteria atomic force miroscopy data. We want to study the bacteria cell shape and extract the main geometrical feature.\n",
        "\n",
        "## Biological context\n",
        "*Mycobacterium smegmatis* is Grahm-positive rod shape bacterium. It is 3 to 5 $\\mu m$ long and around 500 $nm$ wide. This non-pathogenic species is otften used a biological model to study the pathogenic Mycobacteria such as *M.tuberculosis* (responsible for the tubercuosis) or *M.abscessus*, with which it shares the same cell wall structure [@tyagi2002mycobacterium]. In particular *M.smegmatis* has a fast growth (3-4 hours doubling time compared to 24h for *M. tuberculosis*), allowing for faster experimental protocols. \n",
        "\n",
        "\n",
        "Here are some know properties of *M.smegmatis* bacteria :\n",
        "\n",
        "* They present variation of cell diameter along their longitudinal axis [@eskandarian2017division]. The cell diameter is represented as a height profile along the cell centerline. We respectively name peaks and troughs the local maxima and minima of this profile.\n",
        "\n",
        "![3D image of *M.smegmatis*. The orange line represents the height profile.](3D_cell.png)\n",
        "\n",
        "* They grow following a biphasic and asymetrical polar dynamics [@hannebelle2020biphasic]. The cells elongate from the poles, where material is added. After division, the pre-existing pole (OP) elongate at a high rate, whereas the newly created pole (NP) has first a slow growth, and then switches to a fast growth, after the New End Take Off (NETO).\n",
        "\n",
        "![Growth dynamics.](Neto.svg)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "## Raw image pre-processing\n",
        "#### Data\n",
        "\n",
        "Several data acquisitions were conducted with wild types and different mutant strains. The raw data is composed of AFM log files times series for each experiments. Each log file contain several images, each one representing a physical channel such as height, stiffness, adhesion etc. After extraction of the data, forward and backward cells are aligned, artefacts such as image scars are detected and corrected.\n",
        "\n",
        "![At each time step, images representing different physical variables are produced by the AFM](Figure_1_quarto.png)\n",
        "\n",
        "## Segmentation\n",
        "At each time steps, images are segmented to detect each cells using the cellpose package [@stringer2021cellpose]. If available, different physical channels are combined to improve the segmentation. Forward and backward images are also combined.\n",
        "\n",
        "![Images are combined to improve the segmentation](Figure_2_quarto.png)\n",
        "\n",
        "Here is an example on how to use cellpose on an image. Different models are available (with the `seg_mod` variable), depending on the training datasets. With cellpose 3, different denoising models are also available (with the `denoise_mod` variable). \n"
      ],
      "id": "1c4fc746"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "from cellpose import io, denoise, plot\n",
        "from PIL import Image\n",
        "\n",
        "\n",
        "'''\n",
        "Parameters\n",
        "'''\n",
        "\n",
        "image_path = 'raw_img.png'\n",
        "path_to_save = 'segmented_img'\n",
        "# Segmentation model type\n",
        "seg_mod = 'cyto'   \n",
        "# Denoizing model\n",
        "denoise_mod = \"denoise_cyto3\"  \n",
        "# Expected cell diameter (pixels)\n",
        "dia = 40\n",
        "# Type of segmentation (with / without nuclei, different color channels or not)\n",
        "chan = [0,0] \n",
        "# Segmentation sensibility parameters\n",
        "thres = 0.8\n",
        "celp = 0.4\n",
        "\n",
        "'''\n",
        "Computing segmentation\n",
        "'''\n",
        "\n",
        "\n",
        "# Opening image to segment\n",
        "img=np.array(Image.open(image_path))[:,:,1]\n",
        "\n",
        "# Chosing a model type :\n",
        "model = denoise.CellposeDenoiseModel(gpu=False, model_type=seg_mod, restore_type=denoise_mod)\n",
        "\n",
        "# Computing segmentaion\n",
        "masks, flows, st, diams = model.eval(img, diameter = dia, channels=chan, flow_threshold = thres, cellprob_threshold=celp)\n",
        "\n",
        "\n",
        "# Saving the results into a numpy file\n",
        "io.masks_flows_to_seg(img, masks, flows, path_to_save, channels=chan, diams=diams)\n"
      ],
      "id": "f9f1f408",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We plot the final results :\n"
      ],
      "id": "c50de557"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| fig-cap: \"Raw image\"\n",
        "\n",
        "plt.imshow(img,cmap='gray')\n",
        "plt.show()"
      ],
      "id": "1a3b99bf",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| fig-cap: \"Image with segmented masks overlaid\"\n",
        "\n",
        "mask_RGB = plot.mask_overlay(img,masks)\n",
        "plt.imshow(mask_RGB)\n",
        "plt.show()"
      ],
      "id": "9d872910",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Centerline\n",
        "Since we are interested in studying the variations of the cell diameter, we define height profile as the value of the cell height along the cell centerline. The cell centerline are computed using a skeletonization algorithm [@zhang1984fast,@lee1994building]. Here is an example of skeletonization \n"
      ],
      "id": "49c40ac3"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from skimage.morphology import skeletonize\n",
        "\n",
        "# Selecting first mask\n",
        "first_mask =  masks == 1\n",
        "\n",
        "skel_img = skeletonize(first_mask, method='lee')  \n",
        "skel = np.argwhere(skel_img)\n",
        "plt.imshow(first_mask, cmap='gray')\n",
        "\n",
        "plt.scatter(skel[:,1], skel[:,0], 0.5*np.ones(np.shape(skel[:,0])), color='r', marker='.')\n",
        "plt.show()"
      ],
      "id": "1ef89e0e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Depending on the masks shapes, centerlines may have branches :\n"
      ],
      "id": "30e0af6a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from skimage.morphology import skeletonize\n",
        "\n",
        "# Selecting first mask\n",
        "first_mask =  masks == 3\n",
        "\n",
        "skel_img = skeletonize(first_mask)  #, method='lee'\n",
        "skel = np.argwhere(skel_img)\n",
        "plt.imshow(first_mask, cmap='gray')\n",
        "\n",
        "plt.scatter(skel[:,1], skel[:,0], 0.5*np.ones(np.shape(skel[:,0])), color='r', marker='.')\n",
        "plt.show()"
      ],
      "id": "93a2cad4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "In practice, centerlines are pruned and extended to the cell poles, in order to capture the cell length. Other geometrical properties such as masks centroids or outlines are computed as well.\n",
        "\n",
        "![Final static processing results in real life data. White masks are excluded from the cell tracking algorithm (see part 2). Black dots are cell centroids. The yellow boxes represent artefacts cleaning.](Figure_3_quarto.png)\n",
        "\n",
        "# References"
      ],
      "id": "c31c4022"
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}