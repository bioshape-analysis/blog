<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Mo Wang">
<meta name="dcterms.date" content="2024-12-15">

<title>Farm Shape Analysis: Linking Geometry with Crop Yield and Diversity – bioshape-analysis</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-5027bf1c1f92ac6615724d89c8213d6a.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">bioshape-analysis</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Farm Shape Analysis: Linking Geometry with Crop Yield and Diversity</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">landscape-analysis</div>
                <div class="quarto-category">agriculture</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Mo Wang </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">December 15, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction-and-motivation" id="toc-introduction-and-motivation" class="nav-link active" data-scroll-target="#introduction-and-motivation">1. Introduction and Motivation</a></li>
  <li><a href="#dataset-overview-and-preparation" id="toc-dataset-overview-and-preparation" class="nav-link" data-scroll-target="#dataset-overview-and-preparation">2. Dataset Overview and Preparation</a>
  <ul class="collapse">
  <li><a href="#data-source" id="toc-data-source" class="nav-link" data-scroll-target="#data-source">Data Source</a></li>
  <li><a href="#refined-litefarm-dataset" id="toc-refined-litefarm-dataset" class="nav-link" data-scroll-target="#refined-litefarm-dataset">Refined Litefarm Dataset</a></li>
  </ul></li>
  <li><a href="#shape-analysis" id="toc-shape-analysis" class="nav-link" data-scroll-target="#shape-analysis">3. Shape Analysis</a>
  <ul class="collapse">
  <li><a href="#vertex-distribution-analysis" id="toc-vertex-distribution-analysis" class="nav-link" data-scroll-target="#vertex-distribution-analysis">1. Vertex Distribution Analysis</a></li>
  <li><a href="#validation-of-area-and-perimeter-metrics" id="toc-validation-of-area-and-perimeter-metrics" class="nav-link" data-scroll-target="#validation-of-area-and-perimeter-metrics">2. Validation of Area and Perimeter Metrics</a></li>
  </ul></li>
  <li><a href="#field-polygon-standardization-and-preparation" id="toc-field-polygon-standardization-and-preparation" class="nav-link" data-scroll-target="#field-polygon-standardization-and-preparation">Field Polygon Standardization and Preparation</a></li>
  <li><a href="#shape-alignment-and-fréchet-mean-analysis" id="toc-shape-alignment-and-fréchet-mean-analysis" class="nav-link" data-scroll-target="#shape-alignment-and-fréchet-mean-analysis">Shape Alignment and Fréchet Mean Analysis</a></li>
  <li><a href="#global-fréchet-mean-and-outlier-detection" id="toc-global-fréchet-mean-and-outlier-detection" class="nav-link" data-scroll-target="#global-fréchet-mean-and-outlier-detection">Global Fréchet Mean and Outlier Detection</a></li>
  <li><a href="#fréchet-mean-shape-by-country" id="toc-fréchet-mean-shape-by-country" class="nav-link" data-scroll-target="#fréchet-mean-shape-by-country">Fréchet Mean Shape by Country</a>
  <ul class="collapse">
  <li><a href="#assessing-mean-shape-representation-in-countries-with-limited-data" id="toc-assessing-mean-shape-representation-in-countries-with-limited-data" class="nav-link" data-scroll-target="#assessing-mean-shape-representation-in-countries-with-limited-data">Assessing Mean Shape Representation in Countries with Limited Data</a></li>
  <li><a href="#detecting-potential-fake-field-polygons" id="toc-detecting-potential-fake-field-polygons" class="nav-link" data-scroll-target="#detecting-potential-fake-field-polygons">Detecting Potential Fake Field Polygons</a></li>
  <li><a href="#future-work" id="toc-future-work" class="nav-link" data-scroll-target="#future-work">Future Work</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="introduction-and-motivation" class="level2">
<h2 class="anchored" data-anchor-id="introduction-and-motivation">1. Introduction and Motivation</h2>
<p>In modern agriculture, the geometric features of farmland play a crucial role in farm management and planning. Understanding these characteristics enables farmers to make informed decisions, manage resources more efficiently, and promote sustainable agricultural practices.</p>
<p>This research leverages data from <a href="https://www.litefarm.org/">Litefarm</a>, an open-source agri-tech application designed to support sustainable agriculture. Litefarm provides detailed information about farmland, including field shapes, offering valuable insights for analysis. However, as an open platform, Litefarm’s database may include unrealistic or inaccurate data entries, such as “fake farms.” Cleaning and validating this data is essential for ensuring the reliability of agricultural analyses.</p>
<p>In this blog, we focus on identifying fake farms by analyzing field shapes to detect unrealistic entries. Our goal is to enhance data accuracy, providing a stronger foundation for future agriculture-related research.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/Litefarm.png" class="img-fluid figure-img"></p>
<figcaption>Litefarm Interface</figcaption>
</figure>
</div>
</section>
<section id="dataset-overview-and-preparation" class="level2">
<h2 class="anchored" data-anchor-id="dataset-overview-and-preparation">2. Dataset Overview and Preparation</h2>
<section id="data-source" class="level3">
<h3 class="anchored" data-anchor-id="data-source">Data Source</h3>
<p>The data for this study was extracted from Litefarm’s database, which contains detailed information about farm geometries, locations, and user associations. The dataset included the following key attributes:</p>
<ul>
<li><p><strong>Farm-Level Information</strong>:<br>
Each farm is uniquely identified by a <strong>farm_ID</strong>, representing an individual farm within the Litefarm database.</p></li>
<li><p><strong>Polygon-Level Information</strong>:<br>
Each farm consists of multiple polygons, corresponding to distinct areas such as <strong>fields</strong>, <strong>gardens</strong>, or <strong>barns</strong>. Each polygon is uniquely identified by a <strong>location_ID</strong>, ensuring that every area within a farm is individually traceable.</p></li>
<li><p><strong>Geometric Attributes</strong>:</p>
<ul>
<li><strong>Area</strong>: The total surface area of the polygon.<br>
</li>
<li><strong>Perimeter</strong>: The boundary length of the polygon.</li>
</ul></li>
<li><p><strong>Vertex Coordinates</strong>:<br>
The geographic shape of each polygon is defined by a list of vertex coordinates in latitude and longitude format, represented as: <code>[(lat1, lon1), (lat2, lon2), ..., (latN, lonN)]</code>.</p></li>
<li><p><strong>Polygon Types</strong>:<br>
The polygons in each farm are categorized into various types:</p>
<ul>
<li><strong>Fields</strong><br>
</li>
<li><strong>Farm site boundaries</strong><br>
</li>
<li><strong>Residences</strong><br>
</li>
<li><strong>Barns</strong><br>
</li>
<li><strong>Gardens</strong><br>
</li>
<li><strong>Surface water</strong><br>
</li>
<li><strong>Natural areas</strong><br>
</li>
<li><strong>Greenhouses</strong><br>
</li>
<li><strong>Ceremonial areas</strong></li>
</ul></li>
</ul>
<p>This rich dataset captures farm structures and geometries comprehensively, enabling the analysis of relationships between polygon features and agricultural outcomes.</p>
<p>This study focuses specifically on <strong>productive areas</strong>—gardens, greenhouses, and fields—as these contribute directly to agricultural output. Since different polygon types possess unique geometric characteristics, we focused on a single type to maintain analytical consistency.</p>
<p>As the Litefarm database is dynamic and continuously updated, the data captured as of November 28th showed that 36.4% of farms included garden areas, 20.7% had greenhouse areas, and nearly 70% contained fields. To ensure a robust and representative analysis, we focused on field polygons, which had the highest proportion within the dataset.</p>
</section>
<section id="refined-litefarm-dataset" class="level3">
<h3 class="anchored" data-anchor-id="refined-litefarm-dataset">Refined Litefarm Dataset</h3>
<p>To ensure that only valid and realistic farm data was included in the analysis, we applied rigorous SQL filters to the Litefarm database. These filters excluded:</p>
<ul>
<li>Placeholder farms and internal test accounts.<br>
</li>
<li>Deleted records.<br>
</li>
<li>Farms located in countries with insufficient representation (fewer than 10 farms).</li>
</ul>
<p>The table below summarizes the results of the filtering process and the composition of the cleaned dataset:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Description</th>
<th>Count</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Initial number of farms in Litefarm</td>
<td>3,559</td>
</tr>
<tr class="even">
<td>Farms after SQL filtering</td>
<td>2,919</td>
</tr>
<tr class="odd">
<td>Farms with field areas</td>
<td>2,022</td>
</tr>
<tr class="even">
<td>Farms with garden areas</td>
<td>1,063</td>
</tr>
<tr class="odd">
<td>Farms with greenhouse areas</td>
<td>607</td>
</tr>
<tr class="even">
<td>Total number of field polygons</td>
<td>6,340</td>
</tr>
</tbody>
</table>
<p>By narrowing the focus to field polygons, we ensured that the dataset was both robust and suitable for exploring the relationship between geometric features and agricultural outcomes.</p>
</section>
</section>
<section id="shape-analysis" class="level2">
<h2 class="anchored" data-anchor-id="shape-analysis">3. Shape Analysis</h2>
<p>This study focuses on the geometric properties of field polygons, as these are essential for understanding farm structures and ensuring data reliability. Each field polygon is represented by a series of vertices in latitude-longitude pairs, which outline its geometric boundaries. These vertices are the foundation for calculating key metrics such as <strong>area</strong>, <strong>perimeter</strong>, and more complex shape properties.</p>
<p>To perform a robust analysis, we systematically processed and evaluated the field polygon data through the following steps:</p>
<section id="vertex-distribution-analysis" class="level3">
<h3 class="anchored" data-anchor-id="vertex-distribution-analysis">1. Vertex Distribution Analysis</h3>
<p>The first step in our analysis was to examine the <strong>vertex distribution</strong> of the field polygons to understand their general characteristics and ensure data quality. A box plot was created to visualize the distribution of vertex counts: <img src="img/boxplot.png" class="img-fluid" alt="boxplot of vertices’ number distribution"></p>
<p>The results revealed a wide range of vertex counts, spanning from 3 to 189 vertices. This variability required filtering to address potential outliers. Using the <strong>z-score method</strong>, we identified and excluded extreme values, capping the maximum vertex count at 34.</p>
<p>After filtering, we analyzed the revised vertex distribution using a histogram, which revealed that 47.4% of field polygons had exactly four vertices:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/number_of_vertices.png" class="img-fluid figure-img"></p>
<figcaption>histogram of number of veritces</figcaption>
</figure>
</div>
</section>
<section id="validation-of-area-and-perimeter-metrics" class="level3">
<h3 class="anchored" data-anchor-id="validation-of-area-and-perimeter-metrics">2. Validation of Area and Perimeter Metrics</h3>
<section id="recalculation-process" class="level4">
<h4 class="anchored" data-anchor-id="recalculation-process">Recalculation Process:</h4>
<ol type="1">
<li>Vertex coordinates, initially in latitude-longitude format, were transformed into a planar coordinate system (<code>EPSG:6933</code>) to enable precise calculations.</li>
<li><strong>Area</strong> and <strong>perimeter</strong> were computed directly from the transformed vertex data.</li>
</ol>
<p>Scatter plots comparing the user-provided values with the recalculated metrics showed strong alignment, with most points clustering around the diagonal (dashed line), confirming the accuracy of the recalculated values:</p>
<ul>
<li><p><strong>Perimeter Comparison</strong><br>
<img src="img/perimeter1.png" class="img-fluid" alt="Perimeter Scatter Plot"></p></li>
<li><p><strong>Area Comparison</strong><br>
<img src="img/area1.png" class="img-fluid" alt="Area Scatter Plot"></p></li>
</ul>
<p>This validation step provided confidence in the accuracy of the recalculated metrics, allowing us to proceed with subsequent shape analysis using reliable data.</p>
</section>
</section>
</section>
<section id="field-polygon-standardization-and-preparation" class="level2">
<h2 class="anchored" data-anchor-id="field-polygon-standardization-and-preparation">Field Polygon Standardization and Preparation</h2>
<p>To focus on the geometric properties of field polygons, we projected all polygons into a <strong>size-and-shape space</strong>. This transformation isolates the shape and scale of the polygons while removing variations caused by rotation and translation. The size-and-shape space ensures consistent and meaningful comparisons of the underlying geometric features.</p>
<p>While this study emphasizes polygon shapes, we recognize that <strong>area</strong> is a critical feature in agricultural studies due to its relationship with factors like regional regulations and agricultural policies. Thus, we preserved the size (scaling) component in our analysis to maintain the relevance of area.</p>
<p>To ensure uniformity and consistency in the dataset, we performed the following preprocessing steps:</p>
<ol type="1">
<li><strong>Standardizing Landmark Points</strong>:</li>
</ol>
<p>To enable meaningful comparisons in the size-and-shape space, each polygon was resampled to have exactly 34 evenly spaced points along its boundary. The following Python function illustrates this process:</p>
<div id="a6587b3a" class="cell" data-execution_count="1">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> folium</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> json</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> shapely.geometry <span class="im">import</span> shape, Polygon, Point, MultiPoint, MultiPolygon, LineString,LinearRing, MultiLineString</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> shapely.ops <span class="im">import</span> unary_union, transform, nearest_points</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> geopy.distance</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> itertools <span class="im">import</span> combinations</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> itertools</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pyproj</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> functools <span class="im">import</span> partial</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> altair <span class="im">as</span> alt</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> plotly.graph_objs <span class="im">as</span> go</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pyproj <span class="im">import</span> Transformer, CRS </span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> plotly.express <span class="im">as</span> px</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> logging</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> shapely.validation <span class="im">import</span> explain_validity</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> geopandas <span class="im">as</span> gpd</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ast</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> geographiclib.geodesic <span class="im">import</span> Geodesic</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> StandardScaler</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.decomposition <span class="im">import</span> PCA</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> geopy.distance <span class="im">import</span> geodesic</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> geomstats.geometry.pre_shape <span class="im">import</span> PreShapeSpace</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> geomstats.visualization <span class="im">import</span> KendallDisk, KendallSphere</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="70df897c" class="cell" data-execution_count="2">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> resample_polygon(projected_coords, num_points<span class="op">=</span><span class="dv">34</span>):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Resample a polygon's boundary to have a specified number of evenly spaced points.</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="co">    - projected_coords: List of coordinates defining the polygon's boundary.</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co">    - num_points: The number of evenly spaced points to resample (default is 34).</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="co">    - new_coords: List of resampled coordinates.</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    ring <span class="op">=</span> LinearRing(projected_coords)</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    total_length <span class="op">=</span> ring.length</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    distances <span class="op">=</span> np.linspace(<span class="dv">0</span>, total_length, num_points, endpoint<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    new_coords <span class="op">=</span> [ring.interpolate(distance).coords[<span class="dv">0</span>] <span class="cf">for</span> distance <span class="kw">in</span> distances]</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> new_coords</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<ol start="2" type="1">
<li><strong>Ensuring Consistent Vertex Direction</strong>:</li>
</ol>
<p>All polygons were standardized to have vertices drawn in the same direction (clockwise or counterclockwise). This step ensures that the orientation of the vertices does not introduce inconsistencies in the analysis.</p>
<div id="454a0a73" class="cell" data-execution_count="3">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> is_clockwise(coords):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Check if the polygon vertices are in a clockwise direction.</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co">    - coords: List of coordinates defining the polygon's boundary.</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="co">    - True if the polygon is clockwise; False otherwise.</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    ring <span class="op">=</span> LinearRing(coords)</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ring.is_ccw <span class="op">==</span> <span class="va">False</span> </span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> make_clockwise(coords):</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="co">    Convert the polygon's vertices to a clockwise direction, if it is not </span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span class="co">    - coords: List of coordinates defining the polygon's boundary.</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a><span class="co">    - List of coordinates ordered in a clockwise direction.</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> is_clockwise(coords):  </span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> [coords[<span class="dv">0</span>]] <span class="op">+</span> coords[:<span class="dv">0</span>:<span class="op">-</span><span class="dv">1</span>]  <span class="co"># Reverse the vertex order, keeping the start point</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> coords</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The image illustrates four polygons that have been standardized by resampling them to have 34 evenly spaced points, with all vertices aligned in a clockwise direction.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/resampled_polygon.png" class="img-fluid figure-img"></p>
<figcaption>The standardized polygon</figcaption>
</figure>
</div>
<section id="validation-of-standardization" class="level4">
<h4 class="anchored" data-anchor-id="validation-of-standardization">Validation of Standardization</h4>
<p>To confirm the accuracy of these transformations, we compared the areas and perimeters of the resampled polygons with the original values. The results demonstrated minimal deviation, indicating the transformations preserved the integrity of the shapes.</p>
<ul>
<li><strong>Perimeter Comparison</strong></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/resamples_perimeter.png" class="img-fluid figure-img"></p>
<figcaption>perimeter comparison</figcaption>
</figure>
</div>
<ul>
<li><strong>Area Comparison</strong></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/resampled_area.png" class="img-fluid figure-img"></p>
<figcaption>area comparison</figcaption>
</figure>
</div>
<p>By meeting these preprocessing requirements, we ensured that the polygons were accurately prepared for subsequent shape analysis.</p>
</section>
</section>
<section id="shape-alignment-and-fréchet-mean-analysis" class="level2">
<h2 class="anchored" data-anchor-id="shape-alignment-and-fréchet-mean-analysis">Shape Alignment and Fréchet Mean Analysis</h2>
<p>With data preparation complete, the polygons were ready for analysis in the <strong>size-and-shape space</strong>. This specialized framework enables consistent comparison of shapes by accounting for geometric differences, including scaling, translation, and rotation. It provides a robust foundation for meaningful geometric analysis.</p>
<p>The polygons were aligned using <strong>Procrustes analysis</strong><span class="citation" data-cites="dryden2016shape">(<a href="#ref-dryden2016shape" role="doc-biblioref">Dryden and Mardia 2016</a>)</span>, and their <strong>Fréchet Mean</strong> was iteratively computed in Euclidean space. This process standardizes the shapes, ensuring variations caused by translation and rotation are removed, allowing for accurate and meaningful comparisons.</p>
<p>The <strong>Fréchet Mean</strong><span class="citation" data-cites="dryden2016shape">(<a href="#ref-dryden2016shape" role="doc-biblioref">Dryden and Mardia 2016</a>)</span> represents the “average” shape in a geometric space (manifold), minimizing the average squared distance to all sample shapes. It serves as a standardized and central representation of the dataset.</p>
<hr>
<section id="step-by-step-overview" class="level4">
<h4 class="anchored" data-anchor-id="step-by-step-overview">Step-by-Step Overview</h4>
<ol type="1">
<li><strong>Shape Alignment</strong>:
<ul>
<li>The <code>align_shape</code> function performs Procrustes alignment through the following steps:
<ol type="1">
<li><strong>Removing Translation</strong>:
<ul>
<li>The centroid (average position of all points) of each shape is computed. The shape is then centered by subtracting its centroid from all points, ensuring the shape is position-independent.</li>
</ul></li>
<li><strong>Removing Rotation</strong>:
<ul>
<li>Using Singular Value Decomposition (SVD), the optimal rotation matrix is calculated to align the target shape with the reference shape. This step removes rotation differences while preserving the relative positions of the points.</li>
</ul></li>
</ol></li>
</ul></li>
<li><strong>Measuring Shape Differences</strong>:
<ul>
<li>The <code>riemannian_distance</code> function computes the <strong>Riemannian distance</strong> between two shapes in size-and-shape space. This metric quantifies geometric differences between shapes, considering both size and rotation.</li>
</ul></li>
</ol>
<hr>
<section id="riemannian-distance-in-size-and-shape-space" class="level5">
<h5 class="anchored" data-anchor-id="riemannian-distance-in-size-and-shape-space">Riemannian Distance in Size-and-Shape Space</h5>
<p>Given two <span class="math inline">\(k\)</span>-point configurations in <span class="math inline">\(m\)</span>-dimensions, <span class="math inline">\(X_1^o, X_2^o \in \mathbb{R}^{k \times m}\)</span>, the <strong>Riemannian distance</strong><span class="citation" data-cites="dryden2016shape">(<a href="#ref-dryden2016shape" role="doc-biblioref">Dryden and Mardia 2016</a>)</span> in size-and-shape space is defined as:</p>
<p><span class="math display">\[
d_S(X_1^o, X_2^o) = \sqrt{S_1^2 + S_2^2 - 2 S_1 S_2 \cos \rho(X_1^o, X_2^o)}
\]</span></p>
<p>where:</p>
<ul>
<li><p><span class="math inline">\(S_1, S_2\)</span>: Centroid sizes of <span class="math inline">\(X_1^o\)</span> and <span class="math inline">\(X_2^o\)</span>, representing the Frobenius norms of the centered shapes.</p></li>
<li><p><span class="math inline">\(\rho(X_1^o, X_2^o)\)</span>: Riemannian shape distance.</p></li>
</ul>
<p>This formula ensures that the distance captures both shape similarity and scaling differences, making it a robust tool for geometric analysis.</p>
<ol start="3" type="1">
<li><strong>Iterative Fréchet Mean Calculation</strong>:
<ul>
<li>The algorithm begins with an initial <strong>reference shape</strong> and aligns all other shapes to it using Procrustes alignment.</li>
<li>The Fréchet Mean is then calculated as the average shape in Euclidean space.</li>
<li>The shapes are iteratively re-aligned to the updated Fréchet Mean, refining the alignment and mean calculation until convergence is achieved.</li>
</ul></li>
</ol>
<hr>
</section>
</section>
<section id="python-implementation" class="level4">
<h4 class="anchored" data-anchor-id="python-implementation">Python Implementation</h4>
<p>The following Python code implements the entire process of shape alignment, Riemannian distance computation, and iterative Fréchet Mean calculation.</p>
<div id="2794764d" class="cell" data-execution_count="4">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> align_shape(reference_shape, target_shape):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Align the target shape to the reference shape using Procrustes alignment.</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="co">    - reference_shape: The reference shape to align to.</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="co">    - target_shape: The shape to be aligned.</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="co">    - aligned_shape: The aligned target shape.</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    reference_shape <span class="op">=</span> np.array(reference_shape)</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    target_shape <span class="op">=</span> np.array(target_shape)</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 1: Remove the translation</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    centroid_reference <span class="op">=</span> np.mean(reference_shape, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    centroid_target <span class="op">=</span> np.mean(target_shape, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    centered_reference <span class="op">=</span> reference_shape <span class="op">-</span> centroid_reference</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    centered_target <span class="op">=</span> target_shape <span class="op">-</span> centroid_target</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 2: Remove the rotation</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    u, s, vh <span class="op">=</span> np.linalg.svd(np.matmul(np.transpose(centered_target), centered_reference))</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>    r <span class="op">=</span> np.matmul(u, vh)</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>    aligned_shape <span class="op">=</span> np.matmul(centered_target, r)</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> aligned_shape</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> riemannian_distance(reference_shape, target_shape):</span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a><span class="co">    Compute the Riemannian distance between two shapes.</span></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a><span class="co">    - reference_shape: The reference shape.</span></span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a><span class="co">    - target_shape: The target shape.</span></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a><span class="co">    - distance: The Riemannian distance between the shapes.</span></span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>    reference_shape <span class="op">=</span> np.array(reference_shape)</span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>    target_shape <span class="op">=</span> np.array(target_shape)</span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 1: Compute centroid sizes</span></span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a>    S1 <span class="op">=</span> np.linalg.norm(reference_shape)  </span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a>    S2 <span class="op">=</span> np.linalg.norm(target_shape)</span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 2: Remove translation by centering the shapes</span></span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a>    centered_reference <span class="op">=</span> reference_shape <span class="op">-</span> np.mean(reference_shape, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a>    centered_target <span class="op">=</span> target_shape <span class="op">-</span> np.mean(target_shape, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb4-49"><a href="#cb4-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-50"><a href="#cb4-50" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 3: Compute optimal rotation using SVD</span></span>
<span id="cb4-51"><a href="#cb4-51" aria-hidden="true" tabindex="-1"></a>    H <span class="op">=</span> np.dot(centered_target.T, centered_reference)</span>
<span id="cb4-52"><a href="#cb4-52" aria-hidden="true" tabindex="-1"></a>    U, _, Vt <span class="op">=</span> np.linalg.svd(H)</span>
<span id="cb4-53"><a href="#cb4-53" aria-hidden="true" tabindex="-1"></a>    R <span class="op">=</span> np.dot(U, Vt)</span>
<span id="cb4-54"><a href="#cb4-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-55"><a href="#cb4-55" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 4: Align target shape</span></span>
<span id="cb4-56"><a href="#cb4-56" aria-hidden="true" tabindex="-1"></a>    aligned_target <span class="op">=</span> np.dot(centered_target, R)</span>
<span id="cb4-57"><a href="#cb4-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-58"><a href="#cb4-58" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 5: Compute the Riemannian distance</span></span>
<span id="cb4-59"><a href="#cb4-59" aria-hidden="true" tabindex="-1"></a>    cosine_rho <span class="op">=</span> np.trace(np.dot(aligned_target.T, centered_reference)) <span class="op">/</span> (S1 <span class="op">*</span> S2)</span>
<span id="cb4-60"><a href="#cb4-60" aria-hidden="true" tabindex="-1"></a>    cosine_rho <span class="op">=</span> np.clip(cosine_rho, <span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb4-61"><a href="#cb4-61" aria-hidden="true" tabindex="-1"></a>    distance <span class="op">=</span> np.sqrt(S1<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> S2<span class="op">**</span><span class="dv">2</span> <span class="op">-</span> <span class="dv">2</span> <span class="op">*</span> S1 <span class="op">*</span> S2 <span class="op">*</span> cosine_rho)</span>
<span id="cb4-62"><a href="#cb4-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-63"><a href="#cb4-63" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> distance</span>
<span id="cb4-64"><a href="#cb4-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-65"><a href="#cb4-65" aria-hidden="true" tabindex="-1"></a><span class="co"># Iterative Fréchet Mean Calculation</span></span>
<span id="cb4-66"><a href="#cb4-66" aria-hidden="true" tabindex="-1"></a>epsilon <span class="op">=</span> <span class="fl">1e-6</span>  </span>
<span id="cb4-67"><a href="#cb4-67" aria-hidden="true" tabindex="-1"></a>max_iterations <span class="op">=</span> <span class="dv">100</span>  </span>
<span id="cb4-68"><a href="#cb4-68" aria-hidden="true" tabindex="-1"></a>reference_shape <span class="op">=</span> field_data[<span class="st">'resampled_point'</span>].iloc[<span class="dv">0</span>]  </span>
<span id="cb4-69"><a href="#cb4-69" aria-hidden="true" tabindex="-1"></a>aligned_shapes <span class="op">=</span> []</span>
<span id="cb4-70"><a href="#cb4-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-71"><a href="#cb4-71" aria-hidden="true" tabindex="-1"></a><span class="co"># Align all shapes to the initial reference shape</span></span>
<span id="cb4-72"><a href="#cb4-72" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> target_shape <span class="kw">in</span> field_data[<span class="st">'resampled_point'</span>]:</span>
<span id="cb4-73"><a href="#cb4-73" aria-hidden="true" tabindex="-1"></a>    aligned_shape <span class="op">=</span> align_shape(reference_shape, target_shape)</span>
<span id="cb4-74"><a href="#cb4-74" aria-hidden="true" tabindex="-1"></a>    aligned_shapes.append(aligned_shape)</span>
<span id="cb4-75"><a href="#cb4-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-76"><a href="#cb4-76" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialize Euclidean space and calculate initial Fréchet Mean</span></span>
<span id="cb4-77"><a href="#cb4-77" aria-hidden="true" tabindex="-1"></a>euclidean_space <span class="op">=</span> Euclidean(dim<span class="op">=</span>aligned_shapes[<span class="dv">0</span>].shape[<span class="dv">1</span>])</span>
<span id="cb4-78"><a href="#cb4-78" aria-hidden="true" tabindex="-1"></a>frechet_mean <span class="op">=</span> FrechetMean(euclidean_space)</span>
<span id="cb4-79"><a href="#cb4-79" aria-hidden="true" tabindex="-1"></a>previous_frechet_mean_shape <span class="op">=</span> frechet_mean.fit(aligned_shapes).estimate_</span>
<span id="cb4-80"><a href="#cb4-80" aria-hidden="true" tabindex="-1"></a>converged <span class="op">=</span> <span class="va">False</span></span>
<span id="cb4-81"><a href="#cb4-81" aria-hidden="true" tabindex="-1"></a>iteration <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb4-82"><a href="#cb4-82" aria-hidden="true" tabindex="-1"></a>frechet_means <span class="op">=</span> [previous_frechet_mean_shape]</span>
<span id="cb4-83"><a href="#cb4-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-84"><a href="#cb4-84" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="kw">not</span> converged <span class="kw">and</span> iteration <span class="op">&lt;</span> max_iterations:</span>
<span id="cb4-85"><a href="#cb4-85" aria-hidden="true" tabindex="-1"></a>    iteration <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb4-86"><a href="#cb4-86" aria-hidden="true" tabindex="-1"></a>    aligned_shapes2 <span class="op">=</span> []</span>
<span id="cb4-87"><a href="#cb4-87" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> target_shape <span class="kw">in</span> field_data[<span class="st">'resampled_point'</span>]:</span>
<span id="cb4-88"><a href="#cb4-88" aria-hidden="true" tabindex="-1"></a>        aligned_shape <span class="op">=</span> align_shape(previous_frechet_mean_shape, target_shape)</span>
<span id="cb4-89"><a href="#cb4-89" aria-hidden="true" tabindex="-1"></a>        aligned_shapes2.append(aligned_shape)</span>
<span id="cb4-90"><a href="#cb4-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-91"><a href="#cb4-91" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate new Fréchet Mean</span></span>
<span id="cb4-92"><a href="#cb4-92" aria-hidden="true" tabindex="-1"></a>    frechet_mean <span class="op">=</span> FrechetMean(euclidean_space)</span>
<span id="cb4-93"><a href="#cb4-93" aria-hidden="true" tabindex="-1"></a>    current_frechet_mean_shape <span class="op">=</span> frechet_mean.fit(aligned_shapes2).estimate_</span>
<span id="cb4-94"><a href="#cb4-94" aria-hidden="true" tabindex="-1"></a>    frechet_means.append(current_frechet_mean_shape)</span>
<span id="cb4-95"><a href="#cb4-95" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-96"><a href="#cb4-96" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check convergence</span></span>
<span id="cb4-97"><a href="#cb4-97" aria-hidden="true" tabindex="-1"></a>    difference <span class="op">=</span> riemannian_distance(previous_frechet_mean_shape, current_frechet_mean_shape)</span>
<span id="cb4-98"><a href="#cb4-98" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> difference <span class="op">&lt;</span> epsilon:</span>
<span id="cb4-99"><a href="#cb4-99" aria-hidden="true" tabindex="-1"></a>        converged <span class="op">=</span> <span class="va">True</span></span>
<span id="cb4-100"><a href="#cb4-100" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb4-101"><a href="#cb4-101" aria-hidden="true" tabindex="-1"></a>        previous_frechet_mean_shape <span class="op">=</span> current_frechet_mean_shape</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
</section>
<section id="global-fréchet-mean-and-outlier-detection" class="level2">
<h2 class="anchored" data-anchor-id="global-fréchet-mean-and-outlier-detection">Global Fréchet Mean and Outlier Detection</h2>
<p>Here is the global Fréchet mean calculated from all field polygons:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/mean_shape.png" class="img-fluid figure-img"></p>
<figcaption>The global mean shape</figcaption>
</figure>
</div>
<p>The following image illustrates the original polygon and its alignment with the Fréchet mean:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/aligned_shape.png" class="img-fluid figure-img"></p>
<figcaption>Aligned Shape</figcaption>
</figure>
</div>
<p>After aligning all shapes to the Fréchet mean, the <code>riemannian_distance</code> function was used to calculate the distances between the mean shape and each aligned shape. To identify potential outliers, the z-score method was applied to these distance values.</p>
<p>Below are the four field polygons detected as outliers using the global Fréchet mean:</p>
<div id="99600bce" class="cell" data-execution_count="5">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Load the CSV file</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>four_potiential_fake_farm <span class="op">=</span> pd.read_csv(<span class="st">"data/potiential_fake_field.csv"</span>)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Display the table</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>four_potiential_fake_farm   <span class="co"># Or use `data` to show the entire table</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="1">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Farm Number</th>
<th data-quarto-table-cell-role="th">country_name</th>
<th data-quarto-table-cell-role="th">type</th>
<th data-quarto-table-cell-role="th">calculated_perimeter_m</th>
<th data-quarto-table-cell-role="th">calulated_area_ha</th>
<th data-quarto-table-cell-role="th">number of vertices</th>
<th data-quarto-table-cell-role="th">distance_to_frechet_mean</th>
<th data-quarto-table-cell-role="th">z_score</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>Farm 310</td>
<td>United States</td>
<td>field</td>
<td>744797.7117</td>
<td>2.600780e+06</td>
<td>3</td>
<td>591590.0609</td>
<td>48.784896</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>Farm 71</td>
<td>Canada</td>
<td>field</td>
<td>864206.5248</td>
<td>4.251124e+06</td>
<td>5</td>
<td>709800.2531</td>
<td>58.580655</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>Farm 45</td>
<td>Canada</td>
<td>field</td>
<td>341370.9916</td>
<td>8.453115e+04</td>
<td>5</td>
<td>177371.8498</td>
<td>14.459753</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>Farm 2792</td>
<td>India</td>
<td>field</td>
<td>200958.9993</td>
<td>2.170029e+05</td>
<td>4</td>
<td>166440.3554</td>
<td>13.553890</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
</section>
<section id="fréchet-mean-shape-by-country" class="level2">
<h2 class="anchored" data-anchor-id="fréchet-mean-shape-by-country">Fréchet Mean Shape by Country</h2>
<p>The shape of field polygons varies significantly across different countries. To capture this variation, we calculated the <strong>Fréchet mean shape</strong>* for each country based on the fields located within that specific country.</p>
<p>The plot below summarizes the Fréchet mean shapes for all countries in the dataset.</p>
<p>In this visualization, <strong>different colors represent different continents</strong>. It is evident that both the shapes and areas of the field polygons differ substantially across regions, highlighting the diversity in field geometry across countries.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/output.png" class="img-fluid figure-img"></p>
<figcaption>Summary of Countries’ Mean Shapes</figcaption>
</figure>
</div>
<section id="assessing-mean-shape-representation-in-countries-with-limited-data" class="level3">
<h3 class="anchored" data-anchor-id="assessing-mean-shape-representation-in-countries-with-limited-data">Assessing Mean Shape Representation in Countries with Limited Data</h3>
<p>To evaluate the representativeness of the mean shape, we specifically selected countries with fewer than 10 polygons. The small number of polygons in these cases allows for easier visualization, helping us assess whether the mean shape effectively captures the overall geometric characteristics of these datasets.</p>
<section id="zambia" class="level4">
<h4 class="anchored" data-anchor-id="zambia">Zambia</h4>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/small_number_country1.png" class="img-fluid figure-img"></p>
<figcaption>Field polygons and Fréchet mean for Zambia</figcaption>
</figure>
</div>
</section>
<section id="chile" class="level4">
<h4 class="anchored" data-anchor-id="chile">Chile</h4>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/small_number_country.png" class="img-fluid figure-img"></p>
<figcaption>Field polygons and Fréchet mean for Chile</figcaption>
</figure>
</div>
<p>From the above plots, we can draw the following conclusions:</p>
<ul>
<li><p><strong>Effective Representation with Similar Shapes</strong>:</p>
<p>When the field polygons within a country have similar shapes, the calculated Fréchet mean serves as an effective representation of the general shape trend.</p></li>
<li><p><strong>Limitations with Diverse Shapes</strong>:</p>
<p>If the field polygons within a country show significant variation in their shapes, the Fréchet mean becomes less representative and may fail to adequately capture the geometric diversity of the dataset.</p></li>
</ul>
</section>
</section>
<section id="detecting-potential-fake-field-polygons" class="level3">
<h3 class="anchored" data-anchor-id="detecting-potential-fake-field-polygons">Detecting Potential Fake Field Polygons</h3>
<p>Building on the country-level mean shape analysis, we applied the same methodology to detect potential fake field polygons. For each country, field polygons were aligned to their corresponding <strong>Fréchet mean</strong>, and the <strong>z-score technique</strong> was used to identify anomalies based on the distances between each polygon and the mean shape.</p>
<p>Through this analysis, we identified <strong>51 potential fake field polygons</strong>. To verify their validity, we visualized each field polygon on satellite imagery. The results are summarized in the plot below:</p>
<ul>
<li><strong>Gray markers</strong>: Fake fields<br>
</li>
<li><strong>Pink markers</strong>: True fields<br>
</li>
<li><strong>Orange markers</strong>: Potential fake fields</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/satelite.png" class="img-fluid figure-img"></p>
<figcaption>Satellite plot for all 51 potential fake fields</figcaption>
</figure>
</div>
<p>After visualizing all 51 potential fake field polygons, the findings were as follows:</p>
<ul>
<li><strong>45.1%</strong> were confirmed as fake fields.<br>
</li>
<li><strong>29.4%</strong> were ambiguous, meaning they could potentially be either fake or real fields, requiring further investigation.</li>
<li><strong>25.5%</strong> were determined to be true fields.</li>
</ul>
<p>Below are examples of confirmed fake fields. These polygons often exhibit:</p>
<ul>
<li><p><strong>Unusual geometric shapes</strong></p></li>
<li><p><strong>Sizes that are disproportionately large compared to neighboring field polygons</strong></p></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/fake_farm.jpg" class="img-fluid figure-img"></p>
<figcaption>fake field polygons</figcaption>
</figure>
</div>
</section>
<section id="future-work" class="level3">
<h3 class="anchored" data-anchor-id="future-work">Future Work</h3>
<p>Our analysis successfully identified a significant number of potential fake field polygons, with nearly half of these cases being validated as genuinely fake. While this demonstrates the effectiveness of our approach, there is still room to improve the accuracy and reliability of the detection process. To further refine our results, future efforts will focus on:</p>
<ol type="1">
<li><strong>Incorporate Geographic Information</strong>:<br>
Enrich the dataset with geographic features such as proximity to natural landmarks (e.g., mountains, rivers) or man-made structures (e.g., urban areas, roads). These features could provide valuable context for improving the calculation of the Fréchet mean and detecting anomalies more effectively.</li>
<li><strong>Improve Outlier Detection Methods</strong>:<br>
Leverage advanced machine learning models, such as clustering algorithms or ensemble methods, to identify subtle patterns and relationships that may indicate fake fields. Techniques like unsupervised learning or deep anomaly detection could also be explored to improve performance.</li>
</ol>
</section>
<section id="references" class="level3">




</section>
</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-dryden2016shape" class="csl-entry" role="listitem">
Dryden, Ian L., and Kanti V. Mardia. 2016. <em>Statistical Shape Analysis, with Applications in r</em>. Wiley Series in Probability and Statistics. Chichester, UK: John Wiley &amp; Sons, Ltd. <a href="https://doi.org/10.1002/9781119072492">https://doi.org/10.1002/9781119072492</a>.
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/bioshape-analysis\.github\.io\/blog\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>