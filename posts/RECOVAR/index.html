<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Qiyu Wang">
<meta name="dcterms.date" content="2024-09-18">

<title>Heterogeneity analysis of cryo-EM data of proteins dynamic in comformation and composition using linear subspace methods – bioshape-analysis</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-659650fc26dc25888fc1474f317bb8ac.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">bioshape-analysis</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Heterogeneity analysis of cryo-EM data of proteins dynamic in comformation and composition using linear subspace methods</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">cryo-EM</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Qiyu Wang </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">September 18, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#background" id="toc-background" class="nav-link active" data-scroll-target="#background">Background</a></li>
  <li><a href="#methods" id="toc-methods" class="nav-link" data-scroll-target="#methods">Methods</a>
  <ul class="collapse">
  <li><a href="#regularized-covariance-estimation" id="toc-regularized-covariance-estimation" class="nav-link" data-scroll-target="#regularized-covariance-estimation">Regularized covariance estimation</a></li>
  <li><a href="#latent-space-embedding" id="toc-latent-space-embedding" class="nav-link" data-scroll-target="#latent-space-embedding">Latent space embedding</a></li>
  <li><a href="#conformation-reconstruction" id="toc-conformation-reconstruction" class="nav-link" data-scroll-target="#conformation-reconstruction">Conformation reconstruction</a></li>
  <li><a href="#estimation-of-state-density" id="toc-estimation-of-state-density" class="nav-link" data-scroll-target="#estimation-of-state-density">Estimation of state density</a></li>
  <li><a href="#motion-recovery" id="toc-motion-recovery" class="nav-link" data-scroll-target="#motion-recovery">Motion recovery</a></li>
  </ul></li>
  <li><a href="#results" id="toc-results" class="nav-link" data-scroll-target="#results">Results</a>
  <ul class="collapse">
  <li><a href="#results-of-public-datasets" id="toc-results-of-public-datasets" class="nav-link" data-scroll-target="#results-of-public-datasets">Results of public datasets</a></li>
  <li><a href="#results-of-sars-cov2-datasets" id="toc-results-of-sars-cov2-datasets" class="nav-link" data-scroll-target="#results-of-sars-cov2-datasets">Results of SARS-CoV2 datasets</a></li>
  </ul></li>
  <li><a href="#discussion" id="toc-discussion" class="nav-link" data-scroll-target="#discussion">Discussion</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="background" class="level2">
<h2 class="anchored" data-anchor-id="background">Background</h2>
<p>Cryogenic electron microscopy (cryo-EM), a cryomicroscopy technique applied on samples embedding in ice, along with recent development of powerful hardwares and softwares, have achieved huge success in the determination of biomolecular structures at near-atomic level. Cryo-EM takes screenshots of thousands or millions of particles in different poses frozen in the sample, and thus allows the reconstruction of the 3D structure from those 2D projections.</p>
<p>Early algorithms and softwares of processing cryo-EM data focus on resolving homogeneous structure of biomolecules. However, many biomolecules are very dynamic in conformations, compositions, or both. For example, ribosomes comprise of many sub-units, and their compositions may vary within the sample and are of research interest. Spike protein is an example of conformational heterogeneity, where the receptor-binding domain (RBD) keeps switching between close and open states in order to bind to receptors and meanwhile resist the binding of antibody <span class="citation" data-cites="PPR:PPR217218">(<a href="#ref-PPR:PPR217218" role="doc-biblioref">Taka et al. 2020</a>)</span>. When studying the antigen-antibody complex, both compositional and conformational heterogeneity need to be considered.</p>
<div class="quarto-figure quarto-figure-center" style="display: block; margin-left: auto; margin-right: auto;">
<figure class="figure">
<p><img src="img/spike.png" class="img-fluid figure-img" style="width:65.0%"></p>
<figcaption>A simple illustration of the conformational heterogeneity of spike protein, where it displays two kinds of conformations: closed RBD and open RBD of one chain (colored in blue) <span class="citation" data-cites="Wang2020">(<a href="#ref-Wang2020" role="doc-biblioref">Wang et al. 2020</a>)</span>. Spike protein is a trimer so in reality all the three chains will move possibly in different ways and the motion of spike protein is much more complex than what’s shown here.</figcaption>
</figure>
</div>
<p>The initial heterogeneity analysis of 3D structrues reconstructed from cryo-EM data started from relatively simple 3D classfication, which outputs discrete classes of different conformations. This is usually done by expectation-maximization (EM) algorithms, where 2D particle stacks were iteratively assigned to classes and used to reconstruct the volume of that class <span class="citation" data-cites="scheres_2012">(<a href="#ref-scheres_2012" role="doc-biblioref">Scheres 2012</a>)</span>. However, such an approach has two problems: first, the classification decreases the number of images used to reconstruct the volume, and thus lower the resolution we are able to achieve; second, the motion of biomolecule is continuous in reality and discrete classification may not describe the heterogeneity very well, and we may miss some transient states.</p>
<p>Therefore, nowadays people start to focus on methods modeling continuous heterogeneity without any classification step to avoid the above issues. Most methods adopt similar structures, where 2D particle stacks are mapped to latent embeddings, clusters/trajectories are estimated in latent space, and finally volumes are mapped and reconstructed from latent embeddings. Early methods use linear mapping (e.g.&nbsp;3DVA), but with the applications of deep learning techniques in the field of cryo-EM data processing, people find methods adapted from variational autoencoder (VAE) achieving better performance (e.g.&nbsp;cryoDRGN, 3DFlex). Nevertheless, the latent space obtained from VAE and other deep learning methods is hard to interpret, and do not conserve distances and densities, imposing difficulties in reconstructing motions/trajectories, which are what most structure biologists desire at the end.</p>
<p>Recent developed software RECOVAR <span class="citation" data-cites="Gilles2023">(<a href="#ref-Gilles2023" role="doc-biblioref">Gilles and Singer 2024</a>)</span>, using a linear mapping like 3DVA, was shown to achieve comparable or even better performance with deep learning methods, and meanwhile has high interpretability and allows easy recovery of motions/trajectories from latent space. For this project, I will review the pipeline of RECOVAR, discussed improvements and extensions we made to this pipeline, and present heterogeneity analysis results from the original paper and our SARS-CoV2 spike protein dataset.</p>
</section>
<section id="methods" class="level2">
<h2 class="anchored" data-anchor-id="methods">Methods</h2>
<section id="regularized-covariance-estimation" class="level3">
<h3 class="anchored" data-anchor-id="regularized-covariance-estimation">Regularized covariance estimation</h3>
<p>Let <span class="math inline">\(N\)</span> be the dimension of the grid and <span class="math inline">\(n\)</span> be the number of images. We start with formulating the formation process of each cryo-EM image in the Fourier space <span class="math inline">\(y_i\in\mathbb{C}^{N^2}\)</span> from its corresponding conformation <span class="math inline">\(x_i\in\mathbb{C}^{N^3}\)</span> as: <span class="math display">\[y_i = C_i\hat{P}(\phi_i)x_i + \epsilon_i, \epsilon_i\sim N(0, \Lambda_i) \]</span></p>
<p>where <span class="math inline">\(\hat{P}(\phi_i)\)</span> is the projetion from 3D to 2D after rigid body motion with pose <span class="math inline">\(\phi_i\)</span>, <span class="math inline">\(C_i\)</span> is the contrast transfer function (CTF), and <span class="math inline">\(\epsilon_i\)</span> represents the Gaussian noise. RECOVAR will assume that <span class="math inline">\(C_i\)</span> and <span class="math inline">\(\phi_i\)</span> were given. This can be done via many existing ab-initio methods. Hence in the following analysis, we will simply fix the linear map <span class="math inline">\(P_i:=C_i\hat{P}(\phi_i)\)</span>.</p>
<p>When poses are known, the mean <span class="math inline">\(\mu\in\mathbb{C}^{N^3}\)</span> of the distribution of conformations can be estimated by solving:</p>
<p><span class="math display">\[\hat{\mu}:=\underset{\mu}{\mathrm{argmin}}\sum_{i=1}^{n}\lVert y_i-P_i\mu\rVert_{\Lambda^{-1}}^2+\lVert\mu\rVert_w^2\]</span></p>
<p>where <span class="math inline">\(\lVert v\rVert_{\Lambda^{-1}}^2=v^*\Lambda^{-1}v\)</span> and <span class="math inline">\(\lVert v\rVert_w^2=\sum_i|v_i|^2w_i\)</span>. <span class="math inline">\(w\in \mathbb{R}^{N^3}\)</span> is the optional Wiener filter. Similarly, covariance can be estimated as the solution to the linear system corresponding to the following:</p>
<p><span class="math display">\[\hat{\Sigma}:=\underset{\Sigma}{\mathrm{argmin}}\sum_{i=1}^n\lVert(y_i-P_i\hat{\mu})(y_i-P_i\hat{\mu})^*-(P_i\Sigma P_i^*+\Lambda_i)\rVert_F^2+\lVert\Sigma\rVert_R^2\]</span></p>
<p>where <span class="math inline">\(\lVert A\rVert_F^2=\sum_{i,j}A_{i,j}^2\)</span> and <span class="math inline">\(\lVert A\rVert_R^2=\sum_{i,j}A_{i,j}^2R_{i,j}\)</span>. <span class="math inline">\(R\)</span> is the regularization weight.</p>
<p>Our goal at this step is to compute principal components (PCs) from <span class="math inline">\(\hat{\mu}\)</span> and <span class="math inline">\(\hat{\Sigma}\)</span>. Nevertheless, computing the entire matrix of <span class="math inline">\(\hat{\Sigma}\)</span> is impossible considering that we have to compute <span class="math inline">\(N^6\)</span> entries. Fortunately, for low-rank variance matrix only a subset of the columns is required to estimate the entire matrix and its leading eigenvectors, which are just PCs. <span class="math inline">\(d\)</span> PCs can be computed in <span class="math inline">\(O(d(N^3+nN^2))\)</span>, much faster than <span class="math inline">\(O(N^6)\)</span> required to compute the entire covariance matrix. Here a heuristic scheme is used to choose which columes to be used to compute eigenvectors. First, all columns are added into the considered set. Then the column corresponding to the pixel with the highest SNR in the considered set is iteratively added to the chosen set, and pixels nearby are removed from the considered set, until there are a disirable number of columns <span class="math inline">\(d\)</span> in the chosen set. We estimate the entries of the chosen columns and their complex conjugates and let them form <span class="math inline">\(\hat{\Sigma}_{col}\)</span>. Let <span class="math inline">\(\tilde{U}\in\mathbb{C}^{N^3\times d}\)</span> be orthogonalized <span class="math inline">\(\hat{\Sigma}_{col}\)</span>. It follows that we can compute the reduced covariance matrix <span class="math inline">\(\hat{\Sigma}_{\tilde{U}}\)</span> by:</p>
<p><span class="math display">\[\hat{\Sigma}_{\tilde{U}}:=\underset{\Sigma_{\tilde{U}}}{\mathrm{argmin}}\sum_{i=1}^n\lVert(y_i-P_i\hat{\mu})(y_i-P_i\hat{\mu})^*-(P_i\tilde{U}\Sigma_{\tilde{U}}\tilde{U}^* P_i^*+\Lambda_i)\rVert_F^2\]</span></p>
<p>Basically, we just replace <span class="math inline">\(\Sigma\)</span> in the formula to estimate the entire covariance matrix shown before with <span class="math inline">\(\tilde{U}\Sigma_{\tilde{U}}\tilde{U}^*\)</span>. Finally, we just need to perform an eigendecomposition on <span class="math inline">\(\hat{\Sigma}_{\tilde{U}}\)</span> and obtain <span class="math inline">\(\hat{\Sigma}_{\tilde{U}}=V\Gamma V^*\)</span>. The eigenvectors (which are the PCs we want) and eigenvalues would be <span class="math inline">\(U:=\tilde{U}V\)</span> and <span class="math inline">\(\Gamma\)</span> repectively.</p>
</section>
<section id="latent-space-embedding" class="level3">
<h3 class="anchored" data-anchor-id="latent-space-embedding">Latent space embedding</h3>
<p>With PCs computed from the last step, denoted by <span class="math inline">\(U\in\mathbb{C}^{N^3\times d}\)</span>, we can project <span class="math inline">\(x_i\)</span> onto lower-dimensional latent space by <span class="math inline">\(z_i = U^*(x_i-\hat{\mu})\in\mathbb{R}^d\)</span>. Assuming <span class="math inline">\(z_i\sim N(0,\Gamma)\)</span>, the MAP estimation of <span class="math inline">\(P(z_i|y_i)\)</span> can be obtained by solving:</p>
<p><span class="math display">\[\hat{a}_i, \hat{z}_i = \underset{a_i\in\mathbb{R}^+, z_i\in\mathbb{R}^d}{\mathrm{argmin}}\lVert a_iP_i(Uz_i+\hat{\mu})-y_i\rVert_{\Lambda_i^{-1}}^2+\lVert z_i\rVert_{\Gamma^{-1}}^2\]</span></p>
<p>where <span class="math inline">\(a_i\)</span> is a scaling factor used to capture the effect of display variations in contrast.</p>
</section>
<section id="conformation-reconstruction" class="level3">
<h3 class="anchored" data-anchor-id="conformation-reconstruction">Conformation reconstruction</h3>
<p>After computing the latent embeddings, the next question would naturally be how to reconstruct conformations from embeddings. The most intuitive way is to do reprojection <em>i.e</em>. <span class="math inline">\(\hat{x}\leftarrow Uz+\hat{\mu}\)</span>. Nevertheless, reprojection only works well when all the relevant PCs can be computed, which is almost impossible considering the low signal-to-noise ratio (SNR) in practice. Therefore, an alternative scheme based on adaptive kernel regression is used here. Given a fixed latent position <span class="math inline">\(z^*\)</span> and the frequency <span class="math inline">\(\xi^k\in\mathbb{R}^3\)</span> in the 3D Fourier space of the volume whose value we would like to estimate, the kernel regression estimates of this form are computed as:</p>
<p><span class="math display">\[x(h;\xi^k) = \underset{x_k}{\mathrm{argmin}}\sum_{i,j}\frac{1}{\sigma_{i,j}^2}|C_{i,j}x_k-y_{i,j}|^2K(\xi^k,\xi_{i,j})K_i^h(z^*,z_i)\]</span></p>
<p>where <span class="math inline">\(h\)</span> is bandwitdth; <span class="math inline">\(\sigma_{i,j}\)</span> is the variance of <span class="math inline">\(\epsilon_{i,j}\)</span>, which is the noise of frequency <span class="math inline">\(j\)</span> of the <span class="math inline">\(i\)</span>-th observation; <span class="math inline">\(y_{i,j}\)</span> is the value of frequency <span class="math inline">\(j\)</span> of the <span class="math inline">\(i\)</span>-th observation; <span class="math inline">\(\xi_{i,j}\)</span> is the frequency <span class="math inline">\(j\)</span> of the <span class="math inline">\(i\)</span>-th observation in 3D adjusted by <span class="math inline">\(\phi_i\)</span>. We have two kernel functions in this formulation. <span class="math inline">\(K(\xi^k,\xi_{i,j})\)</span> is the triangular kernel, measuring the distance in frequencies. <span class="math inline">\(K_i^h(z^*, z_i)=E(\frac{1}{h}\lVert z^* - z_i\rVert_{\Sigma_{z_i}^{-1}})\)</span> where <span class="math inline">\(\Sigma_{z_i}\)</span> is the covariance matrix of <span class="math inline">\(z_i\)</span> which can be computed from the formulation for latent embedding, and <span class="math inline">\(E\)</span> is a piecewise constant approxination of the Epanechnikov kernel. <span class="math inline">\(K_i^h(z^*, z_i)\)</span> measures the distance between latent embeddings.</p>
<p>Here comes a trade-off at the heart of every heterogeneous reconstruction algorithm: averaging images is necessary to overcome noise, but it also degrades heterogeneity since the images averaged may come from different conformations. Hence, we have to choose <span class="math inline">\(h\)</span> carefully. A cross-validation strategy is applied to find the optimal <span class="math inline">\(h\)</span> for each frequency shell of each subvolume. For a given <span class="math inline">\(z^*\)</span>, the dataset is split into two: from one halfset, the 50 estimates <span class="math inline">\(\hat{x}(h_1), ..., \hat{x}(h_{50})\)</span> with varying <span class="math inline">\(h\)</span> are computed, and from the other subset a single low-bias, high-variance template <span class="math inline">\(\hat{x}_{CV}\)</span> is reconstrcuted by using a small number of images which are closest to <span class="math inline">\(z^*\)</span>. Each of the 50 kernel estimate is then subdivided into small subvolumes by real-space masking, and each subvolume is again decomposed into frequency shells after a Fourier transform. We use the following cross-validation metric for subvolume <span class="math inline">\(v\)</span> and frequency shell <span class="math inline">\(s\)</span>:</p>
<p><span class="math display">\[d_{s,v}(h) = \lVert S_sV^{-1/2}(M_v(\hat{x}_{CV}-\hat{x}(h)))\rVert_2^2\]</span></p>
<p>where <span class="math inline">\(S_s\)</span> is a matrix that extracts shell <span class="math inline">\(s\)</span>; <span class="math inline">\(M_v\)</span> is a matrix extracting subvolume <span class="math inline">\(v\)</span>; and <span class="math inline">\(V\)</span> is a diagonal matrix containing the variance of the template. For each <span class="math inline">\(s\)</span> and <span class="math inline">\(v\)</span>, the minimizer over <span class="math inline">\(h\)</span> of the cross-validarion score is selected, and the final volume is obtained by first recombining frequency shells for each subvolume and then recombining all the subvolumes.</p>
<div class="quarto-figure quarto-figure-center" style="display: block; margin-left: auto; margin-right: auto;">
<figure class="figure">
<p><img src="img/3D_reconstruct.png" class="img-fluid figure-img" style="width:100.0%"></p>
<figcaption>Volumes are reconstructed from the embedding by adaptive kernel regression <span class="citation" data-cites="Gilles2023">(<a href="#ref-Gilles2023" role="doc-biblioref">Gilles and Singer 2024</a>)</span>.</figcaption>
</figure>
</div>
</section>
<section id="estimation-of-state-density" class="level3">
<h3 class="anchored" data-anchor-id="estimation-of-state-density">Estimation of state density</h3>
<p>Since motion is what structure biologists finally want, we have to figure out a method to sample from latent space to form a trajectory representing the motion of the molecule. According to Boltzmann statistics, the density of a particular state is a measure of the free energy of that state, which means a path which maximizes conformational density is equivalent to the path minimizing the free energy. Taking the advantage of linear mapping, we can easily relate embedding density to conformational density. The embedding density estimator is given by:</p>
<p><span class="math display">\[\hat{E}(z) = \frac{1}{n}\sum_{i=1}^nK_G(\hat{z_i}, \Sigma_s;z)\]</span></p>
<p>where <span class="math inline">\(K_G(\mu, \Sigma;z)\)</span> is the probability density function of the multivariant Gaussian with mean <span class="math inline">\(\mu\)</span> and covariance <span class="math inline">\(\Sigma\)</span>, evaluated at <span class="math inline">\(z\)</span>, and <span class="math inline">\(\Sigma_s\)</span> is set using the Silverman rule. The conformational density can be related as following:</p>
<p><span class="math display">\[\overline{E}(z)=\overline{G}(z)*d(z)\]</span></p>
<p>where <span class="math inline">\(\overline{E}(z)\)</span> is the expectation of the embedding density <span class="math inline">\(\hat{E}(z)\)</span>; <span class="math inline">\(\overline{G}(z)\)</span> is the expectation of <span class="math inline">\(\hat{G}(z)=\frac{1}{n}\sum_{i=1}^nK_G(0,\Sigma_{z_i}+\Sigma_s;z)\)</span>, which is named as embedding uncertainty; <span class="math inline">\(d(z)\)</span> is the conformational density corresponding to <span class="math inline">\(z\)</span>; <span class="math inline">\(*\)</span> is the convolution operation.</p>
</section>
<section id="motion-recovery" class="level3">
<h3 class="anchored" data-anchor-id="motion-recovery">Motion recovery</h3>
<p>Given the conformational density estimated from last step, denoted by <span class="math inline">\(\hat{d}(z)\)</span>, start state <span class="math inline">\(z_{st}\)</span> and end state <span class="math inline">\(z_{end}\)</span>, we can find trajectory <span class="math inline">\(Z(t):\mathbb{R}^+\rightarrow\mathbb{R}^d\)</span> in latent space by computing the value function:</p>
<p><span class="math display">\[v(z):=\underset{Z(t)}{\mathrm{inf}}\int_{t=0}^{t=T_a}\hat{d}(Z(t))^{-1}dt\]</span></p>
<p>subject to <span class="math display">\[Z(0)=z, Z(T_a)=z_{end}, \lVert \frac{d}{dt}Z(t)\rVert=1; T_a = min\{t|Z(t)=z_{end}\}\]</span></p>
<p>In simple word, <span class="math inline">\(v(z)\)</span> computes the minimum inverse density we can have to reach <span class="math inline">\(z_{end}\)</span> starting from <span class="math inline">\(z\)</span>. <span class="math inline">\(v(z)\)</span> is the viscosity solution of the Eikonal equation:</p>
<p><span class="math display">\[\hat{d}(z)|\nabla v(z)|=1, \forall z\in B\setminus \{z_{end}\}; v(z_{end})=0\]</span></p>
<p>where <span class="math inline">\(B\)</span> is the domain of interest, and <span class="math inline">\(v(z)\)</span> can be solved by solving this partial differential equation. Once <span class="math inline">\(v(z)\)</span> is solved, the optimal trajectory an be obtained by finding the path orthogonal to the level curve of <span class="math inline">\(v(z)\)</span>, which can be computed numerically using the steepest gradient descent on <span class="math inline">\(v(z)\)</span> starting from <span class="math inline">\(z_{st}\)</span></p>
<div class="quarto-figure quarto-figure-center" style="display: block; margin-left: auto; margin-right: auto;">
<figure class="figure">
<p><img src="img/level_curve.png" class="img-fluid figure-img" style="width:45.0%"></p>
<figcaption>Visulization of the steepest gradient descent on the level curve of v(z)</figcaption>
</figure>
</div>
</section>
</section>
<section id="results" class="level2">
<h2 class="anchored" data-anchor-id="results">Results</h2>
<section id="results-of-public-datasets" class="level3">
<h3 class="anchored" data-anchor-id="results-of-public-datasets">Results of public datasets</h3>
<p>The original paper of RECOVAR presents results on precatalytic spliceosome dataset (EMPIAR-10180), integrin dataset (EMPIAR-10345) and ribosomal subunit dataset (EMPIAR-10076), all of which are public dataset and could be accessed from https://www.ebi.ac.uk/empiar/.</p>
<p>Results on EMPIAR-10180 focuses on comformational heterogeneity. Three local maxima in conformational density were identified, a path between two of which was identified to show arm regions moving down followed by head regions moving up.</p>
<div class="quarto-figure quarto-figure-center" style="display: block; margin-left: auto; margin-right: auto;">
<figure class="figure">
<p><img src="img/EMPIAR-10180.png" class="img-fluid figure-img" style="width:75.0%"></p>
<figcaption>Latent space and volume view of precatalytic spliceosome conformational heterogeneity. Latent view of the path is projected on the plane formed by different combinations of two principal components <span class="citation" data-cites="Gilles2023">(<a href="#ref-Gilles2023" role="doc-biblioref">Gilles and Singer 2024</a>)</span>.</figcaption>
</figure>
</div>
<p>EMPIAR-10345 contains both conformational and compositional heterogeneity. Two local maxima were found, with the smaller one corresponds to a different composition never reported by provious studies. Also a motion of the arm was found along the path.</p>
<div class="quarto-figure quarto-figure-center" style="display: block; margin-left: auto; margin-right: auto;">
<figure class="figure">
<p><img src="img/EMPIAR-10345.png" class="img-fluid figure-img" style="width:45.0%"></p>
<figcaption>RECOVAR finds both comformational and compositional heterogeneity within integrin <span class="citation" data-cites="Gilles2023">(<a href="#ref-Gilles2023" role="doc-biblioref">Gilles and Singer 2024</a>)</span>.</figcaption>
</figure>
</div>
<p>EMPIAR-10076 is used to show the ability of RECOVAR to find stable states. RECOVAR finds two stable states of the 70S ribosomes.</p>
<div class="quarto-figure quarto-figure-center" style="display: block; margin-left: auto; margin-right: auto;">
<figure class="figure">
<p><img src="img/EMPIAR-10076.png" class="img-fluid figure-img" style="width:65.0%"></p>
<figcaption>The volume of two stable states are reconstructed, correspinding to two peaks in densities <span class="citation" data-cites="Gilles2023">(<a href="#ref-Gilles2023" role="doc-biblioref">Gilles and Singer 2024</a>)</span>.</figcaption>
</figure>
</div>
</section>
<section id="results-of-sars-cov2-datasets" class="level3">
<h3 class="anchored" data-anchor-id="results-of-sars-cov2-datasets">Results of SARS-CoV2 datasets</h3>
<p>We also tested RECOVAR on our own dataset which contains 271,448 SARS-CoV2 spike protein particles, extracted using CryoSparc. Some of these particles are binding to human angiotensin-converting enzyme 2 (ACE2), which is an enzyme on human membrane targeted by SARS-CoV2 spike protein. Therefore, this dataset has both compositional and conformational heterogeneity.</p>
<p>After obtaining an ab-initio model from CryoSparc, we ran RECOVAR with a dimension of 4 and a relatively small grid size of 128. K-Means clustering was performed to find 5 cluster centers among the embeddings.</p>
<p>Here we present two volumes reconstructed from center 0 and center 1, showing a very obvious compositional heterogeneity, where ACE2 is clearly present in center 0 and missing in center 1.</p>
<div class="quarto-figure quarto-figure-center" style="display: block; margin-left: auto; margin-right: auto;">
<figure class="figure">
<p><img src="img/composition_spike.png" class="img-fluid figure-img" style="width:65.0%"></p>
<figcaption>Compositional heterogeneity in the spike protein dataset. The spot where ACE2 is present/absent is highlighted by the red circle.</figcaption>
</figure>
</div>
<p>A path between center 0 and 1 was analyzed to study the conformational changes adopted by the spike protein to bind to ACE2. We can see the arm in the RBD region lifts in order to bind to ACE2.</p>
<div class="quarto-figure quarto-figure-center" style="display: block; margin-left: auto; margin-right: auto;">
<figure class="figure">
<p><img src="img/conformation_spike.png" class="img-fluid figure-img" style="width:100.0%"></p>
<figcaption>Conformational changes along the path between center 0 and 1, highlighted by the yellow circle</figcaption>
</figure>
</div>
</section>
</section>
<section id="discussion" class="level2">
<h2 class="anchored" data-anchor-id="discussion">Discussion</h2>
<p>RECOVAR has several advantages over other heteogeneity analysis methods. Besides the high interpretability we mentioned before, RECOVAR is proved to be able to discover compositional heterogeneity, which cannot be solved by some popular deep learning methods like 3DFlex. Moreover, RECOVAR has much less hyper-parameters to tune compared with deep learning models. The main hyper-parameter the user needs to specify is the number of proncipal components to use, which is a trade-off between the amount of heterogeneity to capture and computational cost.</p>
<p>However, one problem RECOVAR and many other heterogeneity analysis algorithms share is that it requires the input of a homogeneous model/poses of images. However the estimation of the consensus model is often biased by heterogeneity, while the heterogeneity analysis assumes the input consensus model is correct(a dead loop!). Nevertheless, we would expect this issue to be solved by an EM-algorithm iteratively constructing consensus model and performing heterogeneity analysis. In future we may also be interested in benchmarking on pose estimation errors, and other parameters such as the number of principal components, grid size, and particle number, which were not be done in the original paper.</p>
<p>The other drawback of RECOVAR is that the density-based path recovery approach is computationally expensive. The cost increases expoenentially with dimension. In practice, our NVIDIA 24GB GPU could deal with at most a dimension of 4, which is usually insufficient to capture enough heteogeneity in cryo-EM datasets with low SNR. We have to look at cheaper ways of finding path without estimating densities. We are also interested in methods to quantify the compositional heterogeneity along the path e.g.&nbsp;the probability of SARS-CoV2 spike proteins binding to ACE2 with certain conformation.</p>
<p>The last but not least, it will be much easier for structure biologists to study the heterogeneity if we could extend the movie of density map to the movie of atomic model. This requires fitting atomic models to density maps. Since here the density maps in the movies are very similar, we don’t want to fit from scratch every time. Instead, a better approach would be fitting an initial model and then locally updating each density map.</p>



</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-Gilles2023" class="csl-entry" role="listitem">
Gilles, Marc Aurèle, and Amit Singer. 2024. <span>“Cryo-EM Heterogeneity Analysis Using Regularized Covariance Estimation and Kernel Regression.”</span> <a href="https://doi.org/10.1101/2023.10.28.564422">https://doi.org/10.1101/2023.10.28.564422</a>.
</div>
<div id="ref-scheres_2012" class="csl-entry" role="listitem">
Scheres, Sjors H. W. 2012. <span>“RELION: Implementation of a Bayesian Approach to Cryo-EM Structure Determination.”</span> <em>Journal of Structural Biology</em> 180 (3): 519–30. https://doi.org/<a href="https://doi.org/10.1016/j.jsb.2012.09.006">https://doi.org/10.1016/j.jsb.2012.09.006</a>.
</div>
<div id="ref-PPR:PPR217218" class="csl-entry" role="listitem">
Taka, Elhan, Sema Yilmaz, Mert Golcuk, Ceren Kilinc, Umut Aktas, Ahmet Yildiz, and Mert Gur. 2020. <span>“Critical Interactions Between the SARS-CoV-2 Spike Glycoprotein and the Human ACE2 Receptor.”</span> <em>bioRxiv</em>. <a href="https://doi.org/10.1101/2020.09.21.305490">https://doi.org/10.1101/2020.09.21.305490</a>.
</div>
<div id="ref-Wang2020" class="csl-entry" role="listitem">
Wang, Mei-Yue, Rong Zhao, Li-Juan Gao, Xue-Fei Gao, De-Ping Wang, and Ji-Min Cao. 2020. <span>“SARS-CoV-2: Structure, Biology, and Structure-Based Therapeutics Development.”</span> <em>Frontiers in Cellular and Infection Microbiology</em> 10. <a href="https://doi.org/10.3389/fcimb.2020.587269">https://doi.org/10.3389/fcimb.2020.587269</a>.
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/bioshape-analysis\.github\.io\/blog\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>