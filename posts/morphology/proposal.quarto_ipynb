{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Exploring cell shape dynamics dependency on the cell migration\"\n",
        "bibliography: references.bib\n",
        "date: \"October 28 2024\" # Format example: August 9 2024\n",
        "author:\n",
        "  - name: \"Pavel Buklemishev\" \n",
        "categories: [Cell Morphology, Cell Migration, Differential Geometry] # [biology, bioinformatics, theory, etc.]\n",
        "format:\n",
        "  html:\n",
        "    code-fold: true\n",
        "execute:\n",
        "  freeze: auto\n",
        "---\n",
        "\n",
        "\n",
        "---\n",
        "\n",
        "# Introduction \n",
        "\n",
        "## Background\n",
        "Cell morphology is an emerging field of biological research that examines the shape, size, and internal structure of cells to describe their state and the processes occurring within them. Today, more and more scientists across the world are investigating visible cellular transformations to predict cellular phenotypes. This research has significant practical implications: understanding specific cellular features characteristic of certain diseases, such as cancer, could lead to new approaches for early detection and classification.\n",
        "\n",
        "In this work, we explore aspects of cell motility by analyzing the changing shapes of migrating cells. As a cell moves through space, it reorganizes its membrane, cytosol, and cytoskeletal structures [@Mogilner_Oster_1996]. According to current understanding, actin polymerization causes protrusions at the leading edge of a cell, forming specific structures known as lamellipodia and filopodia. Elongation of cells in the direction of movement is also reported in some cases. These changes impact the shape of a cell and can be evaluated numerically. We aim to characterize the motion of single cells and align it with shape changes.\n",
        "\n",
        "## Goals\n",
        "\n",
        "Our goal is to characterize observed motion of cells and perform an analysis of their shape dynamics. We aim to explore bounds and correlations between aspects of cellular motility and shape variation.\n",
        "## Tools\n",
        "\n",
        "### Spatial migration description tools\n",
        "\n",
        "To explore cell migration in space, we assume that a cell moves as a point steadily without rotation. We compute displacements of the mass center, velocities, and angles based on the centroid coordinates at different time moments. Based on the results, we attempt to predict the mode of motion and other aspects of migration.\n",
        "### Shape description tools\n",
        "\n",
        "To analyze the difference in the shapes of a cell over time, we employ differential geometry approaches, particularly the Riemann Elastic Metric[@10.1007/978-3-031-38299-4_60], which allows detection of how the cell form stretches and bends:\n",
        "$$ \n",
        "g_c^{a, b}(h, k) = a^2 \\int_{[0,1]} \\langle D_s h, N \\rangle \\langle D_s k, N \\rangle \\, ds \n",
        "+ b^2 \\int_{[0,1]} \\langle D_s h, T \\rangle \\langle D_s k, T \\rangle \\, ds \n",
        "$$\n",
        "\n",
        "We estimate the geodesic distance between two cellular boundary curves to mathematically describe how the cell shape changes over time. To implement this algorithm, we use the Python Geomstats package.\n",
        "\n",
        "Setting $a=1$ and $b = {\\frac{1}{2}}$, we obtain the SRV metric, which is used in this work.\n",
        "\n",
        "## Dataset\n",
        "\n",
        "This dataset contains real cell contours obtained via fluorescent microscopy in Professor Prasad's lab, segmented by Clément Soubrier.\n",
        "\n",
        "- **204 directories**:  \n",
        "  Each directory is named `cell_*`, representing an individual cell.  \n",
        "\n",
        "- **Frames**:  \n",
        "  Subdirectories inside each cell are named `frame_*`, capturing different time points for that cell.  \n",
        "\n",
        "### NumPy Array Objects in Each Frame  \n",
        "- **centroid.npy**: Stores the coordinates of the cell's centroid.  \n",
        "- **outline.npy**: Contains segmented points as Cartesian coordinates.  \n",
        "- **time.npy**: Timestamp of the frame.\n",
        "\n",
        "### Structure  \n",
        "\n",
        "```bash\n",
        "├── cell_i\n",
        "│   ├── frame_j\n",
        "│   │   ├── centroid.npy\n",
        "│   │   ├── outline.npy\n",
        "│   │   └── time.npy\n",
        "│   ├── frame_k\n",
        "│   │   ├── centroid.npy\n",
        "│   │   ├── outline.npy\n",
        "│   │   └── time.npy\n",
        "│   └── ...\n",
        "├── cell_l\n",
        "│   ├── frame_m\n",
        "│   │   ├── centroid.npy\n",
        "│   │   ├── outline.npy\n",
        "│   │   └── time.npy\n",
        "│   └── ...\n",
        "└── ...\n",
        "```\n",
        "\n",
        "## Dataset example: single cell dynamics through the time\n"
      ],
      "id": "4d17d9cd"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "import os\n",
        "\n",
        "fig, ax = plt.subplots(figsize=(10, 10), layout='constrained')\n",
        "\n",
        "N = 15\n",
        "\n",
        "number_of_frames = sum(os.path.isdir(os.path.join(f\"cells/cell_{N}\", entry)) for entry in os.listdir(f\"cells/cell_{N}\"))\n",
        "colors = plt.cm.tab20(np.linspace(0, 1, number_of_frames))\n",
        "for i in range(1,number_of_frames+1):\n",
        "    time = np.load(f'cells/cell_{N}/frame_{i}/time.npy')\n",
        "    border = np.load(f'cells/cell_{N}/frame_{i}/outline.npy')\n",
        "    centroid = np.load(f'cells/cell_{N}/frame_{i}/centroid.npy')\n",
        "\n",
        "    \n",
        "    color = colors[i - 1]\n",
        "\n",
        "    ax.plot(border[:, 0], border[:, 1], label=time, color=color)\n",
        "    ax.scatter(centroid[0], centroid[1], color=color)\n",
        "plt.legend()    \n",
        "\n",
        "plt.savefig(f\"single_cell_{N}.png\", dpi=300, bbox_inches='tight')"
      ],
      "id": "c954d7ba",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "![The cell form in different time moments](img/single_cell_15.png){ width=65% style=\"display: block; margin-left: auto; margin-right: auto;\" }\n",
        "\n",
        "# Main part\n",
        "\n",
        "## Plan \n",
        "\n",
        "Our work is logically divided into two parts: first, we investigate cell spatial migration, and then we focus on shape dynamics.\n",
        "\n",
        "1. Cell Spatial Migration:\n",
        "\n",
        "    We visualize and classify the trajectories of motion for a large set of cells and analyze velocities and directional angle patterns.\n",
        "\n",
        "2. Shape Dynamics:\n",
        "\n",
        "    We compute the Riemann distances over time and investigate characteristic extrema to understand cell shape behavior during migration.\n",
        "\n",
        "## Cell spatial migration \n",
        "\n",
        "To simplify the analysis, the dataset's centroid and time data were initially organized into convenient NumPy array structures:\n"
      ],
      "id": "87e34ffc"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "for cell_i in range(1,204):\n",
        "    number_of_frames = sum(os.path.isdir(os.path.join(f\"cells/cell_{cell_i}\", entry)) for entry in os.listdir(f\"cells/cell_{cell_i}\"))  \n",
        "\n",
        "    iter_distance = np.zeros(number_of_frames)\n",
        "    iter_time = np.zeros(number_of_frames)\n",
        "    iter_centroid = np.array([np.random.rand(2) for _ in range(number_of_frames)])\n",
        "    for i in range(number_of_frames):\n",
        "        iter_time[i] = np.load(f'cells/cell_{cell_i}/frame_{i+1}/time.npy')\n",
        "        iter_centroid[i] = np.load(f'cells/cell_{cell_i}/frame_{i+1}/centroid.npy')\n",
        "    riemann_distances.append(iter_distance)\n",
        "    times.append(iter_time)\n",
        "    centroids.append(iter_centroid)\n",
        "data_path = ########\n",
        "with open(data_path+\"/times.npy\", 'wb') as f:\n",
        "    np.save(f, np.array(times, dtype=object))\n",
        "with open(data_path+\"/centroid.npy\", 'wb') as f:\n",
        "    np.save(f, np.array(centroids, dtype=object))"
      ],
      "id": "33f46057",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Modes of migration \n",
        "\n",
        "Cells can exhibit different modes of motion. In the literature, the mean square displacement (MSD) characteristic is used to distinguish several types of motion [@Modes] [@MSD].\n",
        "\n",
        "\n",
        "Mean squared displacement (MSD): \n",
        "\n",
        "$$msd(t) = <[x(t+t_0) - x(t)]^2 + [y(t+t_0) - y(t)]^2> $$\n",
        "\n",
        "Experimentally, the MSD depends on time in a polynomial way:\n",
        "$$ msd(t)  = C t^{\\alpha}$$\n",
        "\n",
        "The motion types are described by the value of the parameter $\\alpha$ \n",
        "\n",
        "- **$\\alpha = 1$**: Free Difusion.  \n",
        "- **$\\alpha = 2$**: Directed Diffusion.  \n",
        "- **$1 < \\alpha < 2$**: Superdiffusion.\n",
        "- **$\\alpha <1$**: Subdiffusion (anomalous diffusion, confined diffusion).\n",
        "- **$\\alpha \\approx 0$**: Immobility\n",
        "\n",
        "![Diffusion types [@picture]](img/diff_types.png){ width=65% style=\"display: block; margin-left: auto; margin-right: auto;\" }\n",
        "\n",
        "Using the trajectories, we aim to determine the motion type and identify potential transitions between them.\n",
        "\n",
        "### Trajectories  \n",
        "\n",
        "We visualize the trajectories of cells in space by using this code.\n",
        "\n",
        "#### Code\n"
      ],
      "id": "a7f7c822"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def plot_cell_trajectory(n):\n",
        "    centroids = centr[n - 1]  \n",
        "    centroids = np.array(centroids)\n",
        "    x_coords = centroids[:, 0]  \n",
        "    y_coords = centroids[:, 1] \n",
        "\n",
        "    # riemann_data = riemann[n-1] \n",
        "    # riemann_data = np.array(riemann_data)  \n",
        "\n",
        "    time_steps = np.arange(len(x_coords))  \n",
        "\n",
        "    plt.figure(figsize=(10, 8))\n",
        "    plt.scatter(\n",
        "        x_coords[0], y_coords[0],  \n",
        "        c='black',\n",
        "        marker='o',\n",
        "        edgecolor='k',\n",
        "        s=100,\n",
        "        alpha=0.7,\n",
        "        label='Start Point'\n",
        "    )\n",
        "    scatter = plt.scatter(\n",
        "        x_coords[1:], y_coords[1:],  \n",
        "        c=time_steps[1:],  #riemann_data[1:],        \n",
        "        cmap='plasma',             \n",
        "        marker='o',\n",
        "        edgecolor='k',\n",
        "        s=100,\n",
        "        alpha=0.7\n",
        "    )\n",
        "    plt.plot(x_coords, y_coords, linestyle='-', color='gray', alpha=0.5)  # Линия траектории\n",
        "\n",
        "    plt.title(f\"Cell Num {n}\")\n",
        "    plt.xlabel('X Coordinate')\n",
        "    plt.ylabel('Y Coordinate')\n",
        "    plt.grid(True)\n",
        "\n",
        "    cbar = plt.colorbar(scatter)\n",
        "    cbar.set_label('Time Step (t)', rotation=270, labelpad=15)\n",
        "\n",
        "    plt.show()"
      ],
      "id": "a58ac12b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "#### Trajectory example:\n",
        "\n",
        "\n",
        "![The cell №87 trajectory](img/cell_traj_87.png){ width=65% style=\"display: block; margin-left: auto; margin-right: auto;\" }\n",
        "\n",
        "The trajectory for cell №87 shows potential directed motion intervals, but further analysis is required to confirm motion modes.\n",
        "\n",
        "[All the trajectories pdf](files/trajectories.pdf)\n",
        "\n",
        "\n",
        "### Velocity and angle (mostly, data validation)\n",
        "\n",
        "#### Code\n"
      ],
      "id": "c5a1f7b4"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def plot_angle_vel_cell(cell_num):\n",
        "\n",
        "    velocities = []\n",
        "    riemann_distances = []\n",
        "    time_data = []\n",
        "    time_data1 = []\n",
        "    rel_angle = []\n",
        "    \n",
        "    num_frames = len(centr[cell_num-1])  \n",
        "    \n",
        "    for frame in range(1, num_frames):\n",
        "        time_data.append(get_times(cell_num-1, frame))\n",
        "        rel_angle.append(get_velocity_angle_rel(cell_num-1, frame))\n",
        "    for frame in range(1, num_frames):\n",
        "        riemann_distances.append(get_riemann_dist(cell_num-1, frame))\n",
        "        time_data1.append(get_times(cell_num-1, frame))\n",
        "        velocities.append(get_abs_velocity(cell_num-1, frame))\n",
        "    \n",
        "    fig, ax = plt.subplots(figsize=(10, 6))\n",
        "    \n",
        "    ax.plot(time_data1, velocities, label=\"Velocity\", color=\"green\", linewidth=1.5)\n",
        "    ax.set_xlabel(\"Time\", fontsize=10)\n",
        "    ax.set_ylabel(\"Velocity\", fontsize=10)\n",
        "    ax.tick_params(axis=\"both\", which=\"major\", labelsize=8)\n",
        "    ax.legend(loc=\"upper left\", fontsize=8)\n",
        "\n",
        "    ax_angle = ax.twinx()\n",
        "    ax_angle.plot(time_data, rel_angle, label=\"Angle\", color=\"red\", linewidth=1.5)\n",
        "    ax_angle.set_ylabel(\"Angle (degrees)\", fontsize=10, color=\"red\")\n",
        "    ax_angle.tick_params(axis=\"y\", labelsize=8, colors=\"red\")\n",
        "    ax_angle.legend(loc=\"upper right\", fontsize=8)\n",
        "    \n",
        "    ax.set_title(f\"Cell {cell_num}\", fontsize=12)\n",
        "    \n",
        "    plt.tight_layout()\n",
        "    plt.show()"
      ],
      "id": "ef9f596e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "#### Velocity/Angle visualization example:\n",
        "\n",
        "![The cell №87 velocity and angle visualization](img/angle_cell_87.png){ width=65% style=\"display: block; margin-left: auto; margin-right: auto;\" }\n",
        "\n",
        "The graph reveals segments with nearly constant velocity, possibly indicating directed motion. However, the angle graph is noisy and inconclusive.\n",
        "\n",
        "[All the velocities and angles pdf](files/angle_vel.pdf)\n",
        "\n",
        "#### Further steps:  DC-MSS\n",
        "\n",
        "Since, all the previous approaches didn't give the complete result, we need to find another way. In the article [@VEGA20181018] the segment classification framework (divide-and-conquer moment scaling spectrum(**DC-MSS**)) is presented. After converting data to the framework format we can get the segmentized classified trajectory picture.\n",
        "\n",
        "#### Data preparation\n",
        "Before running the DC-MSS framework, we prepare the trajectory data:\n"
      ],
      "id": "6f5c73d8"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "from scipy.io import savemat\n",
        "                                                                            \n",
        "tracks = {}\n",
        "for i, trajectory in enumerate(data):\n",
        "    n_frames = trajectory.shape[0]\n",
        "    row = np.zeros(n_frames * 8)  \n",
        "    for j, (x, y) in enumerate(trajectory):\n",
        "        start_idx = j * 8  \n",
        "        row[start_idx] = x \n",
        "        row[start_idx + 1] = y  \n",
        "\n",
        "    tracks[f\"track_{i+1}\"] = row  \n",
        "\n",
        "output_path = \"trajectory_data.mat\"\n",
        "savemat(output_path, {'tracks': tracks})"
      ],
      "id": "09bf2f53",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "This converts trajectory data into a .mat file, compatible with MATLAB.\n",
        "\n",
        "#### Running the DC-MSS Framework in MATLAB\n",
        "\n",
        "The following MATLAB code processes the prepared data:\n",
        "\n",
        "```matlab\n",
        "loaded = load(\"../trajectory_data.mat\");\n",
        "allTracks = loaded.tracks;\n",
        "\n",
        "probDim = 2;       \n",
        "plotRes = 0;       \n",
        "peakAlpha = 90;  \n",
        "\n",
        "results = struct();\n",
        "\n",
        "trackNames = fieldnames(allTracks);\n",
        "for i = 1:length(trackNames)\n",
        "    trackName = trackNames{i};\n",
        "    tracks = allTracks.(trackName);\n",
        "\n",
        "    [transDiffResults, errFlag] = basicTransientDiffusionAnalysisv1(tracks, probDim, plotRes, peakAlpha);\n",
        "    \n",
        "    if isfield(transDiffResults.segmentClass, 'momentScalingSpectrum')\n",
        "        results.(trackName).momentScalingSpectrum = transDiffResults.segmentClass.momentScalingSpectrum;\n",
        "    end\n",
        "end\n",
        "\n",
        "h5FileName = 'time_events.h5';\n",
        "if exist(h5FileName, 'file') == 2\n",
        "    delete(h5FileName); \n",
        "end\n",
        "\n",
        "trackNames = fieldnames(results);\n",
        "for i = 1:length(trackNames)\n",
        "    trackName = trackNames{i};\n",
        "    data = results.(trackName).momentScalingSpectrum;\n",
        "    if ~isempty(data)\n",
        "        h5create(h5FileName, ['/', trackName], size(data));\n",
        "        h5write(h5FileName, ['/', trackName], data);\n",
        "    end\n",
        "end\n",
        "```\n",
        "\n",
        "![Classified track. Cyan corresponds to the free diffusion, Magenta - directed motion](img/segmented_track.png){ width=65% style=\"display: block; margin-left: auto; margin-right: auto;\" }\n",
        "\n",
        "The classified trajectory segments provide clearer insights into motion types. Cyan indicates free diffusion, while magenta highlights directed motion.\n",
        "\n",
        "## Shape analysis\n",
        "\n",
        "To analyze shape dynamics, we compute Riemann distances between consecutive, aligned cell shapes. This accounts for transformations like translation, scaling, and reparametrization while penalizing rotation.\n",
        "\n",
        "### Alignment\n",
        "\n",
        "The alignment function ensures proper alignment of cell shapes:\n"
      ],
      "id": "784ed997"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def align(point, base_point, rescale, rotation, reparameterization, k_sampling_points): #rotation set as False\n",
        "    \"\"\"\n",
        "    Align point and base_point via quotienting out translation, rescaling, rotation and reparameterization\n",
        "    \"\"\"\n",
        "\n",
        "    total_space = DiscreteCurvesStartingAtOrigin(k_sampling_points=k_sampling_points)\n",
        "   \n",
        "    \n",
        "    # Quotient out translation \n",
        "    point = total_space.projection(point) \n",
        "    point = point - gs.mean(point, axis=0)\n",
        "\n",
        "    base_point = total_space.projection(base_point)\n",
        "    base_point = base_point - gs.mean(base_point, axis=0)\n",
        "\n",
        "    # Quotient out rescaling\n",
        "    if rescale:\n",
        "        point = total_space.normalize(point) \n",
        "        base_point = total_space.normalize(base_point)\n",
        "    \n",
        "    # Quotient out rotation\n",
        "    if rotation:\n",
        "        point = rotation_align(point, base_point, k_sampling_points)\n",
        "\n",
        "    # Quotient out reparameterization\n",
        "    if reparameterization:\n",
        "        aligner = DynamicProgrammingAligner(total_space)\n",
        "        total_space.fiber_bundle = ReparametrizationBundle(total_space, aligner=aligner)\n",
        "        point = total_space.fiber_bundle.align(point, base_point)\n",
        "    return point"
      ],
      "id": "14d5a247",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Distance Computation\n",
        "\n",
        "Riemann distances are computed between aligned shapes:\n"
      ],
      "id": "a2272f41"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "riemann_distances = []\n",
        "a = 1\n",
        "b = 1/2\n",
        "\n",
        "CURVES_SPACE_ELASTIC = DiscreteCurvesStartingAtOrigin(\n",
        "    ambient_dim=2, k_sampling_points=1000, equip=False\n",
        ")\n",
        "CURVES_SPACE_ELASTIC.equip_with_metric(ElasticMetric, a=a, b=b)\n",
        "\n",
        "def calculate_distance(border,reference_shape):\n",
        "\n",
        "    return CURVES_SPACE_ELASTIC.metric.dist(CURVES_SPACE_ELASTIC.projection(border), CURVES_SPACE_ELASTIC.projection(reference_shape))\n",
        "\n",
        "\n",
        "for cell_i in range(1, 205):\n",
        "    number_of_frames = sum(os.path.isdir(os.path.join(f\"cells/cell_{cell_i}\", entry)) for entry in os.listdir(f\"cells/cell_{cell_i}\"))  \n",
        "\n",
        "    iter_distance = np.zeros(number_of_frames)\n",
        "\n",
        "    BASE_LINE = np.load(f'cells/cell_{cell_i}/frame_1/outline.npy')\n",
        "    BASE_LINE= interpolate(BASE_LINE,1000)\n",
        "    BASE_LINE = preprocess(BASE_LINE)\n",
        "    BASE_LINE= project_on_kendall_space(BASE_LINE)\n",
        "    for i in range(number_of_frames):\n",
        "        border_cell = np.load(f'cells/cell_{cell_i}/frame_{i+1}/outline.npy')\n",
        "        cell_interpolation= interpolate(border_cell,1000)\n",
        "        cell_preprocess = preprocess(cell_interpolation)\n",
        "        border_cell = cell_preprocess\n",
        "        border_cell = project_on_kendall_space(cell_interpolation)\n",
        "        aligned_border = align(border_cell, BASE_LINE, rescale=True, rotation=False, reparameterization=True, k_sampling_points=1000)\n",
        "        iter_distance[i] = calculate_distance(aligned_border, BASE_LINE)\n",
        "        BASE_LINE = aligned_border \n",
        "\n",
        "    riemann_distances.append(iter_distance)\n",
        "### Dividing by delta t in the results."
      ],
      "id": "db29d0e1",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Plotting function\n"
      ],
      "id": "230396c4"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def plot_riemann_cell(plot_index):\n",
        "    riemann_distances = []\n",
        "    time_data = []\n",
        "    \n",
        "    num_frames = len(centr[plot_index-1])\n",
        "    \n",
        "    for frame in range(1, num_frames):\n",
        "\n",
        "        dist_value = get_riemann_dist(plot_index-1, frame) / (get_times(plot_index-1, frame) - get_times(plot_index-1, frame - 1))\n",
        "        riemann_distances.append(dist_value)\n",
        "        time_data.append(get_times(plot_index-1, frame))\n",
        "\n",
        "    plt.figure(figsize=(8,6))\n",
        "    plt.plot(time_data, riemann_distances, marker='o', linestyle='-')\n",
        "    plt.xlabel(\"Time\")\n",
        "    plt.ylabel(\"Riemann Velocities\")\n",
        "    plt.title(f\"Cell {plot_index}\")\n",
        "    plt.grid(True)\n",
        "    plt.show()"
      ],
      "id": "6f3e4411",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "![Riemann Velocities graph for cell №87](img/r.png){ width=65% style=\"display: block; margin-left: auto; margin-right: auto;\" }\n",
        "\n",
        "[All the Riemann Velocities pdf](files/riemann_times.pdf)\n",
        "\n",
        "\n",
        "## Combining the results: analysing Riemann velocities in the context of determined events\n",
        "\n",
        "Separately, investigation of cell trasjectories and cell shape variations didn't give any promising results. However, we believe that if we analyze classified trajectories and Riemann velocities together, some attractive evidence could be found. \n",
        "\n",
        "Extracting the event time moments from the DC-MSS framework and plotting them on the Riemann Velocities graph, we expect to see that characteristical peaks are related to the motion mode change."
      ],
      "id": "2c8da999"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| code-fold: true\n",
        "def riemann_times_with_events(cell_num):\n",
        "    cell_index = cell_num - 1\n",
        "    riemann_distances = []\n",
        "    time_data = []\n",
        "\n",
        "\n",
        "    num_frames = len(centr[cell_index])\n",
        "    for frame in range(1, num_frames):\n",
        "        dt = get_times(cell_index, frame) - get_times(cell_index, frame - 1)\n",
        "        riemann_distances.append(get_riemann_dist(cell_index, frame) / dt)\n",
        "        time_data.append(get_times(cell_index, frame))\n",
        "\n",
        "    with h5py.File('time_events.h5', 'r') as f:\n",
        "        track_i_data = f[f'/track_{cell_index + 1}'][:]\n",
        "        first_two_rows = track_i_data[:2]\n",
        "        time_points = np.intersect1d(first_two_rows[0, :], first_two_rows[1, :])\n",
        "        print(f\"Cell #{cell_index + 1} Data: {first_two_rows}\")\n",
        "        print(f\"Cell #{cell_index + 1} Time Points: {time_points}\")\n",
        "\n",
        "    plt.figure(figsize=(8, 6))\n",
        "    plt.plot(time_data, riemann_distances, label='Riemann velocity', color='blue')\n",
        "    plt.xlabel(\"Time\")\n",
        "    plt.ylabel(\"Riemann Velocity\")\n",
        "    plt.title(f\"Cell {cell_index + 1}\", fontsize=12)\n",
        "    plt.grid(True)\n",
        "\n",
        "    for tp in time_points:\n",
        "        if tp - 1 < len(time_data):  \n",
        "            x = time_data[int(tp) - 1]\n",
        "            y = riemann_distances[int(tp) - 1]\n",
        "            plt.scatter(x, y, color=\"red\", label=\"Event time\" if tp == time_points[0] else \"\")\n",
        "\n",
        "    plt.legend()\n",
        "    plt.tight_layout()\n",
        "    plt.show()"
      ],
      "id": "6318ba3c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "<div style=\"display: flex; justify-content: space-around; align-items: center;\">\n",
        "  <figure style=\"text-align: center;\">\n",
        "    <img src=\"img/cell87_90.png\" alt=\"Confidence level 0.90\" style=\"width: 100%;\"/>\n",
        "    <figcaption>Confidence level 0.90</figcaption>\n",
        "  </figure>\n",
        "  <figure style=\"text-align: center;\">\n",
        "    <img src=\"img/cell87_95.png\" alt=\"Confidence level 0.95\" style=\"width: 100%;\"/>\n",
        "    <figcaption>Confidence level 0.95</figcaption>\n",
        "  </figure>\n",
        "</div>\n",
        "\n",
        "\n",
        "[Riemann velocities and events (0.9 confidence level)](files/riemann_with_events_90.pdf)\n",
        "\n",
        "[Riemann velocities and events (0.95 confidence level)](files/riemann_with_events_95.pdf)\n",
        "\n",
        "## Riemann velocities with Classified Segments  \n"
      ],
      "id": "bd4f8626"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def riemann_single_cell_classification(cell_number):\n",
        "    cell_index = cell_number - 1  \n",
        "\n",
        "\n",
        "    riemann_distances = []\n",
        "    time_data = []\n",
        "    type_data = defaultdict(list)  \n",
        "\n",
        "    with h5py.File('time_events_90.h5', 'r') as f:\n",
        "        track_i_data = f[f'/track_{cell_index+1}'][:]\n",
        "        first_three_rows = track_i_data[:3]\n",
        "        event_indices = first_three_rows[0, :].astype(int) - 1  \n",
        "        interval_types = first_three_rows[2, :]  # \n",
        "\n",
        " \n",
        "    time_data = [times[cell_index][idx] for idx in range(1, len(times[cell_index]))]  \n",
        "    riemann_distances = [\n",
        "        get_riemann_dist(cell_index, idx) / (get_times(cell_index, idx) - get_times(cell_index, idx - 1))\n",
        "        for idx in range(1, len(times[cell_index]))\n",
        "    ]\n",
        "\n",
        "    interval_colors = {\n",
        "        0: \"brown\",      \n",
        "        1: \"blue\",       \n",
        "        2: \"cyan\",       \n",
        "        3: \"magenta\",    \n",
        "        \"unclassified\": \"black\"  \n",
        "    }\n",
        "\n",
        "\n",
        "    fig, ax = plt.subplots(figsize=(8, 6))\n",
        "\n",
        "    for start_idx, interval_type in enumerate(interval_types):\n",
        "        start = event_indices[start_idx]\n",
        "        end = event_indices[start_idx + 1] if start_idx + 1 < len(event_indices) else len(time_data) - 1\n",
        "\n",
        "        if start < len(time_data) and end < len(time_data):\n",
        "            time_segment = time_data[start:end + 1]  \n",
        "            segment = riemann_distances[start:end + 1]\n",
        "\n",
        "            interval_type = int(interval_type) if not np.isnan(interval_type) else \"unclassified\"\n",
        "            color = interval_colors.get(interval_type, \"black\")\n",
        "\n",
        "            type_data[interval_type].extend(segment)\n",
        "\n",
        "            ax.plot(time_segment, segment, color=color)\n",
        "\n",
        "    from matplotlib.lines import Line2D\n",
        "    legend_elements = [\n",
        "        Line2D([0], [0], color=\"brown\", lw=2, label=\"Immobile\"),\n",
        "        Line2D([0], [0], color=\"blue\", lw=2, label=\"Confined Diffusion\"),\n",
        "        Line2D([0], [0], color=\"cyan\", lw=2, label=\"Free Diffusion\"),\n",
        "        Line2D([0], [0], color=\"magenta\", lw=2, label=\"Directed Diffusion\"),\n",
        "        Line2D([0], [0], color=\"black\", lw=2, label=\"Unclassified\")\n",
        "    ]\n",
        "    ax.legend(handles=legend_elements, loc=\"upper right\", fontsize=8)\n",
        "\n",
        "    ax.set_xlabel(\"Time\")\n",
        "    ax.set_ylabel(\"Riemann velocity\")\n",
        "    ax.set_title(f\"Cell {cell_number}\", fontsize=10)\n",
        "    ax.tick_params(axis='both', which='major', labelsize=8)\n",
        "\n",
        "    plt.tight_layout()\n",
        "    plt.savefig(f\"riemann_single_cell_{cell_number}_classification_90.png\")\n",
        "    plt.show()"
      ],
      "id": "f6847518",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: {.columns}\n",
        "::: {.column width=\"50%\"}\n",
        "![](img/riemann_single_cell_87_classification_90.png){fig-align=\"center\" width=\"100%\"}\n",
        "<p style=\"text-align: center; font-size: 0.9em;\">Confidence level 0.90.</p>\n",
        ":::\n",
        "::: {.column width=\"50%\"}\n",
        "![](img/riemann_single_cell_87_classification_95.png){fig-align=\"center\" width=\"100%\"}\n",
        "<p style=\"text-align: center; font-size: 0.9em;\">Confidence level 0.95.</p>\n",
        ":::\n",
        ":::\n",
        "\n",
        "[Riemann velocities and classified segments  (0.9 confidence level)](files/riemann_with_classification_90.pdf)\n",
        "\n",
        "[Riemann velocities and classified segments (0.95 confidence level)](files/riemann_with_classification_95.pdf)\n",
        "\n",
        "We can visualize the spatial behaviour of a cell via the motion types as well. \n"
      ],
      "id": "0dc048ff"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def plot_cell_by_motion_type(n):\n",
        "\n",
        "    cell_dir = 'cells'\n",
        "    cell_path = os.path.join(\n",
        "        cell_dir, \n",
        "        sorted(os.listdir(cell_dir), key=lambda x: int(x.split('_')[1]) if '_' in x and x.split('_')[1].isdigit() else 0)[n-1]\n",
        "    )\n",
        "\n",
        "    cell = sorted(\n",
        "        os.listdir(cell_path), \n",
        "        key=lambda x: int(''.join(filter(str.isdigit, x))) \n",
        "    )\n",
        "    \n",
        "    fig = plt.figure()\n",
        "    ax = fig.add_subplot(111, projection='3d')\n",
        "\n",
        "    interval_colors = {\n",
        "        0: \"brown\", \n",
        "        1: \"blue\",       \n",
        "        2: \"cyan\",       \n",
        "        3: \"magenta\",  \n",
        "        \"unclassified\": \"black\"  \n",
        "    }\n",
        "    import h5py\n",
        "\n",
        "    with h5py.File('time_events_90.h5', 'r') as f:\n",
        "        track_i_data = f[f'/track_{n}'][:]\n",
        "        first_three_rows = track_i_data[:3]\n",
        "        event_indices = first_three_rows[0, :].astype(int) - 1\n",
        "        interval_types = first_three_rows[2, :]  \n",
        "\n",
        "    for i, frame in enumerate(cell):\n",
        "        frame_path = os.path.join(cell_path, frame)\n",
        "        time = np.load(os.path.join(frame_path, 'time.npy'))\n",
        "        outline = np.load(os.path.join(frame_path, 'outline.npy'))\n",
        "\n",
        "        current_type = None\n",
        "        for start_idx, interval_type in enumerate(interval_types):\n",
        "            if i >= event_indices[start_idx] and (start_idx + 1 == len(event_indices) or i < event_indices[start_idx + 1]):\n",
        "                current_type = interval_type\n",
        "                break\n",
        "\n",
        "        if current_type is not None:\n",
        "            interval_type = int(current_type) if not np.isnan(current_type) else \"unclassified\"\n",
        "            color = interval_colors.get(interval_type, \"black\")\n",
        "\n",
        "        ax.plot3D(\n",
        "            outline[:, 0], \n",
        "            outline[:, 1], \n",
        "            np.full(len(outline[:, 1]), time),\n",
        "            color=color, \n",
        "            linewidth=1\n",
        "        )\n",
        "        print(f\"Frame {frame}: Time = {time}, Motion Type = {current_type}\")\n",
        "\n",
        "    from matplotlib.lines import Line2D\n",
        "    legend_elements = [\n",
        "        Line2D([0], [0], color=\"brown\", lw=2, label=\"Immobile\"),\n",
        "        Line2D([0], [0], color=\"blue\", lw=2, label=\"Confined Diffusion\"),\n",
        "        Line2D([0], [0], color=\"cyan\", lw=2, label=\"Free Diffusion\"),\n",
        "        Line2D([0], [0], color=\"magenta\", lw=2, label=\"Directed Diffusion\"),\n",
        "        Line2D([0], [0], color=\"black\", lw=2, label=\"Unclassified\")\n",
        "    ]\n",
        "    ax.legend(handles=legend_elements, loc=\"upper right\", fontsize=8)\n",
        "\n",
        "    ax.set_xlabel('X Coordinate')\n",
        "    ax.set_ylabel('Y Coordinate')\n",
        "    ax.set_zlabel('Time')\n",
        "    ax.set_title(f\"Cell {n}\")\n",
        "    plt.show()"
      ],
      "id": "166f6673",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Parameter statistical research for 0.9 confidence level of trajectory classification.\n",
        "\n",
        "::: {.columns}\n",
        "::: {.column width=\"33%\"}\n",
        "![](img/mean_riemann_distances_09.png){fig-align=\"center\" width=\"100%\"}\n",
        ":::\n",
        "::: {.column width=\"33%\"}\n",
        "![](img/mean_velocity_09.png){fig-align=\"center\" width=\"100%\"}\n",
        ":::\n",
        "::: {.column width=\"33%\"}\n",
        "![](img/mean_angle_09.png){fig-align=\"center\" width=\"100%\"}\n",
        ":::\n",
        ":::\n",
        "\n",
        "# Parameter statistical research for 0.95 confidence level of trajectory classification.\n",
        "\n",
        "::: {.columns}\n",
        "::: {.column width=\"33%\"}\n",
        "![](img/mean_riemann_distances_095.png){fig-align=\"center\" width=\"100%\"}\n",
        ":::\n",
        "::: {.column width=\"33%\"}\n",
        "![](img/mean_velocity_095.png){fig-align=\"center\" width=\"100%\"}\n",
        ":::\n",
        "::: {.column width=\"33%\"}\n",
        "![](img/mean_angle_095.png){fig-align=\"center\" width=\"100%\"}\n",
        ":::\n",
        ":::\n",
        "\n",
        "\n",
        "# Conclusion\n",
        "\n",
        "In this work, we analyzed cell movement and shape dynamics parameters, characterizing migration based on these factors. We investigated absolute velocity, directional angle motion, and the behavior of cell trajectories over time. The cell migration modes were distinguished using a segmentation classification framework, which identified transitions between motility regimes.\n",
        "\n",
        "While we observed that Riemann velocities aligned with some motion switch events, we found no global correlation that could consistently link Riemann velocity behavior to these transitions. We hypothesize that this lack of correlation might be related to errors in cell segmentation. Therefore, we propose repeating the experiment after resegmenting the dataset to improve accuracy.\n",
        "\n",
        "In future work, it would be valuable to combine the Riemann velocity analysis with promising methods such as (quasi-)conformal mapping, which can effectively detect cellular protrusions.\n",
        "\n",
        "\n",
        "\n",
        "## References\n",
        "\n",
        "::: {#refs}\n",
        ":::"
      ],
      "id": "6d1ad957"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/root/miniconda3/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}