<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Wanxin Li">
<meta name="dcterms.date" content="2024-08-29">

<title>Orthogonal outlier detection and dimension estimation for improved MDS embedding of biological datasets – bioshape-analysis</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-5027bf1c1f92ac6615724d89c8213d6a.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">bioshape-analysis</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Orthogonal outlier detection and dimension estimation for improved MDS embedding of biological datasets</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">biology</div>
                <div class="quarto-category">bioinformatics</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Wanxin Li </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">August 29, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#background" id="toc-background" class="nav-link" data-scroll-target="#background">Background</a>
  <ul class="collapse">
  <li><a href="#multidimensional-scaling-mds" id="toc-multidimensional-scaling-mds" class="nav-link" data-scroll-target="#multidimensional-scaling-mds">Multidimensional scaling (MDS)</a></li>
  <li><a href="#orthogonal-outliers" id="toc-orthogonal-outliers" class="nav-link" data-scroll-target="#orthogonal-outliers">Orthogonal outliers</a></li>
  <li><a href="#height-and-volume-of-n-simplices" id="toc-height-and-volume-of-n-simplices" class="nav-link" data-scroll-target="#height-and-volume-of-n-simplices">Height and Volume of n-simplices</a></li>
  </ul></li>
  <li><a href="#methods" id="toc-methods" class="nav-link" data-scroll-target="#methods">Methods</a>
  <ul class="collapse">
  <li><a href="#sec-part1" id="toc-sec-part1" class="nav-link" data-scroll-target="#sec-part1">Orthogonal outlier detection and dimensionality estimation</a></li>
  <li><a href="#correcting-the-dimensionality-estimation-for-a-large-outlier-fraction" id="toc-correcting-the-dimensionality-estimation-for-a-large-outlier-fraction" class="nav-link" data-scroll-target="#correcting-the-dimensionality-estimation-for-a-large-outlier-fraction">Correcting the dimensionality estimation for a large outlier fraction</a></li>
  <li><a href="#outlier-distance-correction" id="toc-outlier-distance-correction" class="nav-link" data-scroll-target="#outlier-distance-correction">Outlier distance correction</a></li>
  </ul></li>
  <li><a href="#sec-dataset" id="toc-sec-dataset" class="nav-link" data-scroll-target="#sec-dataset">Dataset</a></li>
  <li><a href="#results" id="toc-results" class="nav-link" data-scroll-target="#results">Results</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>Multidimensional scaling (MDS) is known to be sensitive to such orthogonal outliers, we present here a robust MDS method, called <em>DeCOr-MDS</em>, short for <strong>De</strong>tection and <strong>C</strong>orrection of <strong>Or</strong>thogonal outliers using <strong><em>MDS</em></strong>. DeCOr-MDS takes advantage of geometrical characteristics of the data to reduce the influence of orthogonal outliers, and estimate the dimension of the dataset. The full paper is available at <span class="citation" data-cites="li2023orthogonal">Li et al. (<a href="#ref-li2023orthogonal" role="doc-biblioref">2023</a>)</span>.</p>
</section>
<section id="background" class="level1">
<h1>Background</h1>
<section id="multidimensional-scaling-mds" class="level2">
<h2 class="anchored" data-anchor-id="multidimensional-scaling-mds">Multidimensional scaling (MDS)</h2>
<p>MDS is a statistical technique used for visualizing data points in a low-dimensional space, typically two or three dimensions. It is particularly useful when the data is represented in the form of a distance matrix, where each entry indicates the distance between pairs of items. MDS aims to place each item in this lower-dimensional space in such a way that the distances between the items are preserved as faithfully as possible. This allows complex, high-dimensional data to be more easily interpreted, as the visual representation can reveal patterns, clusters, or relationships among the data points that might not be immediately apparent in the original high-dimensional space. MDS is widely used in fields such as psychology, market research, and bioinformatics for tasks like visualizing similarities among stimuli, products, or genetic sequences <span class="citation" data-cites="carroll1998multidimensional hout2013multidimensional">(<a href="#ref-carroll1998multidimensional" role="doc-biblioref">Carroll and Arabie 1998</a>; <a href="#ref-hout2013multidimensional" role="doc-biblioref">Hout, Papesh, and Goldinger 2013</a>)</span>.</p>
</section>
<section id="orthogonal-outliers" class="level2">
<h2 class="anchored" data-anchor-id="orthogonal-outliers">Orthogonal outliers</h2>
<p>Outlier detection has been widely used in biological data. Sheih and Yeung proposed a method using principal component analysis (PCA) and robust estimation of Mahalanobis distances to detect outlier samples in microarray data <span class="citation" data-cites="shieh2009detecting">(<a href="#ref-shieh2009detecting" role="doc-biblioref">Shieh and Hung 2009</a>)</span>. Chen <em>et al.</em> reported the use of two PCA methods to uncover outlier samples in multiple simulated and real RNA-seq data <span class="citation" data-cites="oh2008biological">(<a href="#ref-oh2008biological" role="doc-biblioref">Oh, Gao, and Rosenblatt 2008</a>)</span>. Outlier influence can be mitigated depending on the specific type of outlier. In-plane outliers and bad leverage points can be harnessed using <span class="math inline">\(\ell_1\)</span>-norm <span class="citation" data-cites="SpenceLewandowsky1989 CaytonDasgupta2006">Forero and Giannakis (<a href="#ref-ForeroGiannakis2012" role="doc-biblioref">2012</a>)</span>, correntropy or M-estimators <span class="citation" data-cites="MandanasKotropoulos2017">(<a href="#ref-MandanasKotropoulos2017" role="doc-biblioref">Mandanas and Kotropoulos 2017</a>)</span>. Outliers which violate the triangular inequality can be detected and corrected based on their pairwise distances <span class="citation" data-cites="BlouvshteinCohenOr2019">(<a href="#ref-BlouvshteinCohenOr2019" role="doc-biblioref">Blouvshtein and Cohen-Or 2019</a>)</span>. Orthogonal outliers are another particular case, where outliers have an important component, orthogonal to the hyperspace where most data is located. These outliers often do not violate the triangular inequality, and thus require an alternative approach.</p>
</section>
<section id="height-and-volume-of-n-simplices" class="level2">
<h2 class="anchored" data-anchor-id="height-and-volume-of-n-simplices">Height and Volume of n-simplices</h2>
<p>We recall some geometric properties of simplices, which our method is based on. For a set of <span class="math inline">\(n\)</span> points <span class="math inline">\((x_1,\ldots, x_n)\)</span>, the associated <span class="math inline">\(n\)</span>-simplex is the polytope of vertices <span class="math inline">\((x_1,\ldots, x_n)\)</span> (a 3-simplex is a triangle, a 4-simplex is a tetrahedron and so on). The height <span class="math inline">\(h(V_{n},x)\)</span> of a point <span class="math inline">\(x\)</span> belonging to a <span class="math inline">\(n\)</span>-simplex <span class="math inline">\(V_{n}\)</span> can be obtained as <span class="citation" data-cites="sommerville1929">(<a href="#ref-sommerville1929" role="doc-biblioref">Sommerville 1929</a>)</span>, <span id="eq-height"><span class="math display">\[
  h(V_{n},x) = n \frac{V_n}{V_{n-1}},
\tag{1}\]</span></span> where <span class="math inline">\(V_{n}\)</span> is the volume of the <span class="math inline">\(n\)</span>-simplex, and <span class="math inline">\(V_{n-1}\)</span> is the volume of the <span class="math inline">\((n-1)\)</span>-simplex obtained by removing the point <span class="math inline">\(x\)</span>. <span class="math inline">\(V_{n}\)</span> and <span class="math inline">\(V_{n-1}\)</span> can be computed using the pairwise distances only, with the Cayley-Menger formula <span class="citation" data-cites="sommerville1929">(<a href="#ref-sommerville1929" role="doc-biblioref">Sommerville 1929</a>)</span>:</p>
<p><span class="math display">\[\begin{equation}
\label{eq:Vn}
V_n = \sqrt{\frac{\vert det(CM_n)\vert}{2^n \cdot (n!)^2}},
\end{equation}\]</span></p>
<p>where <span class="math inline">\(det(CM_n)\)</span> is the determinant of the Cayley-Menger matrix <span class="math inline">\(CM_n\)</span>, that contains the pairwise distances <span class="math inline">\(d_{i,j}=\left\lVert x_i -x_j \right\rVert\)</span>, as <span class="math display">\[\begin{equation}
  CM_n = \left[ \begin{array}{cccccc} 0 &amp; 1 &amp; 1 &amp; ... &amp; 1 &amp; 1 \\

  1 &amp; 0 &amp; d_{1,2}^2 &amp; ... &amp; d_{1,n}^2 &amp; d_{1,n+1}^2 \\
  1 &amp; d_{2,1}^2 &amp; 0 &amp; ... &amp; d_{2,n}^2 &amp; d_{2,n+1}^2 \\
  ... &amp; ... &amp; ... &amp; ... &amp; ... &amp; ... \\
  1 &amp; d_{n,1}^2 &amp; d_{n,2}^2 &amp; ... &amp; 0 &amp; d_{n,n+1}^2 \\
  1 &amp; d_{n+1,1}^2 &amp; d_{n+1,2}^2 &amp; ... &amp; d_{n+1,n}^2 &amp; 0 \\
  \end{array}\right].
\end{equation}\]</span></p>
</section>
</section>
<section id="methods" class="level1">
<h1>Methods</h1>
<section id="sec-part1" class="level2">
<h2 class="anchored" data-anchor-id="sec-part1">Orthogonal outlier detection and dimensionality estimation</h2>
<p>We now consider a dataset <span class="math inline">\(\mathbf{X}\)</span> of size <span class="math inline">\(N\times d\)</span>, where <span class="math inline">\(N\)</span> is the sample size and <span class="math inline">\(d\)</span> the dimension of the data. We associate with <span class="math inline">\(\mathbf{X}\)</span> a matrix <span class="math inline">\(\mathbf{D}\)</span> of size <span class="math inline">\(N\times N\)</span>, which represents all the pairwise distances between observations of <span class="math inline">\(\mathbf{X}\)</span>. We also assume that the data points can be mapped into a vector space with regular observations that form a main subspace of unknown dimension <span class="math inline">\(d^*\)</span> with some small noise, and additional orthogonal outliers of relatively large orthogonal distance to the main subspace (see <a href="#fig-scheme-outliers" class="quarto-xref">Figure&nbsp;1</a>.A). Our proposed method aims to infer from <span class="math inline">\(\mathbf{D}\)</span> the dimension of the main data subspace <span class="math inline">\(d^*\)</span>, using the geometric properties of simplices with respect to their number of vertices: Consider a <span class="math inline">\((n+2)\)</span>-simplex containing a data point <span class="math inline">\(x_i\)</span> and its associated height, that can be computed using equation <a href="#eq-height" class="quarto-xref">Equation&nbsp;1</a>. When <span class="math inline">\(n&lt;d^*\)</span> and for <span class="math inline">\(S\)</span> large enough, the distribution of heights obtained from different simplices containing <span class="math inline">\(x_i\)</span> remains similar, whether <span class="math inline">\(x_i\)</span> is an orthogonal outlier or a regular observation (see <a href="#fig-scheme-outliers" class="quarto-xref">Figure&nbsp;1</a>.B). In contrast, when <span class="math inline">\(n\geq d^*\)</span>, the median of these heights approximately yields the distance of <span class="math inline">\(x_i\)</span> to the main subspace (see <a href="#fig-scheme-outliers" class="quarto-xref">Figure&nbsp;1</a>.C). This distance should be significantly larger when <span class="math inline">\(x_i\)</span> is an orthogonal outlier, compared with regular points, for which these distances are tantamount to the noise.</p>
<div id="fig-scheme-outliers" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-scheme-outliers-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="working_figures/method_schema.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-scheme-outliers-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Example of a dataset with orthogonal outliers and n-simplices. Representation of a dataset with regular data points (blue) belonging to a main subspace of dimension 2 with some noise, and orthogonal outliers (red triangle symbols) in the third dimension. View of two instances of 3-simplices (triangles), one with only regular points (left) and the other one containing one outlier (right). The height drawn from the outlier is close to the height of the regular triangle. Upon adding other regular points to obtain tetrahedrons (4-simplices), the height drawn from the outlier (right) becomes significantly larger than the height drawn from the same point (left) as in .
</figcaption>
</figure>
</div>
<p>To estimate <span class="math inline">\(d^*\)</span> and for a given dimension <span class="math inline">\(n\)</span> tested, we thus randomly sample, for every <span class="math inline">\(x_i\)</span> in <span class="math inline">\(\mathbf{X}\)</span>, <span class="math inline">\(S(n+2)\)</span>-simplices containing <span class="math inline">\(x_i\)</span>, and compute the median of the heights <span class="math inline">\(h_i^n\)</span> associated with these <span class="math inline">\(S\)</span> simplices. Upon considering, as a function of the dimension <span class="math inline">\(n\)</span> tested, the distribution of median heights <span class="math inline">\((h_1^{n},...,h_N^{n})\)</span> (with <span class="math inline">\(1\leq i \leq N\)</span>), we then identify <span class="math inline">\(d^*\)</span> as the dimension at which this function presents a sharp transition towards a highly peaked distribution at zero. To do so, we compute <span class="math inline">\(\tilde{h}_n\)</span>, as the mean of <span class="math inline">\((h_1^{n},...,h_N^{n})\)</span>, and estimate <span class="math inline">\(d^*\)</span> as</p>
<p><span class="math display">\[\begin{equation}
  \bar{n}=\underset{n}{\operatorname{argmax}} \frac{\tilde{h}_{n-1}}{\tilde{h}_{n}}.
  \label{Eq:Dim}
\end{equation}\]</span></p>
<p>Furthermore, we detect orthogonal outliers using the distribution obtained in <span class="math inline">\(\bar{n}\)</span>, as the points for which <span class="math inline">\(h_i^{\bar{n}}\)</span> largely stands out from <span class="math inline">\(\tilde{h}_{\bar{n}}\)</span>. To do so, we compute <span class="math inline">\(\sigma_{\bar{n}}\)</span> the standard deviation observed for the distribution <span class="math inline">\((h_1^{\bar{n}},...,h_N^{\bar{n}})\)</span>, and obtain the set of orthogonal outliers <span class="math inline">\(\mathbf{O}\)</span> as</p>
<p><span id="eq-set-outliers"><span class="math display">\[
  \mathbf{O}= \left\{ i\;|\;h_i^{\bar{n}}&gt; \tilde{h}_{\bar{n}} + c \times \sigma_{\bar{n}} \right\},
\tag{2}\]</span></span></p>
<p>where <span class="math inline">\(c&gt;0\)</span> is a parameter set to achieve a reasonable trade-off between outlier detection and false detection of noisy observations. </p>
</section>
<section id="correcting-the-dimensionality-estimation-for-a-large-outlier-fraction" class="level2">
<h2 class="anchored" data-anchor-id="correcting-the-dimensionality-estimation-for-a-large-outlier-fraction">Correcting the dimensionality estimation for a large outlier fraction</h2>
<p>The method presented in the previous section assumes that at dimension <span class="math inline">\(d^*\)</span>, the median height calculated for each point reflects the distance to the main subspace. This assumption is valid when the fraction of orthogonal outliers is small enough, so that the sampled <span class="math inline">\(n\)</span>-simplex likely contains regular observations only, aside from the evaluated point. However, if the number of outliers gets large enough so that a significant fraction of <span class="math inline">\(n\)</span>-simplices %drawn to compute a height also contains outliers, then the calculated heights would yield the distance between <span class="math inline">\(x_i\)</span> and an outlier-containing hyperplane, whose dimension is larger than a hyperplane containing only regular observations. The apparent dimensionality of the main subspace would thus increase and generates a positive bias on the estimate of <span class="math inline">\(d^*\)</span>.</p>
<p>Specifically, if <span class="math inline">\(\mathbf{X}\)</span> contains a fraction of <span class="math inline">\(p\)</span> outliers, and if we consider <span class="math inline">\(o_{n,p,N}\)</span> the number of outliers drawn after uniformly sampling <span class="math inline">\(n+1\)</span> points (to test the dimension <span class="math inline">\(n\)</span>), then <span class="math inline">\(o_{n,p,N}\)</span> follows a hypergeometric law, with parameters <span class="math inline">\(n+1\)</span>, the fraction of outliers <span class="math inline">\(p=N_o/N\)</span>, and <span class="math inline">\(N\)</span>. Thus, the expected number of outliers drawn from a sampled simplex is <span class="math inline">\((n+1) \times p\)</span>. After estimating <span class="math inline">\(\bar{n}\)</span> (from <a href="#sec-part1" class="quarto-xref">Section&nbsp;3.1</a>), and finding a proportion of outliers <span class="math inline">\(\bar p = |\mathbf{O}|/N\)</span> using <a href="#eq-set-outliers" class="quarto-xref">Equation&nbsp;2</a>, we hence correct <span class="math inline">\(\bar{n}\)</span> by substracting the estimated bias <span class="math inline">\(\delta\)</span>, as the integer part of the expectation of <span class="math inline">\(o_{n,p,N}\)</span>, so the debiased dimensionality estimate <span class="math inline">\(n^*\)</span> is</p>
<p><span class="math display">\[\begin{equation}
  n^* =\bar{n} - \lfloor (\bar{n}+1) \times p \rfloor.
  \label{eq:corrected_n}
\end{equation}\]</span></p>
</section>
<section id="outlier-distance-correction" class="level2">
<h2 class="anchored" data-anchor-id="outlier-distance-correction">Outlier distance correction</h2>
<p>Upon identifying the main subspace containing regular points, our procedure finally corrects the pairwise distances that contain outliers in the matrix <span class="math inline">\(\mathbf{D}\)</span>, in order to apply a MDS that projects the outliers in the main subspace. In the case where the original coordinates cannot be used (e.g, as a result of some transformation or if the distance is non Euclidean), we perform the two following steps: <em>(i)</em> We first apply a MDS on <span class="math inline">\(\mathbf{D}\)</span> to place the points in a euclidean space of dimension <span class="math inline">\(d\)</span>, as a new matrix of coordinates <span class="math inline">\(\tilde{X}\)</span>. <em>(ii)</em> We run a PCA on the full coordinates of the estimated set of regular data points (i.e.&nbsp;<span class="math inline">\(\tilde{X}\setminus O\)</span>), and project the outliers along the first <span class="math inline">\(\bar{n}^*\)</span> principal components of the PCA, since these components are sufficient to generate the main subspace. Using the projected outliers, we accordingly update the pairwise distances in <span class="math inline">\(\mathbf{D}\)</span> to obtain the corrected distance matrix <span class="math inline">\(\mathbf{D^*}\)</span>. Note that in the case where <span class="math inline">\(\mathbf{D}\)</span> derives from a euclidean distance between the original coordinates, we can skip step <em>(i)</em>, and directly run step <em>(ii)</em> on the full coordinates of the estimated set of regular data points.</p>
</section>
</section>
<section id="sec-dataset" class="level1">
<h1>Dataset</h1>
<p>The Human Microbiome Project (HMP) <span class="citation" data-cites="turnbaugh2007human">(<a href="#ref-turnbaugh2007human" role="doc-biblioref">Turnbaugh et al. 2007</a>)</span> dataset represents the microbiome measured across thousands of human subjects. The human microbiome corresponds to the set of microorganisms associated to the human body, including the gut flora, or the skin microbiota. The data used here corresponds to the HMP1 phase of clinical production. The hypervariable region v13 of ribosomal RNA was sequenced for each sample, which allowed to identify and count each specific microorganism, called phylotype. The processing and classification were performed by the HMP using MOTHUR, and made available as low quality counts (https://www.hmpdacc.org/hmp/HMMCP/) <span class="citation" data-cites="turnbaugh2007human">(<a href="#ref-turnbaugh2007human" role="doc-biblioref">Turnbaugh et al. 2007</a>)</span>. We downloaded this dataset, and subsequently, counts were filtered and normalized as previously described <span class="citation" data-cites="legrand2017exploring">(<a href="#ref-legrand2017exploring" role="doc-biblioref">Legrand 2017</a>)</span>. For our analysis, we also restricted our dataset to samples collected in nose and throat. Samples and phylogenies with less than 10 strictly positive counts were filtered out <span class="citation" data-cites="legrand2017exploring">(<a href="#ref-legrand2017exploring" role="doc-biblioref">Legrand 2017</a>)</span>, resulting in an <span class="math inline">\(n \times p\)</span>-matrix where <span class="math inline">\(n=270\)</span> samples and <span class="math inline">\(p=425\)</span> phylotypes. Next, the data distribution was identified with an exponential distribution, by fitting its rate parameter. Normalization was then achieved by replacing the abundances (counts) with the corresponding quantiles. Lastly, the matrix of pairwise distances was obtained using the Euclidean distance.</p>
</section>
<section id="results" class="level1">
<h1>Results</h1>
<p>To assess our method incrementally, we restricted first the analysis to a representative specific site (nose), yielding a <span class="math inline">\(136 \times 425\)</span> array that was further normalized to generate Euclidean pairwise distance matrices (see <a href="#sec-dataset" class="quarto-xref">Section&nbsp;4</a> for more details). Upon running DeCOr-MDS, we estimated the main dimension to be 3, with 9 (6.62%) orthogonal outliers detected, as shown in <a href="#fig-hmp-3D" class="quarto-xref">Figure&nbsp;2</a>.A. This is also supported by another study that the estimated dimension of HMP dataset is 2 or 3 <span class="citation" data-cites="tomassi2021sufficient">(<a href="#ref-tomassi2021sufficient" role="doc-biblioref">Tomassi et al. 2021</a>)</span>. We also computed the average distance between these orthogonal outliers and the barycenter of regular points in the reduced subspace, and obtained a decrease from 1.21 when using MDS to 0.91 when using DeCOr-MDS. This decrease suggests that orthogonal outliers get corrected and projected closer to the regular points, to improve the visualization of the data in the reduced subspace. In <a href="#fig-hmp-3D" class="quarto-xref">Figure&nbsp;2</a>.B, we next aggregated data points from another site (throat) to study how the method performs in this case, yielding a <span class="math inline">\(270 \times 425\)</span> array that was further normalized to generate Euclidean pairwise distance matrices. As augmenting the dataset brings a separate cluster of data points, the dimension of the main dataset was then estimated to be 2, with 13 (5%) orthogonal outliers detected, as shown in <a href="#fig-hmp-3D" class="quarto-xref">Figure&nbsp;2</a>.B. The average distance between the projected outliers and the barycenter of projected regular points are approximately the same when using MDS {(1.46)} as when using DeCOr-MDS (1.45) for nose, and are also approximately the same when using MDS (1.75) to when using DeCOr-MDS (1.74) for throat. This decrease also suggests that orthogonal outliers get corrected and projected closer to the regular points.</p>
<div id="fig-hmp-3D" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-hmp-3D-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="working_figures/hmp_3D.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-hmp-3D-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: Application of DeCOr-MDS on HMP dataset. <strong>A</strong>: Structure restituted on 3 axes using MDS (left) and our procedure (right) using data from the nose site. The points marked with cross represent orthogonal outliers detected by DeCOr-MDS, which are also put closer to regular points after correction. <strong>B</strong> Same comparison as in <strong>A</strong> using data from nose and throat. The two clusters formed by nose and throat have a better seperation using DeCOr-MDS.
</figcaption>
</figure>
</div>
<p>The Python scripts for generating the results are available at <a href="https://github.com/wxli0/DeCOr-MDS">this repository</a>.</p>



</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-BlouvshteinCohenOr2019" class="csl-entry" role="listitem">
Blouvshtein, Leonid, and Cohen Cohen-Or. 2019. <span>“Outlier Detection for Robust Multi Dimensional Scaling.”</span> <em>IEEE Transactions on Pattern Analysis and Machine Intelligence</em> 41: 2273–79.
</div>
<div id="ref-carroll1998multidimensional" class="csl-entry" role="listitem">
Carroll, J Douglas, and Phipps Arabie. 1998. <span>“Multidimensional Scaling.”</span> <em>Measurement, Judgment and Decision Making</em>, 179–250.
</div>
<div id="ref-CaytonDasgupta2006" class="csl-entry" role="listitem">
Cayton, Lawrence, and Sanjoy Dasgupta. 2006. <span>“Robust Euclidean Embedding.”</span> In <em>Proceedings of the 23rd International Conference on Machine Learning</em>, edited by William Cohen and Andrew Moore, 169–76. ACM. <a href="https://doi.org/10.1145/1143844.1143866">https://doi.org/10.1145/1143844.1143866</a>.
</div>
<div id="ref-ForeroGiannakis2012" class="csl-entry" role="listitem">
Forero, Pedro A., and Georgios B. Giannakis. 2012. <span>“Sparsity-Exploiting Robust Multidimensional Scaling.”</span> <em>IEEE Transactions on Signal Processing</em> 60: 4118–34.
</div>
<div id="ref-hout2013multidimensional" class="csl-entry" role="listitem">
Hout, Michael C, Megan H Papesh, and Stephen D Goldinger. 2013. <span>“Multidimensional Scaling.”</span> <em>Wiley Interdisciplinary Reviews: Cognitive Science</em> 4 (1): 93–103.
</div>
<div id="ref-legrand2017exploring" class="csl-entry" role="listitem">
Legrand, Carine. 2017. <span>“Exploring and Controlling for Underlying Structure in Genome and Microbiome Case-Control Association Studies.”</span> PhD thesis, University of Heidelberg.
</div>
<div id="ref-li2023orthogonal" class="csl-entry" role="listitem">
Li, Wanxin, Jules Mirone, Ashok Prasad, Nina Miolane, Carine Legrand, and Khanh Dao Duc. 2023. <span>“Orthogonal Outlier Detection and Dimension Estimation for Improved MDS Embedding of Biological Datasets.”</span> <em>Frontiers in Bioinformatics</em> 3: 1211819.
</div>
<div id="ref-MandanasKotropoulos2017" class="csl-entry" role="listitem">
Mandanas, Fotios D., and Constantine L. Kotropoulos. 2017. <span>“Robust Multidimensional Scaling Using Correntropy Criterion.”</span> <em>IEEE Transactions on Signal Processing</em> 65: 919–32.
</div>
<div id="ref-oh2008biological" class="csl-entry" role="listitem">
Oh, Jung Hun, Jean Gao, and Kevin Rosenblatt. 2008. <span>“Biological Data Outlier Detection Based on Kullback-Leibler Divergence.”</span> In <em>2008 IEEE International Conference on Bioinformatics and Biomedicine</em>, 249–54. IEEE.
</div>
<div id="ref-shieh2009detecting" class="csl-entry" role="listitem">
Shieh, Albert D, and Yeung Sam Hung. 2009. <span>“Detecting Outlier Samples in Microarray Data.”</span> <em>Statistical Applications in Genetics and Molecular Biology</em> 8 (1).
</div>
<div id="ref-sommerville1929" class="csl-entry" role="listitem">
Sommerville, Duncan MacLaren Young. 1929. <em>An Introduction to the Geometry of n Dimensions</em>. London: Methuen.
</div>
<div id="ref-SpenceLewandowsky1989" class="csl-entry" role="listitem">
Spence, Ian, and Stephan Lewandowsky. 1989. <span>“Robust Multidimensional Scaling.”</span> <em>Psychometrika</em> 54: 501–13.
</div>
<div id="ref-tomassi2021sufficient" class="csl-entry" role="listitem">
Tomassi, Diego, Liliana Forzani, Sabrina Duarte, and Ruth M Pfeiffer. 2021. <span>“Sufficient Dimension Reduction for Compositional Data.”</span> <em>Biostatistics</em> 22 (4): 687–705.
</div>
<div id="ref-turnbaugh2007human" class="csl-entry" role="listitem">
Turnbaugh, Peter J, Ruth E Ley, Micah Hamady, Claire M Fraser-Liggett, Rob Knight, and Jeffrey I Gordon. 2007. <span>“The Human Microbiome Project.”</span> <em>Nature</em> 449 (7164): 804–10.
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/bioshape-analysis\.github\.io\/blog\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>