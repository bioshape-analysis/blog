{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Point cloud representation of 3D volumes\"\n",
        "subtitle: \"Application to cryoEM density maps\"\n",
        "\n",
        "engine: \"jupyter\"\n",
        "author:\n",
        "  - name: \"Clément Soubrier\" \n",
        "    email: \"c.soubrier @math.ubc.ca\"\n",
        "    affiliations:\n",
        "      - name: KDD Group\n",
        "        url: \"https://rtviii.xyz/\"\n",
        "\n",
        "  - name: \"Khanh Dao Duc\" \n",
        "    email: \"kdd@math.ubc.ca\"\n",
        "    affiliations:\n",
        "      - name: Department of Mathematics, UBC\n",
        "        url: \"https://www.math.ubc.ca/\"\n",
        "      - name: Department of Computer Science, UBC\n",
        "        url: \"https://www.cs.ubc.ca/\"\n",
        "\n",
        "date: \"August 15 2024\"\n",
        "categories: [biology, bioinformatics]    \n",
        "\n",
        "# Introduction\n",
        "\n",
        "In the context of cryo-EM, many computationaly exhaustive methods rely on simpler representations of cryo-EM density maps to overcome their scalability challenges. There are many choices to the form of the simpler representation, such as vectors (ref vesper) or mixture of gussians (ref). In this post we discuss a format which is probably the simplest and that is using a set of points (called point cloud). \n",
        "\n",
        "This problem can be formulated in a much more general sense rather than cryo-EM. In this sense we are given a probability distribution over $\\mathbb{R}^3$ and we want to generate a set of 3D points that represent this distribution. The naive approach to find such a point cloud is to just sample points from the distribution. Although this approach is guaranteed to find a good representation, it needs lots of points to cover the distribution evenly. Since methods used in this field can be computationally intensive with cubic or higher time complexity, generating a point cloud that covers the give distribution with a smaller point cloud could lead to a significant improvement in their runtime.\n",
        "\n",
        "In this approach, we present two methods for generating a point cloud from a cryo-EM density map or a distribution in general. The first one is based on the Topological Representing Network (TRN) (ref) and the second one combines the usage the Optimal Transport (OT) theory and and some computational geometry object named Centroidal Vornoi Tessellation (CVT).\n",
        "\n",
        "\n",
        "## Data\n",
        "In this post we use a map of Escherichia coli ribosome (EMDB-1717). To download visit [Electron Microscopy Data Bank](https://www.ebi.ac.uk/emdb/EMD-1717) and selecet \"3D volume\" option under the \"Download\" dropdown. Then unzip the downloaded file and put it beside your code. In practice, before using either of these two methods we might threshold the density map to reduce the noice that affects the quality of point clouds.\n",
        "\n",
        "# Topology Representing Networks (TRN)\n",
        "## Summary\n",
        "This method is an iterative method relies on randomly sampling an initial point cloud $r_m(0)_{i=1,\\dots,n}$ from the given probability distribution $p$. At each step $t$, we sample a new point ($r_t$) from $p$, and compute the distnace from points in $r_m(t)$ to $r_t$ and rank them from zero to $n-1$. Then we update the position of points based on:\n",
        "$$r_m(t+1) = r_m(t) + \\epsilon(t)exp(-k_m/\\lambda(t))(r_t - r_m(t)),$$"
      ],
      "id": "9af1bb0b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "\n",
        "def coords_n_by_d(coords_1d=None,N=None,d=3):\n",
        "    if N is None: \n",
        "        assert coords_1d is not None\n",
        "    elif coords_1d is None:\n",
        "        assert N is not None\n",
        "        coords_1d = np.arange(-N//2,N//2)\n",
        "\n",
        "    if d==2:\n",
        "        X = np.meshgrid(coords_1d,coords_1d)\n",
        "    elif d==3:\n",
        "        X = np.meshgrid(coords_1d,coords_1d,coords_1d)\n",
        "    coords = np.zeros((X[0].size,d))\n",
        "    for di in range(d):\n",
        "        coords[:,di] = X[di].flatten()\n",
        "    # make compatible with flatten\n",
        "    if d == 3: coords[:,[0,1]] = coords[:,[1,0]]\n",
        "    elif d == 2: coords[:,[0,1]] = coords[:,[1,0]]\n",
        "\n",
        "    return(coords)\n",
        "\n",
        "def EA_to_R3(phi, theta, psi=None):\n",
        "    \n",
        "    \"\"\"\n",
        "    Makes a rotation matrix from Z-Y-Z Euler angles.\n",
        "    maps image coordinates (x,y,0) view coordinates\n",
        "    See Z_1 Y_2 Z_3 entry in the table \"Proper Euler angles\" at https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix\n",
        "    http://www.gregslabaugh.net/publications/euler.pdf\n",
        "    \"\"\"\n",
        "    R_z  = np.array([[ np.cos(phi), -np.sin(phi),  0],\n",
        "                     [ np.sin(phi),  np.cos(phi),  0],\n",
        "                     [          0,           0,  1]])\n",
        "    R_y  = np.array([[ np.cos(theta),  0,  np.sin(theta)],\n",
        "                     [0,              1,             0],\n",
        "                     [-np.sin(theta),  0,  np.cos(theta)]])\n",
        "    R = np.dot(R_z, R_y)\n",
        "    if psi is not None and psi != 0:\n",
        "        R_in = np.array([[ np.cos(psi), -np.sin(psi),  0],\n",
        "                         [ np.sin(psi),  np.cos(psi),  0],\n",
        "                         [          0,           0,  1]])\n",
        "        R = np.dot(R, R_in);\n",
        "\n",
        "    return R\n",
        "\n",
        "def deg_to_rad(deg): return(deg*np.pi/180)\n",
        "\n",
        "def get_random_quat(num_pts,method = 'sphere'):\n",
        "\n",
        "    u = np.random.rand(3, num_pts)\n",
        "\n",
        "    u1, u2, u3 = [u[x] for x in range(3)]\n",
        "\n",
        "    quat = np.zeros((4, num_pts))\n",
        "    if method == 'hemisphere':\n",
        "        angle = np.pi / 2\n",
        "        \n",
        "    elif method == 'sphere':\n",
        "        angle = 2 * np.pi\n",
        "    else:\n",
        "        assert False, 'use hemisphere or sphere'\n",
        "\n",
        "    quat[0] = np.sqrt(1 - u1) * np.sin(np.pi * u2 / 2)\n",
        "    quat[1] = np.sqrt(1 - u1) * np.cos(np.pi * u2 / 2)\n",
        "    quat[2] = np.sqrt(u1) * np.sin(np.pi * u3 / 2)\n",
        "    quat[3] = np.sqrt(u1) * np.cos(np.pi * u3 / 2)\n",
        "\n",
        "    return np.transpose(quat)\n",
        "\n",
        "def quaternion_to_R(q):\n",
        "    a,b,c,d = q[0], q[1], q[2], q[3]\n",
        "    R = np.array([\n",
        "        [a**2+b**2-c**2-d**2 , 2*b*c-2*a*d , 2*b*d+2*a*c],\n",
        "        [2*b*c+2*a*d , a**2-b**2+c**2-d**2 , 2*c*d-2*a*b],\n",
        "        [2*b*d-2*a*c , 2*c*d+2*a*b , a**2-b**2-c**2+d**2]\n",
        "    ])\n",
        "    return(R)"
      ],
      "id": "9aa5e0ed",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def trn_rm0(map_3d,M,random_seed=None):\n",
        "    \"\"\"\n",
        "    Parameters\n",
        "    ----------\n",
        "        map_3d : numpy.ndarray, shape (N,N,N)\n",
        "            3d map\n",
        "        M : int\n",
        "            number of pseudo atoms\n",
        "            random_seed : int\n",
        "\n",
        "    Returns\n",
        "    ------- \n",
        "        rm0 : numpy.ndarray, shape (M,3)\n",
        "            initial sample of M points from map_3d. probability proportional to density\n",
        "        map_3d_flat : numpy.ndarray, shape (N**3,)\n",
        "            flattened map_3d, normalized to sum to 1\n",
        "        map_3d_idx : numpy.ndarray, shape (N**3,)\n",
        "            array of integers from 0 to N**3-1\n",
        "        xyz : numpy.ndarray, shape (M,3)\n",
        "            coordinates of voxels in map_3d\n",
        "\n",
        "    \"\"\"\n",
        "    cube_length = max(map_3d.shape)\n",
        "    cube_length += cube_length%2\n",
        "    print(map_3d.shape)\n",
        "    print(map_3d)\n",
        "    print(map_3d.sum())\n",
        "    print(cube_length)\n",
        "    map_3d = np.pad(map_3d, ((0, cube_length - map_3d.shape[0]), (0, cube_length - map_3d.shape[1]), (0, cube_length - map_3d.shape[2])), 'minimum')\n",
        "    #print(map_3d.shape)\n",
        "    assert np.unique(map_3d.shape).size == 1, 'map must be cube, not non-cubic rectangular parallelepiped'\n",
        "    N = map_3d.shape[0]\n",
        "    assert N%2 == 0, 'N must be even'\n",
        "    print(map_3d.sum())\n",
        "    print(map_3d)\n",
        "    map_3d /= map_3d.sum() # 3d map to probability density\n",
        "    print(map_3d.sum())\n",
        "    print(np.where(np.isnan(map_3d)==True))\n",
        "    print(map_3d)\n",
        "    map_3d_flat = map_3d.flatten()\n",
        "    map_3d_idx = np.arange(map_3d_flat.shape[0])\n",
        "    if random_seed is not None: np.random.seed(seed=random_seed)\n",
        "\n",
        "    # this scales with M (the number of chosen items), not map_3d_idx (the possibilities to choose from)\n",
        "    samples_idx = np.random.choice(map_3d_idx,size=M,replace=True,p=map_3d_flat) # chosen voxel indeces\n",
        "    coords_1d = np.arange(-N//2,N//2)\n",
        "    xyz = coords.coords_n_by_d(coords_1d,d=3)\n",
        "    rm0 = xyz[samples_idx] # pick out coordinates that where chosen. note that this assumes map_3d_idx matches with rows of xyz\n",
        "    return rm0,map_3d_flat,map_3d_idx,xyz,coords_1d\n",
        "\n",
        "def trn_iterate(rm0,\n",
        "    map_3d_flat,\n",
        "    map_3d_idx,\n",
        "    xyz,\n",
        "    n_save=10,\n",
        "    e0=0.3,\n",
        "    ef=0.05,\n",
        "    l0=None,\n",
        "    lf=0.5,\n",
        "    tf=None,\n",
        "    do_log=True,\n",
        "    log_n=10,\n",
        "):\n",
        "    \"\"\"\n",
        "    topology representing network\n",
        "    diffuses pseudo atoms to cover probability distribution uniformly\n",
        "    evolves by equation rm[t+1] = rm[t] + e exp[-km/l] * (r - rm[t]), where\n",
        "        m indexes the pseudo atoms\n",
        "        rm is the 3D cartesian location of the mth pseudo atom\n",
        "        t is time\n",
        "        r is a randomly sampled point from the initial 3d density (independent of t and therefore can be precomputed)\n",
        "        e is a time depedent step size and evolves as e0(ef/e0)**(t/tf)\n",
        "        km is the rank of the rm to r. how close rm is to r, compared with the other rm's, expressed as a rank\n",
        "        l is a time depedent scaling of km size and evolves as l0(lf/l0)**(t/tf)\n",
        "        tf is the total time steps\n",
        "    see ref \n",
        "        Zhang, Y., Krieger, J., Mikulska-Ruminska, K., Kaynak, B., Sorzano, C. O. S., Carazo, J. M., … Bahar, I. (2021). \n",
        "        State-dependent sequential allostery exhibited by chaperonin TRiC/CCT revealed by network analysis of Cryo-EM maps. \n",
        "        Progress in Biophysics and Molecular Biology, 160, 104–120. \n",
        "        http://doi.org/10.1016/j.pbiomolbio.2020.08.006\n",
        "    and python code in prody \n",
        "        http://prody.csb.pitt.edu/manual/reference/proteins/emdfile.html#TRNET\n",
        "        https://github.com/prody/ProDy/blob/697220825ebc7498d64f4e82f53bb7ff6d98027c/prody/proteins/emdfile.py#L466\n",
        "\n",
        "    Parameters\n",
        "    ----------\n",
        "        rm0 : numpy.ndarray, shape (M,3)\n",
        "            initial sample of M points from map_3d. probability proportional to density\n",
        "        map_3d_flat : numpy.ndarray, shape (N**3,)\n",
        "            flattened map_3d, normalized to sum to 1\n",
        "        map_3d_idx : numpy.ndarray, shape (N**3,)\n",
        "            array of integers from 0 to N**3-1\n",
        "        xyz : numpy.ndarray, shape (M,3)\n",
        "            coordinates of voxels in map_3d\n",
        "        n_save : int\n",
        "            number of steps to save (evenly spaced out), in addition to initial step 0\n",
        "        e0 : float\n",
        "            initial step size\n",
        "        ef : float\n",
        "            final step size\n",
        "        l0 : float\n",
        "            initial scaling of rank. larger tightens things up (pulls together). smaller spreads things out\n",
        "        lf : float\n",
        "            initial scaling of rank\n",
        "        tf : int\n",
        "            total steps\n",
        "        do_log : bool\n",
        "        log_n : int\n",
        "            how many times to output log over the course of time steps\n",
        "    \n",
        "    Returns\n",
        "    -------\n",
        "    rms : numpy.ndarray, shape (n_save + 1, M, 3)\n",
        "        location of pseudo atoms, over (evenly spaced intervals of) iterations. \n",
        "        0th and 1st iteration are right after each other with nothing in between\n",
        "    rs : numpy.ndarray, shape (tf+1,3)\n",
        "        sampled points\n",
        "    ts_save : numpy.ndarray, shape (n_save + 1,3), dtype np.int32\n",
        "        time points corresponding to rms\n",
        "    \"\"\"\n",
        "    M = rm0.shape[0]\n",
        "    d = rm0.shape[1]\n",
        "    if l0 is None: 0.067*M\n",
        "    if tf is None: tf=200*M\n",
        "    rms = np.empty((n_save+1,M,d))\n",
        "    rms[0] = rm0\n",
        "    rs = np.empty((tf+1,d))\n",
        "    ts_save = np.empty((n_save+1)).astype(np.int32)\n",
        "\n",
        "    r_idxs = np.random.choice(map_3d_idx,p=map_3d_flat,size=tf) # precompute\n",
        "    rm = rm0\n",
        "    save_idx=0\n",
        "\n",
        "    for t in range(tf):\n",
        "        #if do_log and (t % (tf//log_n) == 0): print(t)\n",
        "        r_idx = r_idxs[t]\n",
        "        r = xyz[r_idx]\n",
        "        rs[t]=r\n",
        "        dist2 = ((r - rm)**2).sum(1) # usually sum over xyz. just need relative rank in one time step, so can use dist2 vs dist\n",
        "        order = dist2.argsort()\n",
        "        rank = order.argsort().reshape(-1,1)\n",
        "        l = l0*(lf/l0)**(t/tf)\n",
        "        e = e0*(ef/e0)**(t/tf)\n",
        "        rm = rm + e*np.exp(-rank/l)*(r-rm)\n",
        "        if do_log and ((t % (tf//n_save) == 0) or (t == tf-1)): \n",
        "            rms[save_idx] = rm\n",
        "            ts_save[save_idx] = t\n",
        "            save_idx+=1\n",
        "    return rms,rs,ts_save\n",
        "\n",
        "def trn_wrapper(map_3d,\n",
        "                                threshold,\n",
        "                                M=1000,\n",
        "                                random_seed=None,\n",
        "                                n_save=10,\n",
        "                                e0=0.3,\n",
        "                                ef=0.05,\n",
        "                                l0_factor=0.005,\n",
        "                                lf=0.5,\n",
        "                                tf_factor=8, # typically M*8\n",
        "                                do_log=True,\n",
        "                                log_n=10\n",
        "                                ):\n",
        "    map_th = map_3d.copy()\n",
        "    map_th[map_th < threshold] = 0\n",
        "    rm0,map_3d_flat,map_3d_idx,xyz,coords_1d = trn_rm0(map_th,M=M,random_seed=random_seed)\n",
        "    rms,rs,ts_save = trn_iterate(rm0,map_3d_flat,map_3d_idx,xyz,n_save=n_save,e0=e0,ef=ef,l0=M*l0_factor,lf=lf,tf=M*tf_factor,do_log=do_log,log_n=log_n)\n",
        "    map_3d_th_norm = map_3d_flat.reshape(map_3d.shape)\n",
        "    return rm0,map_3d_th_norm,map_3d_idx,xyz,coords_1d,rms,rs,ts_save"
      ],
      "id": "7071702a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Centroidal Vornoi Tessellation (CVT)\n",
        "\n",
        "# Visualization\n"
      ],
      "id": "cfefbc97"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "C:\\Users\\artaj\\AppData\\Local\\Programs\\Python\\Python310\\share\\jupyter\\kernels\\python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}