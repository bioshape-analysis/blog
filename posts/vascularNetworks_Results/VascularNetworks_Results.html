<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Ali Fele Paranj">
<meta name="dcterms.date" content="2024-12-10">

<title>Vascular Networks Results – bioshape-analysis</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-e26003cea8cd680ca0c55a263523d882.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-659650fc26dc25888fc1474f317bb8ac.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">bioshape-analysis</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Vascular Networks Results</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">Graph theory</div>
                <div class="quarto-category">Vascular Networks</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Ali Fele Paranj </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">December 10, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#results" id="toc-results" class="nav-link active" data-scroll-target="#results">Results</a>
  <ul class="collapse">
  <li><a href="#enhanced-loop-detection-algorithm" id="toc-enhanced-loop-detection-algorithm" class="nav-link" data-scroll-target="#enhanced-loop-detection-algorithm">Enhanced Loop Detection Algorithm</a></li>
  <li><a href="#statistical-analysis-of-loops" id="toc-statistical-analysis-of-loops" class="nav-link" data-scroll-target="#statistical-analysis-of-loops">Statistical Analysis of Loops</a></li>
  <li><a href="#geometric-shape-analysis-fréchet-and-hausdorff-distances" id="toc-geometric-shape-analysis-fréchet-and-hausdorff-distances" class="nav-link" data-scroll-target="#geometric-shape-analysis-fréchet-and-hausdorff-distances">Geometric Shape Analysis: Fréchet and Hausdorff Distances</a>
  <ul class="collapse">
  <li><a href="#fréchet-distance" id="toc-fréchet-distance" class="nav-link" data-scroll-target="#fréchet-distance">Fréchet Distance</a></li>
  <li><a href="#hausdorff-distance" id="toc-hausdorff-distance" class="nav-link" data-scroll-target="#hausdorff-distance">Hausdorff Distance</a></li>
  <li><a href="#interpretation-of-heatmap-1" id="toc-interpretation-of-heatmap-1" class="nav-link" data-scroll-target="#interpretation-of-heatmap-1">Interpretation of Heatmap</a></li>
  <li><a href="#comparison-of-metrics" id="toc-comparison-of-metrics" class="nav-link" data-scroll-target="#comparison-of-metrics">Comparison of Metrics</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#clustering" id="toc-clustering" class="nav-link" data-scroll-target="#clustering">Clustering</a></li>
  <li><a href="#feature-transformation-and-dimensionality-reduction-in-shape-analysis" id="toc-feature-transformation-and-dimensionality-reduction-in-shape-analysis" class="nav-link" data-scroll-target="#feature-transformation-and-dimensionality-reduction-in-shape-analysis">Feature Transformation and Dimensionality Reduction in Shape Analysis</a>
  <ul class="collapse">
  <li><a href="#dimensionality-reduction" id="toc-dimensionality-reduction" class="nav-link" data-scroll-target="#dimensionality-reduction">Dimensionality Reduction</a>
  <ul class="collapse">
  <li><a href="#t-sne-t-distributed-stochastic-neighbor-embedding" id="toc-t-sne-t-distributed-stochastic-neighbor-embedding" class="nav-link" data-scroll-target="#t-sne-t-distributed-stochastic-neighbor-embedding">t-SNE (t-Distributed Stochastic Neighbor Embedding)</a></li>
  <li><a href="#umap-uniform-manifold-approximation-and-projection" id="toc-umap-uniform-manifold-approximation-and-projection" class="nav-link" data-scroll-target="#umap-uniform-manifold-approximation-and-projection">UMAP (Uniform Manifold Approximation and Projection)</a></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  </ul></li>
  <li><a href="#appendix" id="toc-appendix" class="nav-link" data-scroll-target="#appendix">Appendix</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="results" class="level1">
<h1>Results</h1>
<p>We have performed different goemetrical analysis and clustering methods on the loops tructure of the generated graphs by Branching-Annihilating-Random-Walker model. We need to highlight that assigning meaningful biological explanations was not the focus of this study.</p>
<p>In summary, we did the following improvements to the model using the concepts that we learned in this course: * Enhanced Loop Detection Algorithms * Multiscale Loop Detection WorkFlow * Statistical Analysis of Loops * Loop Structure Clustering * Geometrical Analysis of Loops</p>
<section id="enhanced-loop-detection-algorithm" class="level2">
<h2 class="anchored" data-anchor-id="enhanced-loop-detection-algorithm">Enhanced Loop Detection Algorithm</h2>
<p>Before, we used to generate .png images of the simulation result (see figures above) and then perform image analysis to detect loops. For instance we have convolving the image with 4-connectivity and 8-connectivity matrices to extract the graph structres present in the images. In the new approch, instead, we managed to record the structre of the network in a NetworkX datastructre. This is not easy task to perform without smart useage of the object oriented programming structure for the code. We organized our code into following classes</p>
<p><img src="images/plantuml.svg" class="img-fluid"></p>
<p>Using this structure, we can record the graph structure of the generated networks as a NetworkX dataframe. Then we can use some of the built-in functions of this library to get the loops (cycles) of the network. However, since the generated networks are large, finding all of the loops (of all scales) is computationally very costly. Instead, we first found a minimal set of cycles in the graph that forms a basis for the cycles space. I.e. we found the loops that can be combined (by symmetric difference) to generate new loops. The following figure shows the basis loops highlighted on the graph.</p>
<p><img src="images/improvedDetection.png" class="img-fluid"></p>
<p>As mentioned above, detected cycles are the basis cycles. The space of all cycles in a graph form a vector space and the basis cycles is a basis for that space. In other words, these cycles are all the cycles necessary to generate all of the cycles in the graph. The addition operation between two cycles is the symmetric difference of their edge set (or XOR of their edges). We can combined the basis cycles to generate higher level (and lower level) structure as shown below.</p>
<p><img src="images/multiScaleCycles.png" class="img-fluid"></p>
<p>We can also extract and scale all of the loops for further analysis. The following figure shows all the loops in the network</p>
<p><img src="images/grid_basis.png" class="img-fluid"></p>
<p>The following figures shows some of the loop strucgures that we can get by combining the loops above.</p>
<p><img src="images/grid_Generated.png" class="img-fluid"></p>
</section>
<section id="statistical-analysis-of-loops" class="level2">
<h2 class="anchored" data-anchor-id="statistical-analysis-of-loops">Statistical Analysis of Loops</h2>
<p>The mechanism that generated the vascular networks is an stochastic process (Branching process + Simple Radnom Walk process + local interactions (annihilation)). So we need to use statistical notions to make some observations. In the figure below, the histogram of the cycle length is plotted. The interesting observation is the fact that the number of cycles is exponentially distributed (with respect to the Cycle length). The slope of this line (on log-log plot) can reveal some very important facts about the universality class that our model belongs to. Not only this is very interesting and important from theoretical point of view, but also it can have very useful practical applications. For instance, in comparing the simulated network with real vascualr networks, this slope can be one of the components of comparison.</p>
<p><img src="images/CountVsLengthLogLog.png" class="img-fluid"></p>
<p>Furthremore, it is instructive to study the correlation matrix between some of the features of the loop.</p>
<p><img src="images/FeatureCorrelationMatrix.png" class="img-fluid"></p>
</section>
<section id="geometric-shape-analysis-fréchet-and-hausdorff-distances" class="level2">
<h2 class="anchored" data-anchor-id="geometric-shape-analysis-fréchet-and-hausdorff-distances">Geometric Shape Analysis: Fréchet and Hausdorff Distances</h2>
<p>In geometric shape analysis, comparing cycles involves quantifying their similarity based on the spatial arrangement of points in each cycle. Two widely used measures for such comparisons are the <strong>Fréchet Distance</strong> and the <strong>Hausdorff Distance</strong>. These metrics provide different insights into the relationship between cycles, and their results can be visualized as heatmaps of pairwise distances.</p>
<section id="fréchet-distance" class="level3">
<h3 class="anchored" data-anchor-id="fréchet-distance">Fréchet Distance</h3>
<p>The <strong>Fréchet Distance</strong> between two curves $ A = {a(t) t } $ and $ B = {b(t) t } $ is defined as:</p>
<p><span class="math display">\[
d_F(A, B) = \inf_{\alpha, \beta} \max_{t \in [0,1]} \| a(\alpha(t)) - b(\beta(t)) \|,
\]</span></p>
<p>where:</p>
<ul>
<li>$ (t) $ and $ (t) $ are continuous, non-decreasing reparameterizations of the curves $ A $ and $ B $.</li>
<li>$ | | $ denotes the Euclidean norm.</li>
<li>The infimum is taken over all possible parameterizations $ $ and $ $.</li>
</ul>
<section id="interpretation-of-heatmap" class="level4">
<h4 class="anchored" data-anchor-id="interpretation-of-heatmap">Interpretation of Heatmap</h4>
<p>The heatmap for the Fréchet distance shows the pairwise distances between all cycles. Each entry $ (i, j) $ in the heatmap represents $ d_F(C_i, C_j) $, the Fréchet distance between cycle $ C_i $ and cycle $ C_j $. Key insights include:</p>
<ul>
<li><strong>Small Values:</strong> Cycles with low Fréchet distances are geometrically similar in terms of overall shape and trajectory.</li>
<li><strong>Large Values:</strong> Larger distances indicate significant differences in the geometry or shape of the cycles.</li>
</ul>
<p>The heatmap highlights clusters of similar cycles and outliers with unique geometries.</p>
<p><img src="images/FrechetDistance.png" class="img-fluid"></p>
</section>
</section>
<section id="hausdorff-distance" class="level3">
<h3 class="anchored" data-anchor-id="hausdorff-distance">Hausdorff Distance</h3>
<p>The <strong>Hausdorff Distance</strong> between two sets of points $ A $ and $ B $ is defined as:</p>
<p><span class="math display">\[
d_H(A, B) = \max \{ \sup_{a \in A} \inf_{b \in B} \| a - b \|, \sup_{b \in B} \inf_{a \in A} \| b - a \| \}.
\]</span></p>
<p>This can be broken down into:</p>
<ul>
<li>$ <em>{a A} </em>{b B} | a - b | $: The maximum distance from a point in $ A $ to the closest point in $ B $.</li>
<li>$ <em>{b B} </em>{a A} | b - a | $: The maximum distance from a point in $ B $ to the closest point in $ A $.</li>
</ul>
<p>The Hausdorff distance quantifies the greatest deviation between the two sets of points, considering how well one set covers the other.</p>
</section>
<section id="interpretation-of-heatmap-1" class="level3">
<h3 class="anchored" data-anchor-id="interpretation-of-heatmap-1">Interpretation of Heatmap</h3>
<p>The heatmap for the Hausdorff distance shows pairwise distances between cycles. Each entry $ (i, j) $ represents $ d_H(C_i, C_j) $, the Hausdorff distance between cycle $ C_i $ and cycle $ C_j $. Key insights include:</p>
<ul>
<li><strong>Small Values:</strong> Indicates that the points of one cycle are closely aligned with the points of another cycle.</li>
<li><strong>Large Values:</strong> Reflects that one cycle has points significantly farther away from the other, suggesting geometric dissimilarity.</li>
</ul>
<p>The heatmap highlights cycles that are well-aligned (small distances) and those that are far apart in terms of shape.</p>
<p><img src="images/HausdorffDistance.png" class="img-fluid"></p>
</section>
<section id="comparison-of-metrics" class="level3">
<h3 class="anchored" data-anchor-id="comparison-of-metrics">Comparison of Metrics</h3>
<ul>
<li><strong>Fréchet Distance:</strong> Sensitive to the ordering of points along the curves, making it suitable for comparing trajectories or continuous shapes.</li>
<li><strong>Hausdorff Distance:</strong> Ignores the order of points and focuses on the maximum deviation between sets, making it useful for analyzing shape coverage.</li>
</ul>
<p>Both metrics complement each other in analyzing the geometric properties of cycles. While the Fréchet distance emphasizes trajectory similarity, the Hausdorff distance focuses on the extent of shape overlap.</p>
</section>
</section>
</section>
<section id="clustering" class="level1">
<h1>Clustering</h1>
<section id="features-used-for-clustering" class="level4">
<h4 class="anchored" data-anchor-id="features-used-for-clustering">Features Used for Clustering</h4>
<p>For each cycle in the networks, the following features are extracted:</p>
<ul>
<li>Length: Total length of the cycle, calculated as the sum of the lengths of all edges in the cycle.</li>
<li>Area: Enclosed area of the cycle, approximated using the Shoelace formula.</li>
<li>Compactness: Ratio of the area to the square of the perimeter (area/perimeter<span class="math inline">\(^2\)</span>).</li>
<li>Centroid: The geometric center of the cycle, defined as the mean of the x- and y-coordinates of all points in the cycle.</li>
</ul>
</section>
<section id="principal-component-analysis-pca" class="level4">
<h4 class="anchored" data-anchor-id="principal-component-analysis-pca">Principal Component Analysis (PCA)</h4>
<p>PCA is used for dimensionality reduction by projecting high-dimensional data onto a lower-dimensional subspace while preserving as much variance as possible. The original features (length, area, compactness, centroid) are normalized and reduced to two dimensions using PCA. The first two principal components capture the maximum variance in the data, allowing clustering methods to operate in a simplified feature space.</p>
<ul>
<li>Interpretation: The axes in the PCA-reduced space represent linear combinations of the original features. Clusters in this space indicate groups of cycles with similar characteristics.</li>
</ul>
<p><img src="images/PCAClustering1.png" class="img-fluid"></p>
</section>
</section>
<section id="feature-transformation-and-dimensionality-reduction-in-shape-analysis" class="level1">
<h1>Feature Transformation and Dimensionality Reduction in Shape Analysis</h1>
<p>In analyzing geometric properties of cycles in networks, high-dimensional feature spaces often obscure relationships between cycles. This section describes the use of feature engineering and nonlinear dimensionality reduction techniques (<strong>t-SNE</strong> and <strong>UMAP</strong>) to uncover hidden patterns, simplify visualization, and enhance interpretability. The outputs are 2D visualizations that highlight structural and functional groupings within the data. The following composite features were derived:</p>
<ul>
<li><strong>Area-to-Length Ratio:</strong> Computed as $ $. This feature differentiates between compact cycles (high ratio) and elongated cycles (low ratio).</li>
<li><strong>Normalized Compactness:</strong> Computed as $ $. This feature accounts for the relative efficiency of cycles in enclosing their area.</li>
</ul>
<section id="dimensionality-reduction" class="level2">
<h2 class="anchored" data-anchor-id="dimensionality-reduction">Dimensionality Reduction</h2>
<p>Nonlinear dimensionality reduction methods project high-dimensional data into a lower-dimensional space while preserving specific structural properties.</p>
<section id="t-sne-t-distributed-stochastic-neighbor-embedding" class="level3">
<h3 class="anchored" data-anchor-id="t-sne-t-distributed-stochastic-neighbor-embedding">t-SNE (t-Distributed Stochastic Neighbor Embedding)</h3>
<p><strong>t-SNE</strong> minimizes the divergence between probability distributions over pairwise distances in high-dimensional and low-dimensional spaces. It focuses on preserving local structures (relationships between nearby points) and is particularly effective at uncovering clusters. The key parameters are <strong>Perplexity:</strong> Controls the balance between local and global structure (default: 30), and <strong>Output Dimension:</strong> Reduced to 2D for visualization.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/TSNECycles.png" class="img-fluid figure-img"></p>
<figcaption>Some notes to interpret the plot: that cycles forming tight clusters share strong similarities in features such as length, area, or compactness. Isolated points (outliers) indicate rare or unique geometries. t-SNE emphasizes local structures, making it ideal for detecting smaller, tightly-knit groups.</figcaption>
</figure>
</div>
</section>
<section id="umap-uniform-manifold-approximation-and-projection" class="level3">
<h3 class="anchored" data-anchor-id="umap-uniform-manifold-approximation-and-projection">UMAP (Uniform Manifold Approximation and Projection)</h3>
<p><strong>UMAP</strong> approximates the high-dimensional data manifold and optimally preserves both local and global structures. It provides more interpretable embeddings with smooth transitions between clusters. The key parameters are <strong>Number of Neighbors:</strong> Defines the size of the local neighborhood considered for embedding (default: 15), and <strong>Output Dimension:</strong> Reduced to 2D for visualization.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/UMap.png" class="img-fluid figure-img"></p>
<figcaption>Some notes to interpret the plot: UMAP preserves both local and global structures, making it suitable for analyzing large-scale patterns. Transitions between clusters indicate gradual changes in feature space, useful for understanding progression or hierarchy in cycle characteristics. Dense clusters suggest strong feature alignment, while sparse areas highlight feature variability.</figcaption>
</figure>
</div>
</section>
<section id="conclusion" class="level3">
<h3 class="anchored" data-anchor-id="conclusion">Conclusion</h3>
<p>We used a stochastic process (Branching Annihilating Random Walker) to generate some random networks (that resembes the vascular networks). Then we translated this structure to a networkX data frame for easier processing. We extracted the cycle basis for the cycle space of the graph and using the symmetric difference operation we generated new cycles (of different scales). Then performed different statistical and geometrical analysis on the shape of the loops in the graph. Also we calculated different features for the graph and used dimnsionality reduction methods to see if we can observe any structures (clusters) in low dimension.</p>
</section>
</section>
<section id="appendix" class="level2">
<h2 class="anchored" data-anchor-id="appendix">Appendix</h2>
For a graph, the Laplacian matrix contains the information on the in/out flow of stuff into the nodes.
<p align="center">
<img src="images/graph1.png" alt="BARW" width="400" height="300">
</p>
<p>Then the Laplacian matrix is given by <span class="math display">\[ D = \begin{pmatrix}
        2 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
        0 &amp; 4 &amp; 0 &amp; 0 &amp; 0 \\
        0 &amp; 0 &amp; 2 &amp; 0 &amp; 0 \\
        0 &amp; 0 &amp; 0 &amp; 2 &amp; 0 \\
        0 &amp; 0 &amp; 0 &amp; 0 &amp; 2
    \end{pmatrix}, \]</span> and the adjacency matrix is given by <span class="math display">\[ A = \begin{pmatrix}
        0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 \\
        1 &amp; 0 &amp; 1 &amp; 1 &amp; 1 \\
        1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
        0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 \\
        0 &amp; 1 &amp; 0 &amp; 1 &amp; 0
    \end{pmatrix}, \]</span> and the Laplacian matrix is given by <span class="math display">\[ L = D -A =
    \begin{pmatrix}
        2 &amp; -1 &amp; -1 &amp; 0 &amp; 0 \\
        -1 &amp; 4 &amp; -1 &amp; -1 &amp; -1 \\
        -1 &amp; -1 &amp; 2 &amp; 0 &amp; 0 \\
        0 &amp; -1 &amp; 0 &amp; 2 &amp; -1 \\
        0 &amp; -1 &amp; 0 &amp; -1 &amp; 2
    \end{pmatrix}.
    \]</span> It is straight forward to generalize the notion of Laplacian matrix to the weighed graphs, where the degree matrix $ D $, the diagonal entries will be the sum of all weights of the edges connected to that node, and for the adjacency matrix, instead of zeros and ones, we will have the weights of the connections..</p>
<p>There is also another way of finding the Laplacian matrix by using the notion of incidence matrix. To do so, we first need to make our graph to be directed. Any combination of the direction on the edges will do the job and will yield in a correct answer. For instance, consider the following directed graph</p>
For a graph, the Laplacian matrix contains the information on the in/out flow of stuff into the nodes.
<p align="center">
<img src="images/graph2.png" alt="BARW" width="400" height="300">
</p>
<p>Its incidence matrix will be <span class="math display">\[
    M = \begin{pmatrix}
        -1 &amp; 1  &amp; 0  &amp; 0  &amp; 0  &amp; 0  \\
        0  &amp; -1 &amp; 1  &amp; -1 &amp; 0  &amp; -1 \\
        1  &amp; 0  &amp; -1 &amp; 0  &amp; 0  &amp; 0  \\
        0  &amp; 0  &amp; 0  &amp; 1  &amp; 1  &amp; 0  \\
        0  &amp; 0  &amp; 0  &amp; 0  &amp; -1 &amp; 1  \\
    \end{pmatrix}
    \]</span> The Laplacian matrix can be written as <span class="math display">\[ \mathcal{L} = M M^T. \]</span> Note that in the case of the weighed graphs, we will have <span class="math display">\[ \mathcal{L} = M W M^T \tag{1}\]</span> where $ W $ is a diagonal matrix containing the weights. These computations can be done easily on the NetworkX.</p>
<p>The incidence matrix is also very useful in calculating the pressure difference between nodes of a particular edge. Let <span class="math inline">\(\Delta = M^T\)</span>. Then given the vector <span class="math inline">\(P\)</span> that contains the pressures on the vertices, then the pressure difference on the edges will be given by <span class="math inline">\(\Delta P\)</span>, where <span class="math inline">\(\Delta\)</span> is the transpose of the incidence matrix. This comes in handy when we want to calculate the flow of the edges which will be given by <span class="math display">\[ \bf{Q} = \bf{C} L^{-1} \bf{\Delta} \bf{P}, \tag{2} \]</span> where $ C $ is a diagonal matrix of the conductance of the edges, <span class="math inline">\(L\)</span> is the diagonal matrix of the ``length’’ of each edge, <span class="math inline">\(\Delta\)</span> is the transpose of the incidence matrix, and <span class="math inline">\(P\)</span> is the pressure on the nodes. <span class="math inline">\(Q\)</span> is the flow of the edges. In this particular example we are assuming that the relation between flow and the pressure difference is <span class="math inline">\(Q_e = C_e (p_i - p_j)/L\)</span>. But we can have many other choices.</p>
<p>Knowing the sources and sinks on the nodes, the pressure can be determined by the Kirchhoff law <span class="math display">\[ \mathcal{L} \bf{P} = \bf{q}, \]</span> where the vector $ q $ is the sources and the sinks values for each node. This is the same as solving the . This can also be written in terms of the flow, i.e. <span class="math display">\[ \Delta^T \bf{Q} = \bf{q}. \]</span> By $ (2) $ we can write <span class="math display">\[ (\bf{\Delta}^T \bf{C}\bf{L}^{-1}\Delta) \bf{P} = \bf{q}. \]</span> Since $ = M^T $, the expression inside the parentheses is clearly Equation (1).</p>
<p>Similar to the Poisson equation on the graph which is equivalent Kirchhoff’s law, we can solve other types of heat and wave equations on the graph as well. The Laplacian matrix play a key role. <span class="math display">\[ \frac{\partial p}{\partial t} = - \mathcal{L} p + q,  \]</span> for the heat equation, and <span class="math display">\[ \frac{\partial^2 p}{\partial t^2} = -\mathcal{L}p + q, \]</span> for the wave equation.</p>
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">References</h2>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/bioshape-analysis\.github\.io\/blog\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>